<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>周周博客</title>
  
  <subtitle>很高兴能帮到你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhousaito.top/"/>
  <updated>2019-11-13T01:07:32.832Z</updated>
  <id>http://zhousaito.top/</id>
  
  <author>
    <name>Zhou Saito</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zhousaito.top/2019/11/13/hello-world/"/>
    <id>http://zhousaito.top/2019/11/13/hello-world/</id>
    <published>2019-11-13T01:07:32.832Z</published>
    <updated>2019-11-13T01:07:32.832Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>自己的域名绑定github博客</title>
    <link href="http://zhousaito.top/2019/11/11/2019-11-11-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9Agithub/"/>
    <id>http://zhousaito.top/2019/11/11/2019-11-11-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9Agithub/</id>
    <published>2019-11-11T05:52:57.099Z</published>
    <updated>2019-12-07T02:18:03.067Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>先有自己的域名，然后才有后续的操作</p><blockquote><p>如：zhousaito.top</p></blockquote><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p><img src="http://q0w6zzhek.bkt.clouddn.com/1.png" alt=""></p><blockquote><p>找到自己博客的位置，然后在根路径下添加 CNAME这个文件</p></blockquote><p><img src="http://q0w6zzhek.bkt.clouddn.com/2.png" alt=""></p><blockquote><p>然后到自己的 xx.github.io 的位置上进入的settings</p><p><img src="http://q0w6zzhek.bkt.clouddn.com/3.png" alt=""></p></blockquote><p><img src="http://q0w6zzhek.bkt.clouddn.com/4.png" alt=""></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote><p>去买域名的地方去加两个解析，解析自己的 xx.github.io 地址的ip</p></blockquote><h4 id="3-1-确定xx-github-io的ip地址"><a href="#3-1-确定xx-github-io的ip地址" class="headerlink" title="3.1 确定xx.github.io的ip地址"></a>3.1 确定xx.github.io的ip地址</h4><blockquote><p>ping <a href="http://www.ZhouSilverBullet.github.io" target="_blank" rel="noopener">www.ZhouSilverBullet.github.io</a></p></blockquote><p><img src="http://q0w6zzhek.bkt.clouddn.com/5.png" alt=""></p><blockquote><p>图上的185.199.108.153 就是对于的ip了</p></blockquote><h4 id="3-2-去买域名的地方绑定解析"><a href="#3-2-去买域名的地方绑定解析" class="headerlink" title="3.2 去买域名的地方绑定解析"></a>3.2 去买域名的地方绑定解析</h4><p><img src="http://q0w6zzhek.bkt.clouddn.com/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;h3 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="博客搭建指南" scheme="http://zhousaito.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="个人博客搭建" scheme="http://zhousaito.top/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>2019-07-11-想到学的</title>
    <link href="http://zhousaito.top/2019/11/11/2019-07-11-%E6%83%B3%E5%88%B0%E5%AD%A6%E7%9A%84/"/>
    <id>http://zhousaito.top/2019/11/11/2019-07-11-%E6%83%B3%E5%88%B0%E5%AD%A6%E7%9A%84/</id>
    <published>2019-11-11T05:40:29.459Z</published>
    <updated>2019-11-11T05:40:29.459Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>webview的优化</p><blockquote><p><a href="https://juejin.im/post/5d2605f8f265da1bc23fa07c?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5d2605f8f265da1bc23fa07c?utm_source=gold_browser_extension</a></p></blockquote></li><li><p>javaweb简单的知识</p></li><li><p>Vue </p><blockquote><p>idea 添加 VUE 的语法支持和开发</p><p><a href="https://blog.csdn.net/sl1990129/article/details/83794024" target="_blank" rel="noopener">https://blog.csdn.net/sl1990129/article/details/83794024</a></p><p>getter 获取值</p><p>Setter 比较赋值了，监视当前属性值的变化</p><p>回调函数满足的三个条件：1.你定义的 2.你没有调用 3.但最终它执行了</p><p>双向管理</p><p>虚拟dom</p><p><strong>class和style绑定</strong></p><p>“ ‘a’ “ 相当于写死了  “a” 这个a是个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态确定类名 --&gt;</span><br><span class="line">&lt;p :class=&quot;&#123;aClass: isA, bClass: isB&#125;&quot;&gt;</span><br><span class="line">  xxx是个对象</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style来确定 --&gt;</span><br><span class="line">&lt;p :style=&quot;&#123;color: firstColor, fontSize: fontSize +&apos;px&apos;&#125;&quot;&gt;</span><br><span class="line">  style来进行绑定</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>条件渲染</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    v-if的隐藏会移除 --&gt;</span><br><span class="line">&lt;p v-if=&quot;ok&quot;&gt; 成功了！！！&lt;/p&gt;</span><br><span class="line">&lt;p v-else&gt; 失败了！！！&lt;/p&gt;</span><br><span class="line">&lt;!--    v-show的隐藏只是应酬，标签其实还在内存里面 --&gt;</span><br><span class="line">&lt;p v-show=&quot;ok&quot;&gt;你好&lt;/p&gt;</span><br><span class="line">&lt;p v-show=&quot;!ok&quot;&gt;不好好&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;&#123;ok=!ok&#125;&quot;&gt;切换&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>v-for</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// vue只是监听本身，如果数组没有改变本身，只是里面的值改变，这个时候是不会刷新的</span><br><span class="line">//方法如果是个关键字，可能不生效，直接就报错了delete-&gt;是个关键字，所以不能行</span><br><span class="line">//</span><br><span class="line">&lt;!--    遍历数组--&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;(p, index) in persons&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">            &#123;&#123;index&#125;&#125;----&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125;</span><br><span class="line">            ---</span><br><span class="line">            &lt;button @click=&quot;deleteP(index)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">            ---</span><br><span class="line">            &lt;button @click=&quot;addP(index, &#123;name:&apos;xxx&apos;, age:28&#125;,)&quot;&gt;添加&lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;!--    遍历对象--&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;(value, key) in persons[1] &quot; :key=&quot;key&quot;&gt;</span><br><span class="line">            &#123;&#123;value&#125;&#125; -- &#123;&#123;key&#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>列表的收缩过滤和排序</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">filterPerson() &#123;</span><br><span class="line">    <span class="comment">//取出相关的数据</span></span><br><span class="line">    <span class="keyword">const</span> &#123;persons, searchName, orderType&#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fPersons;</span><br><span class="line">    fPersons = persons.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.name.indexOf(searchName) !== <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (orderType != <span class="number">0</span>) &#123; <span class="comment">//原本的顺序不进行排序处理</span></span><br><span class="line">        fPersons.sort(<span class="function"><span class="keyword">function</span> (<span class="params">p1, p2</span>) </span>&#123; <span class="comment">//如果返回-1 p1在前 返回正数 p2在前</span></span><br><span class="line">            <span class="keyword">if</span> (orderType == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> p2.age - p1.age;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p1.age - p2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对person进行过滤</span></span><br><span class="line">    <span class="keyword">return</span> fPersons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>绑定监听</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//默认的情况下test1方法相当于  test1($event) 默认传递了event</span><br><span class="line">//如果需要自己传值的话test1(&apos;你好&apos;, $event) 最好自己传一个$event,不然就没有默认传递$event对象了</span><br><span class="line">&lt;button @click=&quot;test1&quot;&gt;test1&lt;/button&gt; </span><br><span class="line">&lt;button @click=&quot;test2(&apos;你好&apos;, $event)&quot;&gt;test2&lt;/button&gt;</span><br><span class="line"> </span><br><span class="line">data: &#123;</span><br><span class="line">            test1() &#123;</span><br><span class="line">                alert(&quot;assdfa&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            test2(msg, event) &#123;</span><br><span class="line">                alert(msg+&quot;---&quot; + event.target.innerHTML)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>js event 停止事件冒泡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@click.stop=&quot;test6(&apos;inner&apos;)&quot;</span><br><span class="line"></span><br><span class="line">&lt;div @click=&quot;test4(&apos;outter&apos;)&quot; style=&quot;background: blue; width:200px; height: 200px&quot;&gt;</span><br><span class="line">        &lt;div @click.stop=&quot;test6(&apos;inner&apos;)&quot; style=&quot;background: red; width:100px; height: 100px&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>阻止事件的行为</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;test6(&apos;prevent&apos;)&quot;&gt;百度&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;按键修饰符&lt;/h2&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; @keyup.enter=&quot;test7&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>表单数据的自动收集</strong></p><p>生命周期函数（钩子函数）：</p><p>初始化显示</p><p>更新</p><p>死亡</p><p>mounted 挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//匿名函数，函数作为参数的时候</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    this.isShow = !this.isShow</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure><p>el去进行配置，也可以动态的配置 el</p></blockquote></li></ol><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>   在内存中挂载好后，然后再进行页面更新</p><p>   created  beforeMount mounted </p><p>   beforeUpdated updated</p><p>   beforeDestroy</p><p>   destroy   destroy后页面还在，只是vue不管事情了，比如清除定时器</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> mounted() ajax请求，启动定时器，等异步任务</span><br><span class="line">*beforeDestroy : 做收尾工作，清除定时器</span><br></pre></td></tr></table></figure><p>   <a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">https://www.bootcdn.cn/</a></p><p>   <a href="https://momentjs.com/" target="_blank" rel="noopener">https://momentjs.com/</a></p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;p&gt;完整版: &#123;&#123;date | dateFormat(&apos;YYYY年MM月DD日 HH:mm:ss&apos;)&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//定义过滤器  函数对象</span><br><span class="line">Vue.filter(&apos;dateFormat&apos;, function (value, formate) &#123;</span><br><span class="line"></span><br><span class="line">        // return moment(value).format(&quot;YYYY年MM月DD日 HH:mm:ss&quot;)</span><br><span class="line">        return moment(value).format(formate || &quot;HH:mm:ss&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">或者用在参数上这样使用</span><br><span class="line">    Vue.filter(&apos;dateFormat&apos;, function (value, formate=&quot;HH:mm:ss&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            // return moment(value).format(&quot;YYYY年MM月DD日 HH:mm:ss&quot;)</span><br><span class="line">            return moment(value).format(formate)</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="常用的内置指令"><a href="#常用的内置指令" class="headerlink" title="常用的内置指令"></a>常用的内置指令</h4><h4 id="v-cloak-指令的好处"><a href="#v-cloak-指令的好处" class="headerlink" title="v-cloak 指令的好处"></a>v-cloak 指令的好处</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &lt;p v-cloak&gt;&#123;&#123;date&#125;&#125;&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line"> 这样一开始就不会显示&#123;&#123;date&#125;&#125;了</span><br></pre></td></tr></table></figure><h4 id="vue开发插件"><a href="#vue开发插件" class="headerlink" title="vue开发插件"></a>vue开发插件</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入插件--&gt;</span><br><span class="line">&lt;script src=&quot;./vue-myplugin.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    //声明使用插件</span><br><span class="line">    Vue.use(MyPlugin) //插件安装上</span><br><span class="line"></span><br><span class="line">    const vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#example&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            msg: &apos;NBA I Love this Game&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="Vue-cli安装"><a href="#Vue-cli安装" class="headerlink" title="Vue cli安装"></a>Vue cli安装</h4><p>   项目名不能用大写</p><p>   vue init webpack vue_demo</p><p>   Dev.env.js 开发环境</p><p>   prod.env.js 生产环境</p><p>   什么是组件：component：局部的功能界面，相关的资源是它的组成部分，</p><p>   html，css，js 页面三要素</p><p>   Jsx =&gt; js + xml </p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>   npm run build</p><p>   Npm intall -g serve</p><p>   serve dist</p><p>   然后把dist改成和 webpack_prod #ouput  加入这个 publicPath :”/demo”</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*.js</span><br><span class="line">*.vue</span><br></pre></td></tr></table></figure><p>   都是组件化编码，组件开发</p><h4 id="静态组件"><a href="#静态组件" class="headerlink" title="静态组件"></a>静态组件</h4><p>   1.拆分组件 2.静态组件（没有交互）3.动态组件 (初始化状态，可以操作)</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    引入CSS样式   --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./static/css/bootstrap.css&quot;&gt;</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; 标签里面要先写个div</span><br></pre></td></tr></table></figure><h4 id="组件间通信-props-定义好后，都可以this访问"><a href="#组件间通信-props-定义好后，都可以this访问" class="headerlink" title="组件间通信 props 定义好后，都可以this访问"></a>组件间通信 props 定义好后，都可以this访问</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;:comment=&quot;comment&quot;  在组件标签里面写这个</span><br><span class="line">&gt;props:[&apos;comment&apos;], //这个只进行了属性名的指定</span><br><span class="line">&gt;// props: &#123;  这个是第二种实现</span><br><span class="line">&gt;//   comment :Object</span><br><span class="line">&gt;// &#125;,</span><br></pre></td></tr></table></figure></blockquote>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//数据在哪个组件，更新数据的行为（方法）就应该在哪个组件</span><br><span class="line">//this.comments.unshift(comment) 放到最前面</span><br></pre></td></tr></table></figure><p>   type:Founction</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var comment = &#123;</span><br><span class="line">  name: this.name,</span><br><span class="line">  content: this.content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   js的等于   是  === 三个等于好  !== 是也是两个</p><pre><code>npm info pubsub-js</code></pre><p>   PubSub</p><h4 id="组件间通信-slot"><a href="#组件间通信-slot" class="headerlink" title="组件间通信 slot"></a>组件间通信 slot</h4><p>   slot可以传标签，传什么标签就显示什么标签</p><p>   一开始通过站位，先把位置占好，然后传递标签进去，不传就没有，传就显示传的</p><h4 id="存储-localStorage"><a href="#存储-localStorage" class="headerlink" title="存储 localStorage"></a>存储 localStorage</h4><p>   window.localStorage.getItem() 得到的是文本，是个字符串</p><p>   Json.parse(window.localStorage.getItem() || ‘[]’)</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">arrays: &#123;</span><br><span class="line">deep:true, //深度监视</span><br><span class="line">handler: function(value) &#123;</span><br><span class="line">//json数据存储在LocalStorage</span><br><span class="line">window.localStorage.setItem(&apos;todos_key&apos;, JSON.stringify(value))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义绑定监听"><a href="#自定义绑定监听" class="headerlink" title="自定义绑定监听"></a>自定义绑定监听</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addTodo</span><br><span class="line"></span><br><span class="line">@addTodo=&apos;addTodo&apos;</span><br><span class="line"></span><br><span class="line">//触发事件</span><br><span class="line">this.$emit(&apos;addTodo&apos;, data)</span><br></pre></td></tr></table></figure><h4 id="获取组件对象"><a href="#获取组件对象" class="headerlink" title="获取组件对象"></a>获取组件对象</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TodoHeader ref=&quot;header&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.$refs.header</span><br></pre></td></tr></table></figure><p>   PubSub </p><p>   PubSub.subscribe(‘search’, (msg, searchName) =&gt; {</p><p>   ​    const url = <code>https://api.github.com/search/users?q=${searchName}</code>;</p><p>   })</p><h4 id="数组的-map-方法"><a href="#数组的-map-方法" class="headerlink" title="数组的 map 方法"></a>数组的 map 方法</h4>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;</span><br><span class="line">url: item.html_url</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h4 id="UI库学习"><a href="#UI库学习" class="headerlink" title="UI库学习"></a>UI库学习</h4><p>   饿了么：</p><p>   mint UI</p><p>   Elment  </p><p>   这两个都是饿了么开源的库</p><p>   npm install –save mint-ui</p><p>   Import {Button} from ‘mint-ui’</p><p>   Vue.componet(Button.name, Button)</p><h4 id="路由-vue-05"><a href="#路由-vue-05" class="headerlink" title="路由(vue_05)"></a>路由(vue_05)</h4><p>   路由就是一种映射关系</p><p>   处理请求的回调函数</p><p>   前台路由，组件</p><p>   路径和组件名</p><p>   路由组件</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/xx&quot;&gt;</span><br><span class="line">当前路由组件</span><br><span class="line">&lt;router-view&gt;</span><br></pre></td></tr></table></figure><p>   路由组件和非路由组件</p><p>   views/pages 包名</p><p>   优化路由配置</p><h5 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h5><p>   path最左侧的 / 是 根路径</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  component: Home,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/message'</span>,</span><br><span class="line">      component: Message</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/news'</span>,</span><br><span class="line">      component: News</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   正常情况下，路由切换后，被切换的路由会死亡，下次进来的时候，会重新创建</p><p>   如果要保存起来</p><p>   <strong>说是缓存路由组件实际上 缓存的是 组件的对象</strong></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>   实时性比较高，就不能使用缓存来进行</p><p>   :id 进行占位</p><p>   query 是？后面的参数</p><p>   params，就是路径上的 变参数</p><p>   <strong>&#39; ‘ 空串和 undefined 没什么区别，都不会在界面显示</strong></p><p>   进行查找 方法返回东西，返回值</p><p>   this.$route.params.id * 1 如果是文本的情况下</p><p>   allMessageDetails.find(detail =&gt; detail.id === this.$route.params.id)</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; //监听路由路径发生改版，就是param 发送变化</span><br><span class="line">$route: function(value) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   问题：打包的过程</p><p>   界面适配</p><p>   :id 这种是变量，就是js变量，就会去获取js变量，进行传值了</p><p>   msg=”aaa” 直接写就是，把msg作为变量传递过去</p><h4 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h4><p>   window.location = url，可以进行跳转</p><p>   路由如何实现的， hash，通过改变hash值来进行的，浏览器可以监视这个路由变化，所以我们可以拿到这个变化，可以得到路径进行，匹配显示就可以了。</p><p>   getState setState</p><p>   push</p><p>   replace</p><h4 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h4><p>   <a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a></p><p>   函数中的this只有在执行的时候被确定。this是一直变化的</p><p>   节点：document  element  attr  text</p><h5 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h5><p>   通过对象代理对另一个对象中属性的操作</p><p>   //数据代理</p><p>   Object.definProperty()</p><p>   ![image-20190715175528462](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190715175528462.png)</p><h5 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h5><p>   模板，html嵌套js代码。(指令属性，表达式)</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//引入js的时候需要先引入，然后再使用</span><br><span class="line">&lt;script src=&quot;../js/compile.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>   js的可以通过 updater[‘aaa’] 可以去方法名 也可以去对象</p><p>   this.$vm = vm 就变成了内部的对象了</p><p>   Updater &amp;&amp; updaterFn()</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><h5 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h5>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//回调函数什么时候调用</span><br><span class="line">//回调函数做了些什么事情</span><br><span class="line">//回调函数的this是谁</span><br></pre></td></tr></table></figure><p>   Dep</p><p>   初始化的给data的属性进行数据劫持时创建</p><p>   个数？与data中的属性一一对应关系</p><p>   dep的结构？</p><p>   ​    id：标识</p><p>   ​    subs：[]  n个相关的watcher的容器</p><p>   Watcher</p><p>   ​    它的实例什么时候创建？</p><p>   ​            初始化的解析 大括号表达式/一般指令时创建</p><p>   ​    个数？ </p><p>   ​            与模板中的表达式(不包含事件指令[事件指令在methods里面调用了，不用进行数据绑定])    </p><p>   ​            </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.cb = cb; //用于更新界面的回调</span><br><span class="line">this.vm = vm; // vm</span><br><span class="line">this.expOrFn = expOrFn; //对应的表达式</span><br><span class="line">this.depIds = &#123;&#125;; //相关的n个dep的容器对象</span><br><span class="line">this.value = this.get(); //当前表达式对应的value (改的时候加判断)</span><br></pre></td></tr></table></figure><p>   Dep和watcher的关系  ( 1对多，多对多，多对一)</p><p>   什么关系？</p><p>   ​    多对多的关系</p><p>   ​    data属性—》 Dep —》 n个watcher    {{name}} / v-text=”name” 多写几次就是多个watcher了</p><p>   属性在模板中多次被使用</p><p>   ​    表达式—》 watcher —》 n个Dep()</p><p>   ​    一个表达式永远是对应一个watcher    a.b 的时候，就2个dep了</p><p>   多层表达式，就多个Dep()了</p><p>   多个表达式使用了此属性。</p><p>   n个Dep(多层表达式：a.b.c)</p><p>   如何建立的？</p><p>   dep和watcher创建的先后。 dep先 watcher在后面</p><p>   data中属性的get()中建立</p><p>   什么时候建立？</p><p>   ​    初始化的解析模块中的表达式创建watcher对象时</p><p>   取属性值的时候，get方法会被调用</p><p>   双向绑定，就是双向赋值，dep持有watcher ，watcher持有dep</p><p>   一个表达式对应一个watcher</p><p>   同一个属性对应同一个Dep</p><p>   初始化的时候建立了关系</p><p>   vm.name = ‘abc’ —&gt; data中的name属性变化  —》 name中的set()调用</p><p>   —》 dep.notify()   —&gt; wather. update()</p><p>   并不是观察的对象本身，观察的是对象中的属性。</p><p>   observer进行数据劫持</p><h5 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h5><p>   dom事件监听</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//计算的</span><br><span class="line">computed: &#123;</span><br><span class="line">  eventOrAdd () &#123;</span><br><span class="line">    if (this.count % 2 === 0) &#123;</span><br><span class="line">      return &apos;偶数&apos;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &apos;奇数&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="vuex的库"><a href="#vuex的库" class="headerlink" title="vuex的库"></a>vuex的库</h4><p>   vuex是vue的一个插件</p><p>   vue应用中多个组件的共享状态进行集中式管理(读/写)</p><p>   state -&gt;data    驱动应用的数据源</p><p>   view -&gt; 界面  声明的方式将state映射到视图</p><p>   ​    初始化显示</p><p>   ​    更新显示</p><p>   actions是行为，就是更新状态的函数</p><p>   ​     包含n个更新数据状态的方法</p><p>   单向数据流</p><p>   ![image-20190716163430568](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190716163430568.png)</p><p>   多组件共享状态问题</p><ol><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一个状态</li><li>原来的解决<ol><li>将数据操作行为定义在父组件</li><li>将数据以及操作数据传递到各个组件</li></ol></li><li>vuex就是这样产生的</li></ol><h4 id="Vue相关介绍"><a href="#Vue相关介绍" class="headerlink" title="Vue相关介绍"></a>Vue相关介绍</h4><p>   组件调action</p><p>   Actions</p><p>   Mutations</p><p>   Const state = {}</p><p>   <strong>计算属性的一部分 get</strong></p><p>   vue.x</p><p>   depatch(actionName, data)  触发 action</p><h4 id="vuex应用"><a href="#vuex应用" class="headerlink" title="vuex应用"></a>vuex应用</h4><pre><code>npm install --save vuex</code></pre><p>   主键里面如何得到一个对象</p><p>   计算属性，对应的是getters</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this. 表示组件对象</span><br><span class="line">this.$store</span><br></pre></td></tr></table></figure><h4 id="vuex结构图-管理多组件的状态"><a href="#vuex结构图-管理多组件的状态" class="headerlink" title="vuex结构图(管理多组件的状态)"></a>vuex结构图(管理多组件的状态)</h4><p>   actions 里面可以进行 ajaix请求</p><p>   vuex是个全局</p><p>   每个组件都能看到 $store</p><p>   dispatch</p><p>   更新状态就是 dispatch</p><h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>   render: h =&gt; h(App)  </p><p>   · =&gt; · 同时是个函数，还是return </p><p>   render: function(createElement) {</p><p>   ​    return createElement(App)</p><p>   }</p><h4 id="项目1"><a href="#项目1" class="headerlink" title="项目1"></a>项目1</h4><ol><li><p>监听回车 @keyup.enter=”addTodo”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">@keyup=<span class="string">"toClick"</span></span><br><span class="line"></span><br><span class="line">toClick (event) &#123; <span class="comment">//keycode =13的时候是回车</span></span><br><span class="line">        <span class="built_in">console</span>.log(event.keyCode)</span><br><span class="line">        alert(event.keyCode)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"> @keyup.enter=<span class="string">"addTodo"</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>props: [‘todos’] 是跟data()同级的</p></li><li><p>//取出相关的数据<br>  const {persons, searchName, orderType} = this;</p></li><li><p>v-model 去绑定checkbox就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span> v-model=<span class="string">"todo.complete"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>放入到 computed 里面的方法，每次都会被调用， methods是事件处理的</p></li><li><p>不能在子的 vue组件中 进行 父类的 对象改变  </p><p>​    就是 props 传过来的对象</p><p>![image-20190717113739958](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190717113739958.png)</p></li><li><p>mapState</p></li><li><p>vuex 注意事项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ...mapState([&apos;todos&apos;])  //是个括号包起来的</span><br><span class="line"></span><br><span class="line">state : &#123;</span><br><span class="line">todos: []</span><br><span class="line">&#125;</span><br><span class="line">dispatch -&gt;  </span><br><span class="line">actions : &#123;</span><br><span class="line">deleteItem(&#123;commit, state&#125;, data) &#123;</span><br><span class="line">commit(&apos;mutations里面的方法名&apos;, &#123;data&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line">mutations : &#123;</span><br><span class="line">mutations里面的方法名(state, &#123;data&#125;) &#123;</span><br><span class="line">//操作state，然后进行数据操作，最后更新到了界面上</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vuex<strong>只要更新状态就要进行 dispatch</strong></p></li><li><p>状态非常多的时候用modules来进行 状态控制 项目量非常大的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([&apos;deleteSelectItem&apos;])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>![image-20190719102456735](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190719102456735.png)</p></li></ol><ol start="11"><li><p>逆向思维</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">let minArr = []</span><br><span class="line">categorys.forEach(c =&gt; &#123;</span><br><span class="line">if(minArr.lenth === 8) &#123;</span><br><span class="line">minArr = []</span><br><span class="line">&#125;</span><br><span class="line">if(minArr.length === 0) &#123;</span><br><span class="line">arr.push(minArr)</span><br><span class="line">&#125;</span><br><span class="line">minArr.push(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; //watch里面可以直接写对应的方法</span><br><span class="line">categroys(value) &#123;</span><br><span class="line">new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">loop: true,</span><br><span class="line">pagination: &#123;</span><br><span class="line">el:&apos;.swiper-pagination&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//怎么才能已经把数据加载完了，然后进行相应的设置</span><br><span class="line">  //界面更新后立马创建Swiper对象</span><br><span class="line">      this.$nextTick(()=&gt; &#123;</span><br><span class="line">        //一旦界面更新。理解调用</span><br><span class="line">        //下一次dom完成后调用</span><br><span class="line">        //这条语句要放在数据更新之后调用</span><br><span class="line">        </span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    //项目遇到什么问题</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>item in 6, 提高用户体验</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">score: Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   {} 对象属性</p><p>   计算属性，最难的时候，不知道什么时候使用计算属性</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">:class=&quot;&apos;star-&apos;+size&quot;</span><br><span class="line"></span><br><span class="line">5个span</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;start-item&quot; v-for=&quot;(sc, index) in startClasses&quot; :class=&quot;sc&quot;/&gt;</span><br><span class="line"></span><br><span class="line">类名常量</span><br><span class="line">const CLASS_ON = &quot;on&quot;</span><br><span class="line"></span><br><span class="line">小数部分大于等于0.5出现half</span><br><span class="line"></span><br><span class="line">const scoreInteger = Math.floor(score)</span><br><span class="line">if(score*10 - scoreInteger*10 &gt;=5) &#123; 小数点不精确，所以 *10</span><br><span class="line">scs.push(CLASS_HALF)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(scs.length&lt;5) &#123;</span><br><span class="line">scs.push(CLASS_SAFT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>js对象 {} 在html中都直接这样就好了</p></blockquote><p>观察者设计模式</p><p>![image-20190716215758766](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190716215758766.png)</p><p>![image-20190716222831469](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190716222831469.png)</p><h4 id="定一个小项目"><a href="#定一个小项目" class="headerlink" title="定一个小项目"></a>定一个小项目</h4><p>读书（类似fm吗），小视</p><p>前端：android、小程序、ios/flutter</p><p>后端：java后台进行实现 </p><pre><code>&gt; 资源储备：&gt;&gt;         1. 如何建立表结构，如何设计 (X)&gt;           2. 后台使用SpringBoot(√)&gt;&gt; </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;webview的优化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d2605f8f265da1bc23fa07c?utm_source=gold_browser_extension&quot; targe
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019-07-11-撑起职场bug</title>
    <link href="http://zhousaito.top/2019/11/11/2019-07-11-%E6%92%91%E8%B5%B7%E8%81%8C%E5%9C%BAbug/"/>
    <id>http://zhousaito.top/2019/11/11/2019-07-11-%E6%92%91%E8%B5%B7%E8%81%8C%E5%9C%BAbug/</id>
    <published>2019-11-11T05:40:29.459Z</published>
    <updated>2019-11-11T05:40:29.459Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h3><h1 id="服务自己启动"><a href="#服务自己启动" class="headerlink" title="服务自己启动"></a>服务自己启动</h1><p>通过修改返回值 not_stick</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>写过回调，那么需要使用</p><p>kotlin协程，协程上下文，拦截器，挂起函数</p><p>Job 调度器 作用域</p><p>Job</p><p>start</p><p>join</p><p>cancel</p><p>Deferred 是Job的子线程，Job类似于thread的地位</p><p>Deferred有返回结果，Job的话没有</p><p>deffered.await()</p><p>MainScope</p><p>进行了线程切换，然后优雅的使用</p><p>上下文，启动模式，</p><p>上下文接收调度器</p><p>2.6.0 版本的retrofit就携带了</p><p>可以直接使用suspend的方法</p><p>回调转换为协程</p><p>如何捕获协程的异常，异常处理在cache里面处理就可以了</p><p>Job类似于Thread</p><p>如何通过launch启动协程</p><p>初识调度器以及主线程调度器</p><p>3.协程的启动模式(Lazy, Atomic, )</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> job = GlobalScope.launch (start = CoroutineStart.LAZY)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure><p>deffer 有await</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;git的使用&quot;&gt;&lt;a href=&quot;#git的使用&quot; class=&quot;headerlink&quot; title=&quot;git的使用&quot;&gt;&lt;/a&gt;git的使用&lt;/h3&gt;&lt;h1 id=&quot;服务自己启动&quot;&gt;&lt;a href=&quot;#服务自己启动&quot; class=&quot;hea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019-07-24-app开发步骤</title>
    <link href="http://zhousaito.top/2019/11/11/2019-07-24-app%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/"/>
    <id>http://zhousaito.top/2019/11/11/2019-07-24-app%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</id>
    <published>2019-11-11T05:40:29.459Z</published>
    <updated>2019-11-11T05:40:29.459Z</updated>
    
    <content type="html"><![CDATA[<ol><li>先配置好统一版本控制</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project.ext.set(<span class="string">"appcompat"</span>, <span class="string">"1.0.2"</span>)</span><br><span class="line">project.ext.set(<span class="string">"corektx"</span>, <span class="string">"1.0.2"</span>)</span><br><span class="line">project.ext.set(<span class="string">"constraintlayout"</span>, <span class="string">"1.1.3"</span>)</span><br></pre></td></tr></table></figure><p>对应下面</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.appcompat:appcompat:$project.appcompat"</span></span><br><span class="line">implementation <span class="string">"androidx.core:core-ktx:$project.corektx"</span></span><br><span class="line">implementation <span class="string">"androidx.constraintlayout:constraintlayout:$project.constraintlayout"</span></span><br></pre></td></tr></table></figure><p>致力封装一个简洁、实用、易移植的网络框架模块.</p><p>kotlin的静态代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> INSTANCE: Context <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态代码块</span></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            setDefaultRefreshHeaderCreator &#123; context, layout -&gt;</span><br><span class="line">                layout.setPrimaryColorsId(R.color.colorPrimary, android.R.color.white)</span><br><span class="line">                ClassicsHeader(context)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setDefaultRefreshFooterCreator &#123; context, layout -&gt;</span><br><span class="line">                <span class="comment">//指定为经典Footer，默认是 BallPulseFooter</span></span><br><span class="line">                ClassicsFooter(context).setDrawableSize(<span class="number">20f</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;先配置好统一版本控制&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>反编译</title>
    <link href="http://zhousaito.top/2019/11/11/2019-06-10-%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://zhousaito.top/2019/11/11/2019-06-10-%E5%8F%8D%E7%BC%96%E8%AF%91/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-14T00:14:08.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="0x01-目的"><a href="#0x01-目的" class="headerlink" title="0x01 目的"></a>0x01 目的</h3></li></ul><blockquote><p>主要最近公司需要一个类似于运动类的app的地图路线一样的记录，所以需要查看别人怎么实现的，所以就只好反编译keep这个app来进行看看，有没有什么可以得到的</p></blockquote><h3 id="0x02-工作进行"><a href="#0x02-工作进行" class="headerlink" title="0x02 工作进行"></a>0x02 工作进行</h3><p>通过去百度下载apk包，这个包才好没有进行加固保护，不然就要使用hook dex 的技术来进行提取了，这个我以前通过手机安装 VirtualXposed来进行hook dex。</p><p>通过topActivity来进行查看需要的界面，然后去反编译后找到</p><p><img src="../img/fanbianyi/pic1.jpg" alt=""></p><p>1.文件中的 id 2131494206 反编译出来是10进制，要而在，反编译出来的public.xml（res/values/public.xml）中对应的是16进制的，即：0x7F0C053E，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;h3 id=&quot;0x01-目的&quot;&gt;&lt;a href=&quot;#0x01-目的&quot; class=&quot;headerlink&quot; title=&quot;0x01 目的&quot;&gt;&lt;/a&gt;0x01 目的&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="反编译" scheme="http://zhousaito.top/categories/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
    
      <category term="android java 反编译" scheme="http://zhousaito.top/tags/android-java-%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>求导</title>
    <link href="http://zhousaito.top/2019/11/11/2019-06-11-%E8%87%AA%E5%AE%9A%E4%B9%89view2/"/>
    <id>http://zhousaito.top/2019/11/11/2019-06-11-%E8%87%AA%E5%AE%9A%E4%B9%89view2/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-14T00:14:18.135Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>1.自定义view，必经之路</p><p>为什么要自定义view；</p><p>  andorid系统内置的view无法实现我们的需求</p><p>  处于性能考虑</p><p>自定义view某种情况下也要实现onLayout</p><p>​    自绘和组合： 不知道怎么下手</p><p>数学功底</p><p>TextView是最难的view，内置的<br>StaticLayout</p><p>树形结构，window是虚拟的概念，是为了管理view来虚拟出来的</p><p>android的角度是顺时针的，</p><p>motionEvent里面有getX getRawX</p><p>getTop</p><p>ViewRoot，是个管理view的，</p><p>WindowManagerGlobal  -&gt; 里面创建ViewRootImpl （setView）</p><p>ViewRoot 中</p><p>requestLayout </p><p>performTraversals   -&gt; 计算host.measure   host.layout  host.draw()</p><p>addDisplay()</p><p>如何绘制wrap_content，绘制一个好的view树上</p><p>为了自己适应屏幕，measure，就是把各种尺寸得到一个具体像素，来绘制到屏幕上面来，如果绘制一个自定义树。</p><p>UNSPECIFIED: 这个多次measure来确定子布局的位置</p><p>EXACTLY</p><p>MeasureSpecs：避免过多的内存分配 ；MeasureSpec 是View的一个内部类<br>viewGroup#getChildMeasureSpec；</p><p>Measure这个过程<strong>会多次测量的</strong></p><p>DecorView是根据屏幕大小来决定的</p><p>LayoutParams -》 是在LayoutInflater里面用到；自定义view generateLayoutParams</p><p><strong>MarginLayoutParams 支持margin参数</strong></p><p><strong>自定义LayoutParams</strong></p><p>getRootMeaurse -&gt; performMeasure   -&gt;  mView.measure()   -&gt; onMeasure()</p><p>除了UNSPACE都是用父类的那个测量宽度了</p><p>getMeaureWidth 和 getWidth 的区别：通常情况下是相同的</p><p>//frameLayout的规则代码</p><p>Math.max（0， specSize- padding） 可以绘制的剩余空间</p><p>measureChildWidthMargins</p><p>contentView 在一个线性布局里面，因为还有titlebar在上面</p><p>线性模具 resolveSizeAndState</p><p><strong>自定义attrs也可以通过@bindingAdapter的方式</strong></p><p><strong>getWidth()和getMesureWidth()讲了嘛</strong></p><p><strong>SurfaceFling可以进行优化性能</strong></p><p><strong>启航 自定义View系列也不错</strong></p><p>DecorView跟刘海屏有什么关系吗</p><p>从外往内递归，然后从内往外返回宽高</p><p>父如果自适应，那父的大小就是由子决定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">SystemServer # startOtherServices </span><br><span class="line"></span><br><span class="line">wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">        mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">        !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager()); <span class="comment">//这里直接new了一个phoneWindowManager</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//...中间是启动activity的过程，直接跳过了</span></span><br><span class="line"></span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">                    </span><br><span class="line">activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">activity#attatch &#123;</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    <span class="comment">//把windowmanager设置进去了</span></span><br><span class="line">     mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">&#125;                      </span><br><span class="line"></span><br><span class="line"><span class="comment">//这个winodow实际是PhoneWindow对象</span></span><br><span class="line">Window#setWindowManager &#123;</span><br><span class="line"><span class="comment">//创建了WindowManagerImpl，并且传进了 PhoneWindow对象，这里和service不一样的地方，所以可以显示对话框</span></span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后跑到 ActivityThread#handleResumeActivity 进行了addView操作，因为onCreate的时候界面还没有显示出来</span><br><span class="line">ActivityThread#handleResumeActivity &#123;</span><br><span class="line"><span class="comment">//进行了addView</span></span><br><span class="line"><span class="comment">//这个就是获取了activity#attach获取的创建好的PhoneWindow的mWindowManager = mWindow.getWindowManager();</span></span><br><span class="line"><span class="comment">//这里用了 依赖倒置原则，vm其实本质是个WindowManagerImpl</span></span><br><span class="line">ViewManager wm = a.getWindowManager();</span><br><span class="line">wm.addView(decor, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后接下来就  </span><br><span class="line">WindowManagerImpl # addView  -》 global # addView </span><br><span class="line">-》 ViewRootImpl # addView ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~<span class="comment">//这里断了，不知道怎么调到  WindowManagerImpl # addView  -》 global # addView~~~</span></span><br></pre></td></tr></table></figure><p>activityManagerService 怎么socket通知Zygote创建进程的，这个socket在哪里发送的</p><p>最近看源码发现：怎么保护线程不死</p><p>ZygoteInit-&gt;  runSelectLoop方法里面while(true) -&gt;  socket#accept来进行阻塞</p><p>要么就是用Looper.prepare()  -&gt;  Looper.loop() 这两个组合来进行维护这个线程不被释放</p><blockquote><p>SystemServer；ActivityThread</p></blockquote><pre><code>我觉得吧，如果要到自己线程进行干事情的话，肯定是使用Looper这个组合。</code></pre><p>​    ZygoteInit是通过sokect这种通信机制来进行等待AMS的请求 创建一个新的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zygoteInit# main &#123;</span><br><span class="line">forkSystemServer &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    runSelectLoop &#123;</span><br><span class="line">    //这个方法有等待，等待AMS的socket信号</span><br><span class="line">        acceptCommandPeer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AMS # startProcessLocked </span><br><span class="line">AMS # startProcessLocked(参数多)</span><br><span class="line">AMS # startProcess &#123;</span><br><span class="line">     startResult = Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith,</span><br><span class="line">                        new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>马尔科夫模型</p><p>和算法相关的。</p><p>时间复杂度，空间复杂度</p><p>知道多少种算法 【深度优先遍历，广度优先遍历】</p><p>，回溯法，分治算法，贪心算法，动态规划</p><p>一个问题怎么想到用动态规划</p><p>问题得到问题规模增大导致的变化</p><p>递推式–状态转移方程</p><p>结合侓，，每天学一点算法，挺有意思的</p><p>朴素算法。逆波兰表达式，栈的典型应用，（编译原理）可能会用到</p><p><strong>zero老师有没有管理经验</strong></p><p>1.ViewGroup开始测量自己的尺寸</p><p>​    1.尺寸值，200dp， match_parent，wrap_content</p><p>2.为每个子view计算测量的限制信息</p><p>3.把上一步确定的限制信息，传递给每个子view</p><p>​    树形递归过程，子view调取自己的measure过程</p><p>4.viewGroup 获取每个子view测量的尺寸，wrap_content<br>5.ViewGroup根据自身的情况计算自己的尺寸</p><p>6.保存自身的尺寸</p><p>类图+时序图 ； 多动手</p><p>getWidth 和 getLayoutParams().width的区别：<br>getLayoutParams()返回的是xml布局里面设置的。getLayoutParams().width返回的是xml里面android:width的值。是在onMeasure之前的值。<br>getwidth返回的是onMeasure之后的值。</p><p>18670301864</p><p>Wrap_content怎么确定控件的高度和宽度的，</p><p>绘制完了才有的getHeight的值</p><p>measure之后，wrap_content，match_parent都有值了</p><p>performLayout -&gt; decroVIew (View的layout).layout -&gt;  setFrame</p><p>view里面尽然有onLayout</p><p>onLayout：基本都是if else 加坐标计算</p><p>​        根据规则确定子view的位置</p><p>​        流程：</p><p>​        1.遍历子view，for</p><p>​        2.确定自己的规则</p><p>​        3.子View的测量尺寸  l ,t, b,r   left,top,bottom,right</p><p>​        4.left,top,bottom,right</p><p>​        5.child.layout</p><p>如何去阅读源码</p><p>1带着问题去看：找到什么东西</p><p>2点到为止：不要太在意细节</p><p>3看方法，方法名，返回值，参数，</p><p>问题： 控件的wrap_content，match_patent怎么确定的</p><p>控件在onLayout的时候为什么不用getHeight/getWidth而是用getMeasureHeight/getMeasureWidth，</p><p>layoutParams getwith， 和控件的getWidth的区别-》layoutParams getwith相当于xml布局里头的layout_width<br>    而getWidth是 mRight - mLeft,</p><p>1.时间复杂度，</p><p>n 表示数据规则</p><p>O(f(n)) 表示运行算法所需要</p><p>二分查找法 O(logn)</p><p>寻找数组 O(n)  </p><p>细节上的优化</p><p>归并排序 算法时间复杂度 O(nlogn)</p><p>O(n^2 + nlogn)  n的规模是一样的情况下就是 O(n^2)</p><p>快速排序算法，可能会退化成O(n^2) 平均情况是  nlogn</p><p>![image-20190615102246363](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615102246363.png)</p><p>多开一个辅助的数组 O(n)</p><p>多开一个辅助的二维数组：O(n)</p><p>多开一个常量O(1)</p><p>递归调用是有空间代价的</p><p>Assert(n &gt;= 0)</p><p>![image-20190615102827840](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615102827840.png)</p><p>递归的深度多少，就是多少空间复杂度</p><p>递归的深度是多 O(m) 级别的空间复杂度,m是深度</p><p>![image-20190615103301021](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615103301021.png)</p><p>![image-20190615103350803](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615103350803.png)</p><p>for循环里面先进行  int j+1; j&lt;n 这个判断后才会往下走，然后走完就j++</p><p>选择排序</p><p><strong>For(int j=0, j&lt;n ;j++) {</strong></p><p><strong>For(int j=0, j&lt;10000 ;j++) { //这个10000不算入时间复杂度上</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p>![image-20190615103800925](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615103800925.png)</p><p>![image-20190615104015935](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615104015935.png)</p><p>![image-20190615104235105](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615104235105.png)</p><p>n 除以 xx 等于1，然后就是logn</p><p>![image-20190615104546622](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615104546622.png)</p><p>O(sqrt(n)) 根号n  判断是否是个素数</p><p>具体问题，具体分析。</p><p>二分查找法基本就是递归查找法</p><p>binarySearch 二分查找</p><p>![image-20190615110649958](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615110649958.png)</p><p>pow (double x, int n)</p><p>![image-20190615110944775](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615110944775.png)</p><p>————]————————-</p><p>![image-20190615133355295](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615133355295.png)</p><p>二分查找法</p><p>没有没有bug的二分查找法在1962年</p><p><strong>l+(r-l)/2 -&gt; 通过减法来进行</strong></p><p><strong>考虑边界情况，是否为空，是否不在集合中</strong></p><p>如何写出正确的程序：</p><p>明确变量的含义 ， 循环不变量， 小数据量调试</p><p>forceClosed, —&gt; true 就是个闭合的 false就是开口的</p><p>getLength 获取具体的长度</p><p>getSegment 路径的片段</p><p>是否截取上次的</p><p>getPosTan   路径上的某点坐标，起始点的坐标</p><p>弗兰克尔在 追寻生命的意义 中说过</p><p>环境可能是无法改变的，唯一可以改变的是自己的态度</p><p>我们所处的环境就是一个巨大的鸟笼</p><p>我们无时无刻都生活在这个鸟笼中</p><p>有太多的人想要飞出这个笼子寻找自由</p><p>但不是每个人都能像安迪那样长出丰满的羽翼</p><p>所以固化的生活成了我们大部分人的常态</p><p>onTouchEvent来进行判断</p><p>mCacheViews —默认大小 2</p><p>每次移除第一个</p><p>pool 的大小是5个</p><p>onLayout 布局里面</p><p>mChangeScrap 与 mAttachedScrap</p><p>mCachedViews</p><p>mViewCacheExtension</p><p>RecyclerViewPool</p><p>什么时候回收，什么时候复用</p><p>滑动快的时候，多创建的ViewHolder是怎么回事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView#OnTouchEvent的move事件中</span><br><span class="line">RecyclerView#scrollByInternal</span><br><span class="line">LayoutManager#scrollHorizontallyBy</span><br><span class="line">  LayoutManager#scrollBy</span><br><span class="line">LayoutManager#fill</span><br><span class="line"></span><br><span class="line">LayoutManager#fill (回收和复用)</span><br><span class="line">  layoutManger#layoutChunk &#123;</span><br><span class="line">  layoutState.next(recycler);</span><br><span class="line">&#125;</span><br><span class="line">recycler（RecyclerView.recycler已经回到了RecyclerView中</span><br><span class="line">）.getViewForPosition(mCurrentPosition) &#123;</span><br><span class="line">        getScrapOrCachedViewForId中经过</span><br><span class="line">            mAttachedScrap</span><br><span class="line">  mViewCacheExtension</span><br><span class="line">          mRecyclerPool</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>onCreate </p><p>onBind</p><p>getViewForPosition</p><p>ItemTouchHelper 来进行RecyclerView的拖动View</p><p>ItemTouchHelper的使用</p><p>Callback callback = new C()</p><p>ItemTouchHelper touch = new ItemTouchHelper(callback)</p><p>touch.attachToRecyclerView(rv)</p><p>15怎么来的可以解析一下不</p><p>onChidrenDraw 就是 RecyclerView onDraw回调的</p><p>recyclerView.getChildCount是4个，而不是8个，指的是显示的个数是4个</p><p><strong>只要子view把事件消耗了，中间的view，就没有UP事件了，可能有move事件</strong></p><p>平滑滚动：</p><p>自定义布局的流程：</p><p>​    1.自定义属性：声明，设置，解析获取自定义值</p><p>​    2.测量：在onMeasure中 MeasureSpac.AT_MOST/EXACTIY</p><p>​        自身的宽与高/child的宽高</p><p>   3.布局：onLayout</p><p>   4.绘制：onDraw方法  绘制分割线什么的</p><p>  5.处理LayoutParams</p><p>  6.触摸反馈：滑动事件</p><p><strong>onDispatchDraw？？？</strong></p><p>互联网思维啊(迭代思想)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要想滑动必须消耗事件</span></span><br><span class="line"><span class="comment">//onTouchEvent里面返回true，才有后续的move和up事件</span></span><br><span class="line"><span class="comment">//就是说不返回true的话，就没有move和up事件了</span></span><br></pre></td></tr></table></figure><p>实现滑动，然后再实现阻尼效果，然后实现滑动选择器。这些都跟滑动有关</p><p>厉害的人很早就开始厉害了</p><p>拥有强烈的成功欲望</p><p>拥有说干就干的行动力</p><p>都是深度学习的机器</p><p>都善于坚持</p><p>都愿意延迟满足</p><h3 id="袁阔成评书网"><a href="#袁阔成评书网" class="headerlink" title="[袁阔成评书网]"></a>[袁阔成评书网]</h3><p>Xfermode</p><p>UNSPECIFIED 部分测试</p><p>wrap_content往往会传个携带父类大小的size给子类</p><p>​                        然后往往是小于父类这个值得</p><p>相当于padding是什么时候有效：是在测量的时候有效吗</p><p>​    measureChild(child, Wspec, Hspec)</p><p>textView放大镜 zero老师最拿手textView</p><p>控件滑动起来：1.view的scrollBy scrollTo方法实现滑动</p><p>​                            2.通过动画来给view添加位移效果，实现滑动</p><p>​                            3.通过改变view的LayoutParams，让view重新布局，从而重新滑动</p><p>wps  visio</p><p>professional visio</p><p>相当于canvas坐标移动了50</p><p>移动的是画布</p><p>相当于原点变成了（50，50）</p><p>//移动的是画布</p><p>canvas.translate(mLeft-sx,mTop-sy)</p><p>6中方式实现移动~</p><p>最终的两种移动方式：layout参数；移动动画布</p><p>压力信号-》 InputWindowManager    最初的是InputManagerService？</p><p>然后传到窗口的activity</p><p>事件的分发流程</p><p>事件的监听流程</p><p>事件的记忆机制：如果已经返回true了，就不会给其他的view了</p><p>每一个viewGroup都是事件的分发节点，维护了一个TouchTarget的链表</p><p>记录哪个子View的消耗该时间的</p><p>截获机制：action_down事件一定可截获的，</p><p>非down时间，若子类</p><p>分裂机制：</p><p>设置gravity，事件的几种机制</p><p>如何重构</p><p>版本冲突解决：</p><p><a href="https://blog.csdn.net/qq_32452623/article/details/81323193" target="_blank" rel="noopener">https://blog.csdn.net/qq_32452623/article/details/81323193</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation (<span class="string">'com.android.support.test:runner:1.0.2'</span>)&#123;</span><br><span class="line">      exclude group: <span class="string">'com.android.support'</span></span><br><span class="line">  &#125;</span><br><span class="line">  androidTestImplementation (<span class="string">'com.android.support.test.espresso:espresso-core:3.0.2'</span>)&#123;</span><br><span class="line">      exclude group: <span class="string">'com.android.support'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本身来进行消耗：dx &lt; dy     dy&gt; min  排除误操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalChild</span><br></pre></td></tr></table></figure><p>曾经有伟人说过，30岁之前做加法，因为不知道自己能做什么，30岁之后要做减法，做有把握的事</p><p>滑动的是内容</p><p>长按会影响，滑动效果，会有滑动跳动</p><p>realHeight - 父布局高度</p><p>computeScroll</p><p>invalidate如果没 invalidate完，就不会再调用了</p><p>postInvalidate如果</p><p>这里和属性动画那一块内核倒是很像</p><p>plos</p><p>sourceTree</p><p>git区块链算法：</p><p>集中式，只有服务器有一份，服务器连接不上</p><p>​    就commit和回滚都不能做了</p><p>分布式，本地也有一份管理</p><p>​    分布式的话每一个人本地都是一份完整的代码版本，即使服务器版本比你低，也会进行分享覆盖的</p><p>​    文件的形式进行存储，快照就是当前文件的copy</p><p>Fetch是拉新分支  刷新本地分支的状态， 就可以看到本地的分支可以远程分支一样了</p><p>gitk&amp;</p><p>git后缀的那个文件里面会保存你的详细信息，以及版本的详细信息，存在暂存区和本地仓库中，版本那个比较貌似是tree，文件blob的形式</p><blockquote><p>git status</p><p>Git add —all  到了暂存区</p><p>Git commit -m </p><p>clone checkout add commit push</p><p>unmodify已经被管理了 不需要进行add操作</p><p>Untracked  （追踪）没有被管理起来的文件 —&gt; stage</p><p>文件的4中状态</p><p>你们的分支管理有按照git flow管理吗<br>develop<br>feature/<br>release/<br>bugfix/<br>master</p><p>更换远程仓库</p><p>git remote add <new-url></p><p>git的权威文档</p><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p><p>alicode这个比较好，免费的</p></blockquote><p>git remote add origin <a href="https://gitee.com/zhousaito/adadfa.git" target="_blank" rel="noopener">https://gitee.com/zhousaito/adadfa.git</a></p><p>git branch -vv  当前处于哪个分支</p><p>Fetch  是拉取远程仓库信息 到 本地仓库，pull 是拉取远程分支代码到当前分支</p><p>Git config core.ignorecase false  不要忽略大小写</p><p>git config core.ignorecase false</p><p><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>objects里面存了blob文件和tree，tree比较计算版本信息</p><p>git status 多执行这个命令</p><p>git diff  比较没有提交的修改的文件</p><p>git diff --staged</p><p>git diff --cached</p><p>git push —set-upstream origin master</p><p>git branch</p><p>gitk 命令 需要自己安装</p><p>git branch -D</p><p>HEAD 指针</p><p>Rebase 会有多次冲突的 ，分支上的历史就没了</p><p>merge的话，分支的还有</p><p>git checkout –conflict=diff3 conflicts/testfile</p><p>git checkout –ours conflicts/testfile</p><p>OverScroller</p><p>视图动画</p><pre><code>&gt;补间动画(旋转，平移，缩放，透明)&gt;&gt;帧动画&gt;&gt;​    AnimationDrawable对象来添加，这样可以通过代码来实现&gt;&gt;​    &gt;&gt;插值器:缓动函数&gt;&gt;​    startOffset&gt;&gt;&gt;&gt;触摸反馈动画&gt;&gt;转场动画  [ 共享元素的动画]&gt;&gt;视图状态动画&gt;&gt;矢量图动画&gt;&gt;约束布局&gt;&gt;揭露动画&gt;&gt;Spring动画&gt;lottie-android&gt;&gt;&gt;</code></pre><p>属性动画</p><p>draw：</p><p>![image-20190702201748578](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190702201748578.png)</p><p>设置绘制风格</p><p>抗锯齿</p><p>绘制路径效果  setPatchEffect 绘制虚线</p><p>setShader</p><p>setStyle 设置画笔的填充风格</p><p>setTextAlign 文字对齐方式</p><p>setTextScaleX 设置文字水平拉伸比例</p><p>setStokeCap  画笔形状</p><p>setStrokeJoin 画笔转弯处的连接风格</p><p>Canvas.</p><p>drawArc (也可以画圆吗)</p><p>drawCircle</p><p>drawOval 椭圆</p><p>drawRoundRect 圆角矩形</p><p>convas.drawPicxture (画图片) 一般webView</p><p>stroke会把圆占地面积变大</p><p>![image-20190702203410555](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190702203410555.png)</p><p>​    path.close()</p><p>​    android 顺时针为正，跟数学的坐标角度相反</p><p>​    useCenter 这个为true就可以画扇形，</p><p>​    如果useCenter为false，如果fill就会直接封过去</p><p>moveTo lineTo</p><p>shader 渐变器</p><p>线性渐变，弧形渐变</p><p>LinearGradient </p><p>skew扭曲 </p><p>Canvas.scale 画布是可以缩放的</p><p>Canvas.clipRect  获取裁剪</p><p>Xfermode玩不动</p><p>保存与回滚  (就跟栈一样，每次保存就保存在栈里面</p><p>最后，restore，然后就相当于弹栈)</p><p>裁剪和平移不一样</p><p>裁剪不会改变坐标的，平移会改变坐标的</p><p>canvas相当于一个图层</p><p>setShadowLine 设置阴影</p><p>文字测量</p><p>Staticlayout 来进行测试</p><p>mPaint.setStrokeCap(Paint.cap.round) //画出椭圆的效果</p><p>mPaint.setTestAlign()</p><p>方法一、</p><p>//来进行得到text的一个rect</p><p>mPaint.getTextBounds()</p><p>(ract.top + ract.bottom)/2</p><p>方法二、</p><p>Ascent  descent</p><p>mPaint.getFontMetics(founmetric)</p><p>(founmetric.ascent + fontMetrics.descent)/2 来计算</p><p>自定义view，大小要通过onMeasure来确定的<br>应为放在scrollView里面，会变白，是因为没有重写onMeasure方法</p><p>列个Android坑大全</p><p>文字有默认间距</p><p>多行文字绘制：StaticLayout </p><p>丘比特之线</p><p>对于大部分中文英文，distance用top和bottom计算，有偏差，字体被偏下了一点点，应该用ascent和descent计算<br>部分国家的特殊字符的上下高度会超过descent，ascent，用top和bottom计算</p><h2 id="一个基于-Python-的简单服务"><a href="#一个基于-Python-的简单服务" class="headerlink" title="一个基于 Python 的简单服务"></a>一个基于 Python 的简单服务</h2><p>一行代码搞定服务器</p><p>python -m SimpleHTTPServer <port></p><p>Python3 -m http.server <port></p><p>视频剪辑这一类， 自定义view，</p><p>breakText 做多行绘制</p><p><strong>裁剪画布</strong> 可以做出多种类型的图片出来<br>绘制bitmap</p><p>D:\android9\development\samples\ApiDemos\src\com\example\android\apis\graphics</p><p>官方demo<br>要个手写签名</p><p>canvas的底层原理matrix</p><p>canvas的操作原理</p><p>横着 乘以 竖着</p><p>matrix.set 会清空上次的操作</p><p>旋转，如果没设置就是(0，0)，可以进行设置</p><p>局部缩放  matrix.setScale()</p><p>扭曲 -》可以做翻页 扭曲做3d效果</p><p>preTranslate </p><p>postRotate   </p><p>rgba 还是 argb</p><p>安徽数学会学到高数和微积分</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.自定义view，必经之路&lt;/p&gt;
&lt;p&gt;为什么要自定义view；&lt;/p&gt;
&lt;p&gt;  andorid系统内置的view无法实现我们的需求&lt;/p&gt;
&lt;p&gt;  处于性能考虑&lt;/p&gt;
&lt;p&gt;自定义vie
      
    
    </summary>
    
    
      <category term="求导" scheme="http://zhousaito.top/categories/%E6%B1%82%E5%AF%BC/"/>
    
    
      <category term="java 数学" scheme="http://zhousaito.top/tags/java-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>exercise</title>
    <link href="http://zhousaito.top/2019/11/11/2019-06-26-exercise/"/>
    <id>http://zhousaito.top/2019/11/11/2019-06-26-exercise/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-14T00:14:30.754Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h3></li></ul><ol><li>生成keystore签名文件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;h3 id=&quot;0x01-准备&quot;&gt;&lt;a href=&quot;#0x01-准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 准备&quot;&gt;&lt;/a&gt;0x01 准备&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;生成keys
      
    
    </summary>
    
    
      <category term="项目" scheme="http://zhousaito.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="android" scheme="http://zhousaito.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>自定义view(二)</title>
    <link href="http://zhousaito.top/2019/11/11/2019-06-23-%E8%87%AA%E5%AE%9A%E4%B9%89View2/"/>
    <id>http://zhousaito.top/2019/11/11/2019-06-23-%E8%87%AA%E5%AE%9A%E4%B9%89View2/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-14T00:14:26.874Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3></li></ul><blockquote><p>最近公司要求要出一个暂开内容，然后还能收缩内容的控件</p><p>其实一开始我想用ExpendListView，但是后面寻思着用了自定义View，毕竟现在自己也在学这一块</p></blockquote><h3 id="0x02-效果"><a href="#0x02-效果" class="headerlink" title="0x02 效果"></a>0x02 效果</h3><p><img src="/img/view/view2.gif" alt=""></p><h3 id="0x03-代码"><a href="#0x03-代码" class="headerlink" title="0x03 代码"></a>0x03 代码</h3><h4 id="一、SubExpendLayout代码"><a href="#一、SubExpendLayout代码" class="headerlink" title="一、SubExpendLayout代码"></a>一、SubExpendLayout代码</h4><p> SubExpendLayout 这个是上面那个view，上面那个view实际上是叠加了一个textView，然后进行的，因为需要要求第一个textView收缩之后要点点，所以加上了singleLine =true</p><p><img src="/img/view/view3.png" alt=""></p><p>根据分析</p><p><img src="/img/view/view4.png" alt=""></p><p>对应的<code>expend()</code>和<code>close()</code>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tvContentClose.setVisibility(INVISIBLE); <span class="comment">//close的textview</span></span><br><span class="line">    ivExpend.setVisibility(INVISIBLE);<span class="comment">//close展开按钮图片</span></span><br><span class="line"></span><br><span class="line">    tvContentExpend.setVisibility(VISIBLE);<span class="comment">//展开的textview</span></span><br><span class="line">    ivClose.setVisibility(VISIBLE);<span class="comment">//关闭的按钮图片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tvContentClose.setVisibility(VISIBLE);</span><br><span class="line">    ivExpend.setVisibility(VISIBLE);</span><br><span class="line"></span><br><span class="line">    tvContentExpend.setVisibility(INVISIBLE);</span><br><span class="line">    ivClose.setVisibility(INVISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测量代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (widthMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST: &#123; <span class="comment">//宽度我这里实际默认了屏幕宽度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">                View view = getChildAt(i);</span><br><span class="line">                <span class="keyword">int</span> measuredWidth = view.getMeasuredWidth();</span><br><span class="line">                width = Math.max(widthSize, measuredWidth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            width = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (heightMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">                View view = getChildAt(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//隐藏的就不进行测量了</span></span><br><span class="line">                <span class="keyword">if</span> (view.getVisibility() != GONE) &#123;</span><br><span class="line">                    <span class="keyword">int</span> measuredHeight = view.getMeasuredHeight();</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">//第一个就照着第二个展开内容的摆放就好了,因为第一个内容和第二个的内容相同,但是是单行的,所以第二个的内容肯定比第一个打</span></span><br><span class="line">                        height += measuredHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            height = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.e(TAG, <span class="string">"onMeasure: "</span> + height);</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的onLayout的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tempHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">        View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (view.getVisibility() == GONE) &#123;</span><br><span class="line">            <span class="comment">//隐藏的就下一个，就不在布局</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> measuredHeight = view.getMeasuredHeight();</span><br><span class="line">        view.layout(<span class="number">0</span>, tempHeight, view.getMeasuredWidth(), measuredHeight + tempHeight);</span><br><span class="line">        <span class="comment">//第二个和第一个重叠，所以不进行高度添加</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tempHeight += measuredHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//记录这个singleLine的textView</span></span><br><span class="line">            closeHeight = measuredHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里应该执行动画的时候多次执行，所以只能得到第一次的值就是我们想要的</span></span><br><span class="line">    <span class="keyword">if</span> (expendHeight == <span class="number">0</span> || reLayout) &#123;</span><br><span class="line">        expendHeight = getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        midHeight = (closeHeight + expendHeight) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        reLayout = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后可以来一个触摸事件的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">if</span> (isExpend) &#123;</span><br><span class="line">                closeLayout(); <span class="comment">//执行关闭动画</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                expendLayout();<span class="comment">//执行展开动画</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expendLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofInt(closeHeight, expendHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> changeHeight = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">            layoutParams.height = changeHeight;</span><br><span class="line">            setLayoutParams(layoutParams);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changeHeight &gt;= midHeight) &#123;</span><br><span class="line">                expend();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.start();</span><br><span class="line"></span><br><span class="line">    isExpend = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofInt(expendHeight, closeHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> changeHeight = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">            layoutParams.height = changeHeight;</span><br><span class="line">            setLayoutParams(layoutParams);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changeHeight &lt;= midHeight) &#123;</span><br><span class="line">                close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.start();</span><br><span class="line"></span><br><span class="line">    isExpend = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的动画实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expendLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofInt(closeHeight, expendHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> changeHeight = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">            layoutParams.height = changeHeight;</span><br><span class="line">            setLayoutParams(layoutParams);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changeHeight &gt;= midHeight) &#123;</span><br><span class="line">                expend();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.start();</span><br><span class="line"></span><br><span class="line">    isExpend = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofInt(expendHeight, closeHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> changeHeight = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">            layoutParams.height = changeHeight;</span><br><span class="line">            setLayoutParams(layoutParams);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changeHeight &lt;= midHeight) &#123;</span><br><span class="line">                close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.start();</span><br><span class="line"></span><br><span class="line">    isExpend = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、RecordExpendLayout代码"><a href="#二、RecordExpendLayout代码" class="headerlink" title="二、RecordExpendLayout代码"></a>二、RecordExpendLayout代码</h4><p>分别设置了2个类，SubmissionExpendAdapter是个实现类</p><p><img src="/img/view/view5.png" alt=""></p><p>RecordExpendLayout的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RecordExpendLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置了个背景</span></span><br><span class="line">        setBackgroundColor(getResources().getColor(R.color.background));</span><br><span class="line"></span><br><span class="line"><span class="comment">//把点击关闭和开启状态的title提前加入了进来</span></span><br><span class="line">        View titleView = LayoutInflater.from(getContext()).inflate(R.layout.view_record_expend_title, <span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        cardItemViews.add(titleView);</span><br><span class="line">        addView(titleView);</span><br><span class="line"></span><br><span class="line">        ivCtrolStatus = (ImageView) findViewById(R.id.iv_ctrol_status);</span><br><span class="line"></span><br><span class="line">        setStatus(Status.EXPEND);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进行对应的测量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        measureChildren(widthMeasureSpec, heightMeasureSpec);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            View view = getChildAt(i);</span><br><span class="line">            measureChildWithMargins(view, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (widthMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST: &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">                    View view = getChildAt(i);</span><br><span class="line">                    <span class="keyword">int</span> measuredWidth = view.getMeasuredWidth();</span><br><span class="line">                    width = Math.max(widthSize, measuredWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                width = widthSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (heightMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST: &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">                    View view = getChildAt(i);</span><br><span class="line"></span><br><span class="line">                    MarginLayoutParams lp = (MarginLayoutParams) view.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//隐藏的就不进行测量了</span></span><br><span class="line">                    <span class="keyword">if</span> (view.getVisibility() != GONE) &#123;</span><br><span class="line">                        <span class="keyword">int</span> measuredHeight = view.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line">                        height += measuredHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                height = heightSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.e(TAG, <span class="string">"onMeasure: "</span> + height);</span><br><span class="line"><span class="comment">//        int currentHeight = ViewUtil.dp2px(getContext(), 20);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expendHeight == <span class="number">0</span> || reLayout) &#123;</span><br><span class="line">            expendHeight = getMeasuredHeight();</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进行onLayout</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tempHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">        View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (view.getVisibility() == GONE) &#123;</span><br><span class="line">            <span class="comment">//隐藏的就下一个，就不在布局</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> measuredHeight = view.getMeasuredHeight();</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) view.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        view.layout(lp.leftMargin, tempHeight + lp.topMargin, view.getMeasuredWidth() + lp.rightMargin, measuredHeight + tempHeight + lp.topMargin - lp.bottomMargin);</span><br><span class="line"></span><br><span class="line">        tempHeight += measuredHeight + lp.topMargin + lp.bottomMargin;</span><br><span class="line">        <span class="comment">//记录这个singleLine的textView</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            closeHeight = measuredHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里应该执行动画的时候多次执行，所以只能得到第一次的值就是我们想要的</span></span><br><span class="line">    <span class="keyword">if</span> (expendHeight == <span class="number">0</span> || reLayout) &#123;</span><br><span class="line">        expendHeight = getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        midHeight = (closeHeight + expendHeight) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        reLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Log.e(TAG, <span class="string">"onLayout: expendHeight: "</span> + expendHeight + <span class="string">"  "</span> + getMeasuredHeight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是ExpendAdapter 接口的设置了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpendAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已经在内部添加，因为是已知 item</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View view, RecordExpendLayout parent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecordExpendLayout和adapter相关的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ExpendAdapter mAdapter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ExpendAdapter adapter)</span> </span>&#123;</span><br><span class="line">    mAdapter = adapter;</span><br><span class="line"></span><br><span class="line">    notifyAllData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itemCount = mAdapter.getItemCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; itemCount; i++) &#123;</span><br><span class="line">        View view = LayoutInflater.from(getContext()).inflate(R.layout.view_record_expend_item, <span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        cardItemViews.add(view);</span><br><span class="line">        addView(view);</span><br><span class="line"></span><br><span class="line">        mAdapter.getView(i, view, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.e(TAG, <span class="string">"notifyAllData: "</span>);</span><br><span class="line">    <span class="comment">//重新加入值，就重新测量一次</span></span><br><span class="line">    reLayout = <span class="keyword">true</span>;</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是上周觉得比较有意思而又比较重要的代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;h3 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最近公司要求要出一个暂
      
    
    </summary>
    
    
      <category term="自定义View" scheme="http://zhousaito.top/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
    
      <category term="android view" scheme="http://zhousaito.top/tags/android-view/"/>
    
  </entry>
  
  <entry>
    <title>android动画(转)</title>
    <link href="http://zhousaito.top/2019/11/11/2019-07-09-%E8%87%AA%E5%AE%9A%E4%B9%89view3/"/>
    <id>http://zhousaito.top/2019/11/11/2019-07-09-%E8%87%AA%E5%AE%9A%E4%B9%89view3/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-14T00:14:43.502Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3></li></ul><p><img src="../img/view/drawpath.gif" alt=""></p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">       mContext = context;</span><br><span class="line">       mWidth = width;</span><br><span class="line">       mHeight = height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化画背景的paint</span></span><br><span class="line">       mBgPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">       mRect = <span class="keyword">new</span> Rect();</span><br><span class="line"></span><br><span class="line">       initCirclePaint(); <span class="comment">//初始化画旋转的外圆paint</span></span><br><span class="line">       initBallPaint(); <span class="comment">//初始化变成点的piant</span></span><br><span class="line">       initForkPaint(); <span class="comment">//初始化叉叉的paint</span></span><br><span class="line">       initLinePaint(); <span class="comment">//初始化画勾勾的paint</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="画外圆paint"><a href="#画外圆paint" class="headerlink" title="画外圆paint"></a>画外圆paint</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 画外围转的圆</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initCirclePaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mCirclePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">      mCirclePaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">      mCirclePaint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">      mCirclePaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">      mCirclePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] colors = &#123;Color.WHITE, Color.TRANSPARENT&#125;;</span><br><span class="line">      mPositions = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>];</span><br><span class="line">      mPositions[<span class="number">0</span>] = <span class="number">0.7f</span>;</span><br><span class="line">      mPositions[<span class="number">1</span>] = .<span class="number">9f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//渐变</span></span><br><span class="line">      SweepGradient sweepGradient = <span class="keyword">new</span> SweepGradient(<span class="number">200</span>, <span class="number">200</span>, colors, mPositions);</span><br><span class="line">      Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">      matrix.setRotate(<span class="number">130</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">      sweepGradient.setLocalMatrix(matrix);</span><br><span class="line">      mCirclePaint.setShader(sweepGradient);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> padding = <span class="number">20</span>;</span><br><span class="line">      mRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">      mRectF.set(<span class="number">0</span> + padding, <span class="number">0</span> + padding, mWidth - padding, mHeight - padding);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="画叉-paint"><a href="#画叉-paint" class="headerlink" title="画叉 paint"></a>画叉 paint</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画叉叉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initForkPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mPath = <span class="keyword">new</span> Path();</span><br><span class="line"></span><br><span class="line">    mForkPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    mForkPaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">    mForkPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">    mForkPaint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">    mForkPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    mForkPaint.setColor(Color.WHITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="画小球"><a href="#画小球" class="headerlink" title="画小球"></a>画小球</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画小球</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBallPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBallPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    mBallPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">    mBallPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">    mBallPaint.setColor(Color.WHITE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="画勾勾"><a href="#画勾勾" class="headerlink" title="画勾勾"></a>画勾勾</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画勾勾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinePaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> centerX = mWidth / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> centerY = mHeight / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mLinePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    mLinePaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">    mLinePaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    mLinePaint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">    mLinePaint.setColor(Color.WHITE);</span><br><span class="line">    mLinePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//勾勾的线</span></span><br><span class="line">    mGPath = <span class="keyword">new</span> Path();</span><br><span class="line">    <span class="keyword">float</span> leftPathHeight = mHeight * <span class="number">0.4f</span> / <span class="number">2f</span>;</span><br><span class="line">    mGPath.moveTo(centerX, centerY + leftPathHeight);</span><br><span class="line">    mGPath.lineTo((<span class="keyword">float</span>) (centerX - leftPathHeight / Math.tan(<span class="number">40</span> * Math.PI / <span class="number">180</span>)), centerY);</span><br><span class="line">    mPathMeasure = <span class="keyword">new</span> PathMeasure();</span><br><span class="line">    mPathMeasure.setPath(mGPath, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    mLineRightPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    mLineRightPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">    mLineRightPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    mLineRightPaint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">    mLineRightPaint.setColor(Color.WHITE);</span><br><span class="line">    mLineRightPaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line"></span><br><span class="line">    mGRightPath = <span class="keyword">new</span> Path();</span><br><span class="line">    <span class="keyword">float</span> rightPathHeight = mHeight * <span class="number">0.4f</span> / <span class="number">2f</span>;</span><br><span class="line">    mGRightPath.moveTo(centerX, centerY + rightPathHeight);</span><br><span class="line">    mGRightPath.lineTo((<span class="keyword">float</span>) (centerX + rightPathHeight / Math.tan(<span class="number">40</span> * Math.PI / <span class="number">180</span>)), centerY - rightPathHeight);</span><br><span class="line">    mPathRightMeasure = <span class="keyword">new</span> PathMeasure();</span><br><span class="line">    mPathRightMeasure.setPath(mGRightPath, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终onDraw"><a href="#最终onDraw" class="headerlink" title="最终onDraw"></a>最终onDraw</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(@NonNull Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//防止还有个 半径为10的小球还在，所以清理的画布</span></span><br><span class="line">        <span class="keyword">if</span> (mDashPathEffect != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas.drawColor(Color.WHITE, PorterDuff.Mode.CLEAR);</span><br><span class="line">            canvas.drawColor(Color.WHITE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> centerX = mWidth / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> centerY = mHeight / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        mBgPaint.setColor(Color.GREEN);</span><br><span class="line">        mBgPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        canvas.drawRoundRect(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, <span class="number">30</span>, <span class="number">30</span>, mBgPaint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//旋转外面的圆圈</span></span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.rotate(<span class="number">90</span> + mRotate, mWidth / <span class="number">2f</span>, mHeight / <span class="number">2f</span>);</span><br><span class="line">        <span class="comment">//画运动圆弧</span></span><br><span class="line">        canvas.drawArc(mRectF, -<span class="number">180</span>, <span class="number">240</span>, <span class="keyword">false</span>, mCirclePaint);</span><br><span class="line"></span><br><span class="line">        canvas.restore();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        prepareForkPath(centerX, centerY);</span><br><span class="line">        <span class="comment">//画叉</span></span><br><span class="line">        canvas.drawPath(mPath, mForkPaint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDashPathEffect != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//把小球变小</span></span><br><span class="line">            canvas.drawCircle(centerX, centerY - mMoveHeight, <span class="number">5</span>, mBallPaint);</span><br><span class="line">            canvas.drawPath(mGPath, mLinePaint);</span><br><span class="line">            canvas.drawPath(mGRightPath, mLineRightPaint);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//画移动后的小球</span></span><br><span class="line">            canvas.drawCircle(centerX, centerY - mMoveHeight, <span class="number">10</span>, mBallPaint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareForkPath</span><span class="params">(<span class="keyword">int</span> centerX, <span class="keyword">int</span> centerY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> cos45Value = Math.cos(<span class="number">45</span> * Math.PI / <span class="number">180</span>);</span><br><span class="line">        <span class="keyword">double</span> sin5Value = Math.sin(<span class="number">45</span> * Math.PI / <span class="number">180</span>);</span><br><span class="line">        <span class="keyword">float</span> len = mForkLenScale * centerX;</span><br><span class="line"></span><br><span class="line">        Log.e(TAG, <span class="string">"draw: "</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左上角</span></span><br><span class="line">        <span class="keyword">float</span> x1 = (<span class="keyword">float</span>) (centerX - len * cos45Value);</span><br><span class="line">        <span class="keyword">float</span> y1 = (<span class="keyword">float</span>) (centerY - len * sin5Value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右上角</span></span><br><span class="line">        <span class="keyword">float</span> x2 = (<span class="keyword">float</span>) (centerX + len * cos45Value);</span><br><span class="line">        <span class="keyword">float</span> y2 = (<span class="keyword">float</span>) (centerY - len * sin5Value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右下角</span></span><br><span class="line">        <span class="keyword">float</span> x3 = (<span class="keyword">float</span>) (centerX + len * cos45Value);</span><br><span class="line">        <span class="keyword">float</span> y3 = (<span class="keyword">float</span>) (centerY + len * sin5Value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左下角</span></span><br><span class="line">        <span class="keyword">float</span> x4 = (<span class="keyword">float</span>) (centerX - len * cos45Value);</span><br><span class="line">        <span class="keyword">float</span> y4 = (<span class="keyword">float</span>) (centerY + len * sin5Value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要进行reset，不然一直运行就会卡顿,并且一直是把叉在那里看不到变化</span></span><br><span class="line">        mPath.reset();</span><br><span class="line"></span><br><span class="line">        mPath.moveTo(x1, y1);</span><br><span class="line">        mPath.lineTo(x3, y3);</span><br><span class="line">        mPath.moveTo(x2, y2);</span><br><span class="line">        mPath.lineTo(x4, y4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="启动动画"><a href="#启动动画" class="headerlink" title="启动动画"></a>启动动画</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动动画</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimatorSet animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line"></span><br><span class="line">        ValueAnimator rotateAnimator = ValueAnimator.ofFloat(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        rotateAnimator.setDuration(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//有了这个加速器 中间就不会产生停顿了</span></span><br><span class="line">        rotateAnimator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">        rotateAnimator.setRepeatCount(<span class="number">2</span>);</span><br><span class="line">        rotateAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">        rotateAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> animatedValue = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">                mRotate = -<span class="number">360</span> * animatedValue;</span><br><span class="line"><span class="comment">//                if (mForkLenScale != 0) &#123;</span></span><br><span class="line"><span class="comment">//                    mForkLenScale = 1 - 0.6f * animatedValue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                invalidateSelf();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        rotateAnimator.start();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ValueAnimator forkAnimator = ValueAnimator.ofFloat(<span class="number">0.6f</span>, <span class="number">0</span>);</span><br><span class="line">        forkAnimator.setDuration(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//有了这个加速器 中间就不会产生停顿了</span></span><br><span class="line">        forkAnimator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line"><span class="comment">//        forkAnimator.setRepeatCount(ValueAnimator.INFINITE);</span></span><br><span class="line"><span class="comment">//        forkAnimator.setRepeatMode(ValueAnimator.RESTART);</span></span><br><span class="line">        forkAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> animatedValue = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">                mForkLenScale = animatedValue;</span><br><span class="line">                <span class="keyword">if</span> (mForkLenScale == <span class="number">0</span>) &#123;</span><br><span class="line">                    mForkPaint.setAlpha(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                invalidateSelf();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        forkAnimator.start();</span></span><br><span class="line"></span><br><span class="line">        ValueAnimator ballAnimator = ValueAnimator.ofFloat(<span class="number">0</span>, mHeight * <span class="number">0.6f</span> / <span class="number">2f</span>, -mHeight * <span class="number">0.6f</span> / <span class="number">2f</span>, -mHeight * <span class="number">0.4f</span> / <span class="number">2f</span>);</span><br><span class="line">        ballAnimator.setDuration(<span class="number">1500</span>);</span><br><span class="line">        ballAnimator.setStartDelay(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//有了这个加速器 中间就不会产生停顿了</span></span><br><span class="line">        ballAnimator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line"><span class="comment">//        forkAnimator.setRepeatCount(ValueAnimator.INFINITE);</span></span><br><span class="line"><span class="comment">//        forkAnimator.setRepeatMode(ValueAnimator.RESTART);</span></span><br><span class="line">        ballAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> animatedValue = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">                mMoveHeight = animatedValue;</span><br><span class="line">                invalidateSelf();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        ballAnimator.start();</span></span><br><span class="line"></span><br><span class="line">        ValueAnimator gAnimator = ValueAnimator.ofFloat(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        gAnimator.setDuration(<span class="number">500</span>);</span><br><span class="line">        gAnimator.setStartDelay(<span class="number">2500</span>);</span><br><span class="line">        <span class="comment">//有了这个加速器 中间就不会产生停顿了</span></span><br><span class="line">        gAnimator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">        gAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> animatedValue = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">                mDashPathEffect = <span class="keyword">new</span> DashPathEffect(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;mPathMeasure.getLength(), mPathMeasure.getLength()&#125;, mPathMeasure.getLength() * animatedValue);</span><br><span class="line">                mDashPathRightEffect = <span class="keyword">new</span> DashPathEffect(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;mPathRightMeasure.getLength(), mPathRightMeasure.getLength()&#125;, mPathRightMeasure.getLength() * animatedValue);</span><br><span class="line">                mLinePaint.setPathEffect(mDashPathEffect);</span><br><span class="line">                mLineRightPaint.setPathEffect(mDashPathRightEffect);</span><br><span class="line">                invalidateSelf();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        gAnimator.start();</span></span><br><span class="line"></span><br><span class="line">        animatorSet.playTogether(rotateAnimator, forkAnimator, ballAnimator, gAnimator);</span><br><span class="line"></span><br><span class="line">        animatorSet.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>适当的的地方可以用用Interpolator，有更加吸引人的地方。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><ol><li>path绘制的时候要进行reset，否则就会一直画，然后执行的动画去绘制的时候就会进行卡顿</li><li>可以用canvas的旋转来进行<strong>旋转动画绘制</strong></li><li>SweepGradient 或者 LinearGradient等 position是传递 0-1的值就好了</li><li>setInterpolator(new LinearInterpolator())  这样，repeatCount多次以后就不会停顿一下，再继续下一个动画</li><li>repeatCount是指重复的次数，所以2表示重复2次，一开始的<strong>那一次不包含在内</strong>，也就是说肉眼看到是有3次的动画</li><li>清空某个点什么的可以用 canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);来进行全部清除，<strong>只要保证后面不再执行绘制这个清除的内容就可以了</strong></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;h3 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;headerlink&quot; title=&quot;要求&quot;&gt;&lt;/a&gt;要求&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../img/view/drawpath.g
      
    
    </summary>
    
    
      <category term="项目" scheme="http://zhousaito.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="android" scheme="http://zhousaito.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>2019-07-09-javaweb</title>
    <link href="http://zhousaito.top/2019/11/11/2019-07-09-javaweb/"/>
    <id>http://zhousaito.top/2019/11/11/2019-07-09-javaweb/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-11T05:40:29.458Z</updated>
    
    <content type="html"><![CDATA[<p>直接可以进行http访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为http的正文进行返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"hello Spring boot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库用包装类型，是因为Integer可以进行判空处理</p><blockquote><p>#{aa} 获取参数值</p><p>keyColumn =”area_id”  </p><p>保留字 使用这种方法 `name`  </p></blockquote><p>问题：</p><p><a href="https://blog.csdn.net/yidragon88xx/article/details/53888719" target="_blank" rel="noopener">Mysql出现Table ‘performance_schema.session_status’ doesn’t exist</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接可以进行http访问&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019-07-11-小细节</title>
    <link href="http://zhousaito.top/2019/11/11/2019-07-11-%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>http://zhousaito.top/2019/11/11/2019-07-11-%E5%B0%8F%E7%BB%86%E8%8A%82/</id>
    <published>2019-11-11T05:40:29.458Z</published>
    <updated>2019-11-11T05:40:29.463Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="listView-在-NestedScrollView中解决滑动冲突"><a href="#listView-在-NestedScrollView中解决滑动冲突" class="headerlink" title="listView 在 NestedScrollView中解决滑动冲突"></a>listView 在 NestedScrollView中解决滑动冲突</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> <span class="keyword">implements</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NestedScrollingChildHelper mScrollingChildHelper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            setNestedScrollingEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mScrollingChildHelper.setNestedScrollingEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNestedScrollingEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.isNestedScrollingEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.startNestedScroll(axes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mScrollingChildHelper.stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.hasNestedScrollingParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed, <span class="keyword">int</span> dxUnconsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed,</span><br><span class="line">                dxUnconsumed, dyUnconsumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedFling(velocityX, velocityY, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreFling</span><span class="params">(<span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedPreFling(velocityX, velocityY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;listView-在-NestedScrollView中解决滑动冲突&quot;&gt;&lt;a href=&quot;#listView-在-NestedScrollView中解决滑动冲突&quot; class=&quot;headerlink&quot; title=&quot;listView 在 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>注解和序列化</title>
    <link href="http://zhousaito.top/2019/11/11/2019-04-28-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://zhousaito.top/2019/11/11/2019-04-28-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:16.414Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>1.无参时，无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnabl = () -&gt; System.out.println(<span class="string">"adfa"</span>);</span><br></pre></td></tr></table></figure><p>2.有一次参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.OnClickListener onClickListener = v -&gt; System.out.println();</span><br></pre></td></tr></table></figure><p>3.2个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyCallback2 myCallback2 = (s, i) -&gt; System.out.println(<span class="string">"sfasdfa"</span>);</span><br><span class="line">myCallback2.call(<span class="string">"saf"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>函数 是第一等公民了</p><p>相当于函数指针 c/c++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一行代码的时候，就这样写</span></span><br><span class="line"> view.setOnClickListener(v -&gt;</span><br><span class="line">                System.out.println());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//带返回值的</span></span><br><span class="line"> Callable callable = () -&gt; <span class="string">"11"</span>;</span><br></pre></td></tr></table></figure><p>Method reference方法引用：</p><p>Inherited， Retotent默认是 source类型吗</p><p>@Repeatable 多个标签 jdk8 的新注解</p><p>反射必须是runtime，</p><p>可以让注解使用多次</p><p>运行时的注解，通过反射来进行获取</p><ol><li>提供信息，编译器来进行检查错误。</li><li>class类型的，通过注解信息来进行生成 代码和 html文档等</li><li>运行时的处理：某些注解可以程序运行时获取</li></ol><p>annotationProcessor google内置的</p><p>apt，</p><p>processors注解扫描程序</p><p>@AutoService， auto-service</p><p>gradlew build</p><p>gradlew clear build</p><p>断点调试：</p><p>处理注解在  getsupportedAnnotationTypes中生成</p><p>build -&gt; gen -&gt; source -&gt; apt</p><p>注解的使用场景，</p><p>source类型，编译器</p><p>class类型， apt</p><p>runtime类型， 在运行时去反射获取</p><p>aapt2 ，apk打包过程中就要用到一个工具，aapt2， 编译资源的</p><p>Wpa</p><p>攻克：annotationProcessor</p><p>annotationProcessor生成额外文件的规则是在依赖库里定义的，只在编译的时候执行，但是库最终不打包到apk中，所以使用Butterknife这类编译注解框架并不会增加apk的大小</p><p>使用：</p><ol><li>先创建java libaray annotations, javaPoet ,processors ，创建androidlib api</li></ol><p>接口利于扩展，本地定义好，Map&lt;ViewFinder&gt;, ViewFinder就代表了这一类，后面继承的ViewFinder，都可以在这个代码里面使用这个ViewFinder使用好的类</p><p><strong>小插曲：</strong></p><p>Android studio 默认jdk路径</p><p>/Applications/Android Studio.app/Contents/jre/jdk/Contents/Home</p><p>mac本地安装的jdk路径 通过</p><blockquote><p>/usr/libexec/java_home -V </p></blockquote><p>进行查看, 内置的没有源码， 不是内置的路径的jdk有源码</p><p><strong>插曲结束</strong></p><ol start="2"><li><p>api写到一半写不下去了，需要生成的代码，然后引入javapoet项目，进行一顿修改，把jdk的版本调整到jdk 8，然后javapoet运行正常</p></li><li><p>然后进行编写Processors，需要导入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api project(<span class="string">':annotations'</span>)</span><br><span class="line">implementation <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class="line">implementation <span class="string">'com.google.auto:auto-common:0.10'</span></span><br><span class="line"></span><br><span class="line">api project(<span class="string">':JavaPoet'</span>)</span><br></pre></td></tr></table></figure></li><li><p>javapoet的基本使用</p><p>$T 会进行映射，自动import声明</p><p>$S 代表一个string</p><p>ClassName： 可以识别任何的声明类</p><p>$N 可以应用另外一个通过名字生成的声明。</p><p>Modifiers  创建接口和抽象类</p><p>Constructors 可以用来创建构造函数</p><p>Parameters 创建参数，或者使用类 MethodSpec 类中addParameters</p><p>Fields </p><p>创建枚举类型： typedec.enumBuilder()</p><p>$L通过$L引用匿名内部类</p></li></ol><ol><li><p>默认返回值是void，所以methodSpec中的returns不是必须要写的</p></li><li><p>方法一定要有 addModifiers， 不然会报错</p><blockquote><p>modifiers [] must contain one of [abstract, static, default]</p></blockquote><p>如何跟大佬交流</p></li></ol><ol start="5"><li><p>遇到一个坑，就是在写完Processor的时候，没加resources这个，就不能生成apt文件，哎，弄了半小时，终于可以生成代码了，到时看看，不用这个可以生成代码没，先往下做</p></li><li><p>解决不能进行AutoService 不能进行启动Processor多个的问题； 编写好bindview</p></li><li><p>gradlew clean build  通过这个命令进行看processor编译，然后打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElementKind kind = element.getKind();</span><br><span class="line">TypeMirror typeMirror = element.asType();</span><br><span class="line">List&lt;? extends AnnotationMirror&gt; annotationMirrors = element.getAnnotationMirrors();</span><br><span class="line">System.out.println(<span class="string">"kind: "</span> + kind + <span class="string">" typeMirror: "</span> + typeMirror + <span class="string">" annotationMirrors:"</span> + annotationMirrors);</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>kind: FIELD </p><p>typeMirror: android.widget.TextView </p><p>annotationMirrors: @com.sdxxtop.annotations.BindView(2131165325)</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> variableElement.getSimpleName()</span><br><span class="line"> 结果： mTextView</span><br><span class="line">  variableElement.getEnclosingElement()</span><br><span class="line">  结果:com.sdxxtop.annotationstudydemo.MainActivity</span><br><span class="line">这玩意是关键啊</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeName.get(hostElement.asType()).getClass() 不能 = hostElement.asType()</span><br><span class="line">    </span><br><span class="line"> com.sdxxtop.javapoet.ClassName这个是ClassName</span><br></pre></td></tr></table></figure><p>引用：</p><p>glide为什么可以同步生命周期</p><p><a href="https://www.jianshu.com/p/472e66632ed0" target="_blank" rel="noopener">看懂编译注解annotationProcessor和kapt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式&quot;&gt;&lt;/a&gt;lambda表达式&lt;/h4&gt;&lt;p&gt;1.无参时，无返回值&lt;/p&gt;
&lt;figure class=
      
    
    </summary>
    
    
      <category term="android" scheme="http://zhousaito.top/categories/android/"/>
    
    
      <category term="android 注解和序列化" scheme="http://zhousaito.top/tags/android-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>4月份的总结2</title>
    <link href="http://zhousaito.top/2019/11/11/2019-05-02-4%E6%9C%88%E4%BB%BD%E7%9A%84%E6%80%BB%E7%BB%932/"/>
    <id>http://zhousaito.top/2019/11/11/2019-05-02-4%E6%9C%88%E4%BB%BD%E7%9A%84%E6%80%BB%E7%BB%932/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:24.322Z</updated>
    
    <content type="html"><![CDATA[<p>{:toc}</p><h3 id="java多线程和线程池"><a href="#java多线程和线程池" class="headerlink" title="java多线程和线程池"></a>java多线程和线程池</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="1：java天生就是多线程的"><a href="#1：java天生就是多线程的" class="headerlink" title="1：java天生就是多线程的"></a>1：java天生就是多线程的</h5><p>java的main方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，实际上java程序天生就是个多线程程序，因为执行的方法是一个名称为main的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过这个代码可以获取到当前的线程数量</span></span><br><span class="line">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Monitor Ctrl-Break //监控 Ctrl-Break<br>Signal Dispatcher //分发处理发送给jvm信号的线程<br>Finalizer // 调用对象finalize<br>Reference Handler //清除 reference的线程<br>main // 用户入口线程</p></blockquote><h5 id="2：线程的启动与中止"><a href="#2：线程的启动与中止" class="headerlink" title="2：线程的启动与中止"></a>2：线程的启动与中止</h5><p>启动的方式 Thread  ， Runnable和callable</p><p>start()</p><p>Suspend(), resume()和stop()， 但是这些api是过期的，线程调用suspend()，调用后，线程不会释放已经占用的资源（比如锁），如果不保证线程正常释放，可能没有给予线程释放工作的机会，因此会导致程序可能工作在不确定的状态下。</p><p>Thread.interrupted()和Thread.currentThread().isInterrupted()的区别</p><p>Thread.currentThread().isInterrupted():是一个很正常的方法，就是判断线程的状态，不会做出什么改变</p><p>Thread.interrupted()会将状态重置，如果是 false的情况下，就不会重置状态，因为就是调用后，让这个线程。感觉线程重新获取了生命，所以后面调用Thread.interrupted()，不会将状态重置了，除非重新调取 Thread.currentThread().interrupt():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.currentThread().interrupt(); <span class="comment">//如果这行代码没有写，第一次也是false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"第一次返回的值"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"第二次返回的值"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"第三次返回的值"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"第四次返回的值"</span> + Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">"第五次返回的值"</span> + Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">结果：</span><br><span class="line">第一次返回的值<span class="keyword">true</span></span><br><span class="line">第二次返回的值<span class="keyword">false</span></span><br><span class="line">第三次返回的值<span class="keyword">false</span></span><br><span class="line">第四次返回的值<span class="keyword">false</span></span><br><span class="line">第五次返回的值<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>这就充分解释了，interrupt是协作式的，不是强制式，这样就比较安全，可以正常释放线程的一些资源</p><h5 id="3-处于死锁状态的线程无法通过interrupt中断"><a href="#3-处于死锁状态的线程无法通过interrupt中断" class="headerlink" title="3: 处于死锁状态的线程无法通过interrupt中断"></a>3: 处于死锁状态的线程无法通过interrupt中断</h5><p><strong>草稿：</strong></p><p>写一个基于线程池的例子，就是下载文件。可以自己进行网络请求封装，等等一些操作。可以网络查找一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;{:toc}&lt;/p&gt;
&lt;h3 id=&quot;java多线程和线程池&quot;&gt;&lt;a href=&quot;#java多线程和线程池&quot; class=&quot;headerlink&quot; title=&quot;java多线程和线程池&quot;&gt;&lt;/a&gt;java多线程和线程池&lt;/h3&gt;&lt;h4 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="android" scheme="http://zhousaito.top/categories/android/"/>
    
    
      <category term="android 总结" scheme="http://zhousaito.top/tags/android-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>4月份的总结</title>
    <link href="http://zhousaito.top/2019/11/11/2019-05-01-4%E6%9C%88%E4%BB%BD%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://zhousaito.top/2019/11/11/2019-05-01-4%E6%9C%88%E4%BB%BD%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:20.656Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h4 id="复习内容"><a href="#复习内容" class="headerlink" title="复习内容"></a>复习内容</h4></li></ul><ol><li>gradle使用</li><li>jvm</li></ol><h5 id="gradle使用"><a href="#gradle使用" class="headerlink" title="gradle使用"></a>gradle使用</h5><ol><li><p>gradle是一种自动构建化语言，目前是android的默认构建工具，是一个编程框架</p></li><li><p>一些使用命令：</p><blockquote><p> gradlew clean clean项目</p><p> gradlew build  构建项目</p><p> gradlew assembleDebug or gradlew aD  编译并打包Debug包</p><p> gradlew assembleRelease or gradlew aR  编译并打release包</p><p> gradlew installRelease  or   gradlew iR  release模式打包并安装</p><p> gradlew installDebug  or  gradlew iD   Debug模式打包并安装</p><p> gradlew uninstallRelease or  gradlew uR   卸载Release模式包</p><p> gradlew uninstallDebug or  gradlew uD 卸载Debug模式包</p><p>需要说明的是，有些可以叠加使用</p><p>gradlew clean build —info &gt; bugTags.log</p></blockquote></li><li><p>grooxy语言</p><blockquote><p>def 关键字：返回值</p><p>String: 分两种类型 groovy.lang.GString , java.lang.String</p><p>List: 定义 def value = [“a”,”c”, “b”];  value[0] = 4;  默认是ArrayList </p><p>​    如果需要 LinkedList  value = []; 这样就强制为了 LinkedList了</p><p>Map： def value = [“a”: “str”, “b”: 1]  这里的map是个 []的，不是 {}</p><p>Range：范围值</p><p>metaClass:  在groovy运行期间使用metaClass添加方法和属性</p><p>闭包：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">def</span> listener = (&#123; -&gt; println(<span class="string">"click on"</span>) &#125;)</span><br><span class="line">&gt;演变成：</span><br><span class="line">&gt;<span class="keyword">def</span> listener = &#123; -&gt; println(<span class="string">"click on"</span>) &#125;</span><br><span class="line">&gt;<span class="keyword">def</span> listener = (&#123; println(<span class="string">"click on"</span>) &#125;)</span><br><span class="line">&gt;再演变：</span><br><span class="line">&gt;<span class="keyword">def</span> listener = &#123; println(<span class="string">"click on"</span>) &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>gradle的执行流程</p><ul><li>初始化界面：解析settings.gradle来获取模块信息</li><li>配置阶段：配置每个模块，构建task树</li><li>执行阶段：执行任务</li></ul></li><li><p>project相关的api</p><blockquote><p>getRootProject: 获取根project</p><p>getAllProjects：获取所有Project</p><p>getSubProjects：获取所有的子project</p><p>allProjects：遍历所有的project</p><p>subprojects：遍历所有子project</p></blockquote></li><li><p>属性相关的API</p><p>hasProperty：检测属性是否存在</p><p>findProperty：查找属性</p><p>自定义property：</p><ul><li><p>命令行定义属性 ： gradle build -P pro = 100</p></li><li><p>通过project.ext定义参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ext.a = <span class="number">1</span></span><br><span class="line">或者：</span><br><span class="line">ext &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>task相关的api</p><ul><li>getTasks: 获取当前project所有task</li><li>task 创建一个task、</li></ul></li><li><p>文件相关的API</p><ul><li>file： 获取文件</li><li>fileTree: 获取文件夹</li><li>getBuildDir：获取build文件夹</li></ul></li><li><p>gradle生命周期API</p><ul><li><p>beforeEvaluate： 配置阶段开始之前</p></li><li><p>afterEvaluate： 配置阶段结束</p><blockquote><p>当走到这里，所有的task的配置都已经完成，然后可以在这里加入自定义的task</p></blockquote></li><li><p>gradle.buildFinished：执行阶段结束</p></li></ul></li><li><p>其它api</p><p>执行外部命令</p><ol><li><p>exec：执行外部命令；是project中的</p><blockquote><p>mac的执行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   &gt;project.exec &#123;</span><br><span class="line">executable <span class="string">'bash'</span></span><br><span class="line">args <span class="string">'-c'</span>, cmd</span><br><span class="line">   &gt;&#125;</span><br></pre></td></tr></table></figure><p>windows执行方式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   &gt;project.exec &#123;</span><br><span class="line">executable <span class="string">'cmd'</span></span><br><span class="line">args <span class="string">'/c'</span>, cmd</span><br><span class="line">   &gt;&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol></li><li><p>Task</p><p>gradle很重要的一个东西</p><ul><li><p>task定义</p><blockquote><p>task myTask {</p><p>​    println “myTask”</p><p>}</p><p>最后一个参数是闭包，所以这里省略了圆括号</p><p>可以通过下面方式创建</p><p>project.tasks.create(name: “myTask”) {</p><p>​    println “myTask”</p><p>}</p></blockquote></li><li><p>task的基本信息配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task MyTask (<span class="string">a:</span> <span class="string">"a"</span>, <span class="string">b:</span> <span class="string">"b"</span>) &#123;println <span class="string">"$a和$b"</span>&#125;</span><br><span class="line">或者</span><br><span class="line">task MyTask &#123;</span><br><span class="line">    a <span class="string">"a"</span></span><br><span class="line">    b <span class="string">"b"</span></span><br><span class="line">    println <span class="string">"$a和$b"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Task依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">task b &#123;</span><br><span class="line">    dependsOn A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要执行b的时候会先执行A，然后再执行b</p></li><li><p>task执行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    println <span class="string">"1"</span></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">"2"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"3"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实战自定义plugin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo</span><br></pre></td></tr></table></figure></li></ol><h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h5><h6 id="1-虚拟机的发展"><a href="#1-虚拟机的发展" class="headerlink" title="1:虚拟机的发展"></a>1:虚拟机的发展</h6><p> go语言去实现jvm是比较简单的</p><blockquote><p>hotSpot VM  目前使用最广的虚拟机； 我的mac上面的sdk用的就是类的</p><p>JRockit VM 号称是最快的java虚拟机；</p><p>J9 VM ibm公司的</p><p>Dalvik VM  google给android使用的虚拟机</p></blockquote><p>未来的java技术</p><blockquote><p>模块化</p><p> OSGI 模块化 </p><p>微服务</p><p>混合语言 （java ， scala）</p><p>多核并行 （函数式编程）</p><p>丰富的语法</p><p>64位</p><p>更强的垃圾回收 回收 gb级别的， jdk11是gb级别的。</p></blockquote><h6 id="2：内存的划分"><a href="#2：内存的划分" class="headerlink" title="2：内存的划分"></a>2：内存的划分</h6><p>线程间共享的：堆和方法区</p><p>线程间独享的： 程序计数器，虚拟机栈，本地方法栈</p><p>​    虚拟机栈中有-&gt; 栈帧：局部变量表，返回地址，操作数栈，动态连接</p><p>独享就是当线程结束了，内容也随之释放了，没有线程安全问题；共享的话，就引入了锁这些问题，不是线程安全的</p><p><strong>程序计数器：</strong>指向当前程序的字节码，线程间需要切来切换去，唯一个没有OOM的地方</p><p>为什么java要是用栈来进行方法调用：因为非常符合java间方法的调用</p><blockquote><p>javap -v Test.class &gt; 1.txt  然后获取字节码</p></blockquote><p><strong>局部变量表</strong>：只能存放32位的数据，放一些方法内部的一些变量，如果是64位，就会使用高低位占用两个也可以存放下来。<strong>存放基本类型的变量数据和对象的引用</strong></p><p><strong>操作数栈</strong>：存放我们方法执行的操作数。它就是一个栈的结构，进行一些数据的计算</p><p><strong>动态连接</strong>：用来多态使用，java动态运行性，需要类加载运行时，才能确定具体的方法</p><p><strong>返回地址</strong>：程序正常执行的时候，就会执行到这里，然后返回</p><h6 id="本地方法栈：各虚拟机自由实现"><a href="#本地方法栈：各虚拟机自由实现" class="headerlink" title="本地方法栈：各虚拟机自由实现"></a>本地方法栈：各虚拟机自由实现</h6><h6 id="线程的共享区域"><a href="#线程的共享区域" class="headerlink" title="线程的共享区域"></a>线程的共享区域</h6><p><strong>方法区/永久代</strong></p><p>用于存储已经被虚拟机记载的类信息，常量（”123“，”asfda“等），静态变量（static变量）</p><p>Jdk7 以及以前： -XX:PermSize: -XX:MaxPermSize;</p><p>jdk1.8 以后： -XX：MetaspaceSize： -XX：MaxMetaspaceSize</p><p>jdk1.8 以后大小就只受本机总内存的限制</p><p><strong>堆</strong></p><p>几乎所有的对象都分配在这里，也是垃圾回收发生的主要区域，可用一些参数进行太调整</p><p>…</p><p><strong>直接内存</strong></p><p>不是虚拟机运行时的数据区的一部分，也不是java虚拟机规范中的定义的内存区域；但是受本机总内存限制。也会产生<strong>OOM</strong></p><h6 id="站在线程的角度来看"><a href="#站在线程的角度来看" class="headerlink" title="站在线程的角度来看"></a>站在线程的角度来看</h6><p>线程的私有内存区：随着产生和消亡，因此不要过多考虑内存回收的问题，编译时就确定了所需内存的大小。</p><h6 id="深入辨析堆和栈"><a href="#深入辨析堆和栈" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h6><p><strong>功能</strong></p><p>以栈帧的方式存储方法的调用过程，并存储方法调用过程中基本数据类型的变量，已经对象的应用变量，其内存分配在栈上，变量出了作用域，就会自动释放。</p><p>而堆内存用来存储java中的对象，无论成员变量，局部变量，还是类的变量，指向的位置是在堆中。（这个怎么画图，应该是对象模型图？？？）</p><p><strong>线程独显还是共享</strong></p><p>栈是属于单个线程所有，相当于线程的私有内存</p><p>堆中的所有对象，对所有线程可间。</p><p><strong>空间大小</strong></p><p>栈的空间远远小于对内存</p><p>当栈进行无限制的递归调用的时候，会出现<strong>OOM</strong>，方法的执行要打包成<strong>栈帧</strong>，<strong>所以天生实现同一个功能的时候要慢</strong>，比如树的遍历递归，比较简单，但是比一般的实现要慢，一般的实现代码比较复杂，但是速度快</p><h5 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h5><p>虚拟机遇到一条new的指令时：</p><p>1）检查加载： 先执行相应的类加载过程。</p><p>2）分配内存：</p><p>​    指针碰撞：确定一块内存是否能存放下这个对象，如果不能，就继续往下找，找不到就进行垃圾回收了，在eden去就进行mirror Gc 等。这个分配过程就是指针碰撞。</p><p>​    空闲列表：如果java堆中的内存并不规整的，已使用的内存空间相互交错，那就没有办法简单的进行指针碰撞，虚拟机必须维护一个列表，记录那些内存块可以用，那些不可用，在分配的时候从列表中找到一块足够大的空间划分给对象，并更新列表上的几率，这个分配方式称为”空闲列表“。</p><p>选择哪种方式由java堆是否规整决定了，还有和采取的算法有关系</p><p><strong>并发安全</strong></p><p>除如何划分空间外，还要考虑并发安全的问题。</p><p>cas操作，如果内存分配失败，会进行重试， bab问题</p><p><strong>分配缓冲</strong></p><p>TLAB，Thread local allocation Buffer，TLAB， 本地线程的分配缓冲，提高分配效率，如果容量不够了，就重新重Eden区域申请。</p><p><strong>内存空间初始化</strong></p><p>就是给 没有初值的成员变量，进行初始值设定</p><p><strong>设置</strong></p><p>接下来，虚拟机堆对象进行必要的设置，例如这个对象是那个类的实例、如何找到类的元数据信息，对象的hash码，对象的GC分带年龄等信息。这些信息存放在对象的对象头之中。</p><p><strong>对象的初始化</strong></p><p>在上面工作完成后，从虚拟机的角度来看，一个新的对象已经产生了，从程序的角度来讲，才刚刚开始。在程序员new了之后，对象就产生了。</p><h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>在hotSpot的虚拟机中，对象在内存中存储的布局分为三块区域：对象头，实例数据和对齐填充。</p><p>对象头包括两部分形象，第一部分用于存储对象自生</p><p><strong>栈上分配</strong></p><p>字符串存放在什么位置</p><p>基本数据类型存放在什么位置</p><p>对象的内存模型</p><h4 id="学习垃圾回收的意义"><a href="#学习垃圾回收的意义" class="headerlink" title="学习垃圾回收的意义"></a>学习垃圾回收的意义</h4><p>java与C++等语言的最大技术的区别：自动化的垃圾回收机制</p><p>为什么要了解GC和内存分配策略</p><p>1、面试需要</p><p>2、GC对应的</p><p>3、写代码有好处</p><p>栈：堆中的生命周期是跟随线程，所以一般不需要关注</p><p>堆：堆中的对象是垃圾回收的重点</p><h5 id="GC案例"><a href="#GC案例" class="headerlink" title="GC案例"></a>GC案例</h5><p>自动回收机制也有失败的时候oom</p><h5 id="新生代配置"><a href="#新生代配置" class="headerlink" title="新生代配置"></a>新生代配置</h5><p>新生代大小配置参数的优先级：</p><h5 id="判断对象的存活"><a href="#判断对象的存活" class="headerlink" title="判断对象的存活"></a>判断对象的存活</h5><p>引用计数法：快，方便，实现简单，缺点：对象相互引用的时候不好判断</p><p>虚拟机栈（栈帧中常用的引用变量表）中引用对象。</p><p>方法区中类静态属性引用的对象。</p><p>方法区中常量引用的对象。</p><p>本地方法栈中JNI引用的对象</p><h5 id="各种引用"><a href="#各种引用" class="headerlink" title="各种引用"></a>各种引用</h5><p><strong>强引用</strong>：new出来的对象都是强引用</p><p><strong>软引用</strong>：softWeakReference 软引用即将发生oom的时候进行回收</p><p><strong>弱引用</strong>：weakReference 发生GC的时候就会被回收，不管内存足不足，都会被回收</p><p><strong>虚引用</strong>：垃圾回收的时候会通知一下</p><p>草稿：</p><p>异常处理器表</p><blockquote></blockquote><p>Class.forName() 和 ClassLoader加载类的区别</p><blockquote><p>Class.forName()：本质是通过ClassLoader加载的，但是会进行一些初始化操作，静态代码块的操作。</p><p>ClassLoader：只是把类记载到虚拟机中，不会有任何初始化操作</p><p><a href="https://www.cnblogs.com/jimoer/p/9185662.html" target="_blank" rel="noopener">在Java的反射中，Class.forName和ClassLoader的区别</a></p></blockquote><p>final关键在内存中的常量区，但是和static不同的是，static类进行加载后，就会被初始化，而final的是在用的时候初始化</p><p><a href="https://www.jianshu.com/p/f68d6ef2dcf0" target="_blank" rel="noopener">Final of Java，这一篇差不多了</a></p><blockquote><p>native堆还是在用户空间，是存在数据从内核到堆外空间的拷贝的</p><p>native堆是在用户空间<br>堆外内存 1次拷贝<br>堆内存 2次拷贝</p></blockquote><p>空间担保</p><p><strong>优化一下简历</strong></p><h4 id="产考"><a href="#产考" class="headerlink" title="产考"></a>产考</h4><p><a href="https://www.jianshu.com/p/91f238947977" target="_blank" rel="noopener">gradlew常用命令</a></p><p><a href="http://www.groovy-lang.org/closures.html" target="_blank" rel="noopener">gradle闭包的官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;h4 id=&quot;复习内容&quot;&gt;&lt;a href=&quot;#复习内容&quot; class=&quot;headerlink&quot; title=&quot;复习内容&quot;&gt;&lt;/a&gt;复习内容&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;gradle使用&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://zhousaito.top/categories/android/"/>
    
    
      <category term="android 总结" scheme="http://zhousaito.top/tags/android-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>自定义View</title>
    <link href="http://zhousaito.top/2019/11/11/2019-05-06-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    <id>http://zhousaito.top/2019/11/11/2019-05-06-%E8%87%AA%E5%AE%9A%E4%B9%89view/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:28.305Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="View基础"><a href="#View基础" class="headerlink" title="View基础"></a>View基础</h3><ol><li><p>getLeft(), getRight(),getTop(),getBottom(),是相对于父view的位置</p><p>view的左边距离父view左边的距离</p><p>view的右边距离父view左边的距离</p><p>view的顶部距离父view的顶部的距离</p><p>view的顶部距离父view的顶部的距离</p><p>点击事件的距离：</p></li></ol><blockquote><p>触摸点相对于其所在组件坐标系的坐标</p><p>event.getX()  view自己左边的距离</p><p>event.getY()  view自己顶部的距离</p></blockquote><blockquote><p>触摸点相对于屏幕默认坐标系的坐标</p><p>event.getRawX()</p><p>event.getRawY()</p></blockquote><p>   角度增大是逆时针，</p><p>   颜色值：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> color1 = Color.argb(<span class="number">147</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">33</span>);</span><br><span class="line"><span class="keyword">int</span> color2 = Color.GRAY;</span><br><span class="line"><span class="keyword">int</span> color3 = <span class="number">0xffffddaa</span>;</span><br></pre></td></tr></table></figure><p>   先measure ，然后OnMeasure<br>   在unspacified 默认的 宽/高=默认大小 ，会去判断是否有背景大小</p><p>   显示布局， 贝塞尔曲线</p><p>   b(t) = p0 + t(p1 - p0) = (1-t)p0 + tp1 , 0&lt;=t&lt;=1;</p><p>   一阶的没有控制点</p><p>   所以三阶是2个控制点，三个点就可以确定了，控制点和结束点，贝塞尔曲线</p><p>   <strong>paint 画线的话 用stroke</strong></p><p>   for循环耗时 和 减少个for循环进行判断</p><p>   onMeasure - 》 onSizeChange</p><p>   Path , 贝塞尔曲线，canvas</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;mPath.reset(); //这个就相当于重新将画笔放到0，0</span><br><span class="line">&gt;mPath.lineTo(100, 100);</span><br><span class="line">&gt;//相当于 ，但是有一点区别，这个不会重置原来画的界面</span><br><span class="line">&gt;mPath.moveTo(0, 0);</span><br><span class="line">&gt;mPath.lineTo(100, 100);</span><br><span class="line">&gt;对称的时候，用宽度- 那边的位移就可以了</span><br><span class="line">&gt;后面发现中心点没有找对，所以出现了问题</span><br></pre></td></tr></table></figure></blockquote><p>   Kotlin：成员变量问题<br>   kotlin 没有了 三目运算 用 if else 来代替</p><p>   转Int的时候 用 toInt() 来进行转换</p><p>   Reified 告别class</p><p>   lateinit var c：String<br>   val e: String by lazy {</p><p>   ​    String()</p><p>   }</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">kotlin 中成员变量应该一开始就确定，进行初始化</span><br><span class="line"></span><br><span class="line">get的修饰范围，随成员变量的属性走</span><br><span class="line">private var c = 1</span><br><span class="line">        private get() &#123;</span><br><span class="line">            return field;</span><br><span class="line">        &#125;</span><br><span class="line">        private set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">基本类型：</span><br><span class="line">指定一个值就可以了</span><br><span class="line"></span><br><span class="line">lateinit 不能作用在8的基本类型上</span><br><span class="line"></span><br><span class="line">roomList?size ?: 0 //当list是空是就返回0</span><br><span class="line"></span><br><span class="line">deiliget</span><br><span class="line"></span><br><span class="line">运算符：</span><br><span class="line">infix  中缀表达式 关键字 可以不用 DSL 里面使用， 代码可读性会降低</span><br><span class="line"></span><br><span class="line">kotlin</span><br><span class="line">jetbrains</span><br><span class="line"></span><br><span class="line">readLine</span><br><span class="line"></span><br><span class="line">文件操作</span><br><span class="line"></span><br><span class="line">if 还可以有返回值</span><br></pre></td></tr></table></figure><p>注解就相当于打标签， <strong>注解的本质就是动态代理的实现</strong></p><p>注解生成对象是proxy0吗</p><p>运行时，可以获取属性或方法，进行修改或调取</p><p>依赖注入，</p><p>dagger2和butterknife有一定的区别</p><p>什么是依赖？ 就是一种需要，需要这个对象； 人需要买房子。</p><p>依赖倒置： 复习六大基本原则， 能用父类的地方用父类，如果有改变的时候，就要修改原来的源代码， 高层模块不应该有底层的依赖，，细节应该依赖抽象</p><p>上层 控制下层，就是依赖倒置了。</p><p>抽象约束行为，具体实现行为，</p><p>面向抽象编程，面向接口编程， 依赖倒置</p><p>控制反转。 person只要关系功能，不关心实现，</p><p>依赖-）依赖倒置-》控制反转（父类的应用，传子类对象）</p><p>构造方法注入：</p><p>set方法注入：</p><p>接口注入：</p><p>设计模式：就是六大基本原则的体现</p><p>工厂设计模式，</p><p>Jsr-330 是java的依赖注入的标准</p><p>a类型依赖b类型</p><p><strong>运行时</strong>查找依赖的过程，称为“解析resolving”依赖</p><p>如果没找到实例，称该依赖unsatisfied</p><p>javax.inject 依赖注入</p><p>@Inject 方法，构造器，方法或字段</p><p>@Provider&lt;T&gt; 结构 Provider 用于类型T的实例</p><p>@Qualifier，定义新注解的时候用到它</p><p>@Named 基于String的限定器</p><p>@Scope，作用域，某个线程有效，某个范围有效</p><p>@Singleton， 注入器实例化一次类型，该注解不被继承</p><p>依赖注入只能做到解耦性，</p><p>程序员的最高境界，就是解耦  保证代码的健壮  灵活 可维护</p><p>Dagger2  ： apt技术，生成一些辅助代码，<br>dagger2是dagger的升级版，是square公司出的第一版，然后dagger2是google工程师fork过去，然后重构了。</p><p>dagger2单例的原理</p><p>@Inject 标记要依赖的变量 2，标记构造函数，来为标记了@Inject的变量</p><p>@Module：提供依赖第三方的，需要提供依赖的构造函数，是三方，提供第三方的依赖</p><p>@Provides：  预先提供依赖的对象给标注了@Inject的变量赋值</p><p>@Inject  只能标志一个构造方法，编译的时候会报错</p><p>构造方法，也是可以的</p><p>如果既有inject的也有module，优先使用module的</p><p>提供两个一样类型的， 限定符</p><p>module也使用限定符，来进行注解</p><p>@Qualifier 可以当两个一样类型的时候，可以使用到</p><p>@Named就是限定符的一种</p><p>scope全局引擎</p><p>同一个范围的，对象只会创建一次；使用了范围构造，就只会调用一次了，</p><p>提供第三方</p><p>注射器也要有个范围， doublecheck双重检测的方式来进行的</p><p>mv vm</p><p>mvp</p><p>Scope  不能放在module 类上面 ，放在provides的方法上面</p><p>@Inject 构造方法会生成对应的  factory 就是 类名_Factory</p><p>@Inject 成员变量 就会生成 对应的注解器_MembersInjector</p><p>@Module &amp;&amp; @Provides 注入第三放对象，会生成<br><strong>类名_方法名大写Factory</strong> 的这样的类</p><p>具体当在对应的注入类中初始化的时候用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是注入容器的Builder方法调用，初始化的时候调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getActivityProvider =</span><br><span class="line">        DoubleCheck.provider(ActivityModule_GetActivityFactory.create(builder.activityModule));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在scope下，让后就通过这些factory进行创建独一的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是注入容器的Builder方法调用，初始化的时候调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getActivityProvider =</span><br><span class="line">        DoubleCheck.provider(ActivityModule_GetActivityFactory.create(builder.activityModule));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.homePresenterProvider =</span><br><span class="line">        HomePresenter_Factory.create(MembersInjectors.&lt;HomePresenter&gt;noOp());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>``这个符号是强行将不合法的改为合法的</p><p>在Kotlin中可以用反引号解决关键字冲突的问题，可以强行将一个不合法的字符变为合法。</p><p>cookie</p><p><strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。</p><p><a href="https://www.cnblogs.com/zhujiabin/p/6207913.html" target="_blank" rel="noopener">Android 使用Okhttp/Retrofit持久化cookie的简便方式</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e: ApiException? = <span class="literal">null</span></span><br><span class="line">局部变量声明</span><br><span class="line"><span class="meta">@JvmOverloads</span> <span class="comment">//重载的标志</span></span><br><span class="line">getRetrofit(baseUrl: String, provider: NetProvider? = <span class="literal">null</span>)</span><br><span class="line">两个参数的方法竟然可以传一个值</span><br></pre></td></tr></table></figure><p>okhttp3 interceptor 原理</p><p>Okhttp3 https标准的访问</p><p>Okhttp3 websocket</p><p>java网络这一块</p><p><a href="https://www.cnblogs.com/fysola/p/6088893.html" target="_blank" rel="noopener">JAVA基础知识之网络编程——-使用MutilcastSocket实现多点广播</a></p><p>应用层，  传输层， 网络层，网络接口层</p><p>Tcp端对端的传输</p><p>应用层，表示层，会话层</p><p>Seq =0<br>Seq=0 ack = 1<br>Seq =1 ack=1</p><p>HTTP 的3次握手是准备资源的过程；HTTP 的4次握手是释放资源的过程</p><p>Tcp 三次握手：tcp目的是为了通讯 ，客户端和服务端都要确保，能读能写</p><p>断开，也可以服务器断开，也可以客户端断开</p><p>fin + 1    ack</p><p>服务端还有数据没发完，当发完的时候，然后 在发送 服务器端的 fin 数据，所以分两次</p><p>http2.0 2015出现的</p><p>socket去请求，可以保持这次socket，可以下次拿来使用，如果是connecttion：keep-alive   就是可以进行长连接，通信</p><p>spdy google提出来的 okhttp也实现了这个，被http2.0代替了</p><p>http2.0，和http.1x想是一个全新的一个协议了。1.x的时代是字符串通信。2.0是二进制通信了</p><p>\r\n</p><p>读取449行，然后就成功响应了</p><p>builder，okhttp有责任链模式<br>接口设计是否合理</p><p>http有一种<code>keepalive connections</code>的机制，可以在传输后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手</p><p>责任链设计模式</p><p>1、开闭原则 对扩展开放，对修改关闭 多使用抽象类和接口<br>2、里氏代换原则 基类可以被子类替换 使用抽象类继承，不使用具体类继承<br><del>3、合成复用原则 要依赖于抽象，不依赖于具体 要针对接口编程，不根据实现编程</del><br>4、接口隔离原则 使用多个隔离的接口，比使用单个接口好 建立最小的接口<br>5、迪米特法原则 一个软件实体应尽可能少地与另一个实体发生相互作用 通过中间类建立联系<br>6、依赖倒转原则 尽量使用合成/聚合，而不是使用继承 尽量使用合成/聚合，而不是使用继承</p><p>单一职责：一个类就干一个事情<br>里氏替换：能用到父类的地方就用父类（这个指抽象类）<br>依赖倒置：能用接口的地方就用接口（这个指接口）<br>开闭原则：对修改关闭，对扩展开放<br>接口隔离：尽量把接口拆分成多个接口，让接口不那么的臃肿<br>迪米特（也叫 最小知识）：一个实体尽可能少的更另一个实体接触</p><p>单一职责和接口隔离，感觉是有点像，但是接口隔离注重接口；单一职责重点值 职责单一<br>里氏替换和依赖倒置：也差不多，只不过一个是指抽象类，一个指的是接口</p><p>序列化</p><hr><p>如果传输用serializable<br>进程之间的通信，传输数据：</p><p>AIDL，contentProvide</p><p>远程 <strong>rpc</strong> 也可以数据通信</p><p>内核内存共享</p><p><strong>xml json protobuf 都是序列化的一个手段，不能叫序列化吧</strong><br>序列化：将对象或数据结构转换成<strong>二进制</strong>的过程</p><p>反序列化，</p><p>谷歌出的序列化方案，可以压缩32位数据，<br>很多im传输用protobuf来实现的</p><p><strong>为什么activity之间是同一个进程为什么还要序列化？？</strong></p><p>ams是跨进程的。</p><p>序列化只对变量进行序列化，针对于对象，不针对<strong>方法</strong>进行序列化</p><p>序列化协议：</p><ol><li>技术层面：是否要跨平台，跨语言，通用性问题</li><li>流行程度：</li></ol><p>健壮性：xml json protobuf</p><p>成熟度不够</p><p>性能：</p><p>空间和时间方面：</p><p>空间开销：</p><p>时间开销：复杂的序列化协议会导致较长的解析时间，这可能会使用序列化和反序列化阶段成为整个系统的瓶颈，</p><p>可扩展性/兼容性</p><p>安全性/访问限制</p><p>Protocol buffers  19000 -19999 不能使用，是保留字段</p><p>32，这里是4个字节原因，会压缩32位</p><p>压缩算法在里面，压缩算法32位</p><p>proto的目录<br>Base-128 整形可变长编码</p><p>rpc 调试 rpc效率优先</p><p>protobuf 32位的可以压缩合成一个，几十倍的压缩率，</p><p><strong>transient 修饰的不需要进行序列化。静态变量不会进行序列化。</strong><br>需要一个无参的构造方法</p><p>不加入 serialVersionUID ，不好兼容了，如果修改信息了，然后就会又根据类进行反序列化成新的 serialVersionUID了，兼容性可能不好</p><p>Externalable 也是实现Seralzible接口，只不过要手动实现里面的方法</p><p>.java的文件，jvm，怎么知道是java文件， 也有个魔术，<strong>文件头，对象头</strong></p><p>objectStream里面，会进行反射 writeObject  <strong>可以用于特殊需求</strong></p><p>arrayList 中有 wirteObject实现了，但是elmentData进行了序列化，因为elmentData，<strong>大部分会为空，所以为空的就不进行序列化，只对有效数据序列化</strong>，这是jdk序列化的优化。</p><p><strong>序列化的坑</strong>：</p><ol><li><p>同一个引用只会写一次，要做一些处理</p><p>oos.wirteUnshare ,或者重置流</p></li><li><p>子类实现了序列化，父类实现 serializable</p></li><li><p>类的演化，反序列化的时候不会报错，但是会没有值</p></li><li><p><strong>枚举类型</strong></p></li><li><p>序列化单例对象：打单机游戏什么的可能有需求要存单例对象。</p></li></ol><p>serializable，很多反射，会产生很多中间变量，导致大量的内存碎片，</p><p>parcel  parcelable，就是打包的意思</p><p>parcelable，只是存在内存中，内存中序列化的方案，<strong>硬是要写硬盘也可以</strong></p><p>parcelable 性能方面</p><p>存文件用serializable， 只是跨进程用parcelable</p><p>SQLite与SP</p><p>binder，的缓冲区是有限制的，一般默认一个进程只有16个binder，</p><p>xml：是基于树形结构</p><p>操作频繁，文档较小，动态添加，删除节点用DOM解析</p><p>js解析html就是dom解析</p><p>知识储备</p><p>版本问题，</p><p>移动端不怎么相关的但是是互联网端的：负载均衡</p><p>Keepalives -&gt; okhttp复用池</p><p>找姐夫说一下，自己公司现在是个什么状态，听听他的意见，不一定要全听，但是要去提取有用的条件</p><p>依赖倒置-》  在构造方法里面直接用</p><p>父类的引用 = 子类对象</p><p>控制反转-》构造函数或者方法用父类的引用，外面传子类的对象，相当于内部的对象，有外部提供了，不在是自己亲自创建了</p><p>毒瘤应用-进程保活</p><h5 id="json"><a href="#json" class="headerlink" title="json"></a>json</h5><p>writeObject 和 readObject 原理， 时序图很重要</p><p>json的网络请求</p><p>json是来传输的</p><p>json小于100m，数据多的时候用 protobuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSONObject //基于文档驱动的，会全部加载到内存中</span><br></pre></td></tr></table></figure><p>retrofit有默认解析吗？默认是gson解析吗？</p><p>文档驱动：就是一次性把文档加入进去</p><p>gson基于事件的启动方式， <strong>gson，什么时候有隐藏bug了，忘记听了</strong></p><p>jackson解析也是基于事件驱动， jackson效率比gson高，配置一下也可以不用一一对应可以进行正常解析</p><p>FastJson：有隐藏的bug</p><p>切片 ， 按照 “\n\t\br” 来进行切片</p><p>算法匹配，<br>词法分析 “{” “}” 这种符号，是词法分析<br>然后再语法分析<br>jsonDe</p><p>getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 </p><p>getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。</p><p>具体编码如下：</p><p>ArrayList 增删，效率都不高，因为伴随的System.arraycopy这个操作符很低</p><p>Kotlin 中 实现 接口 ，没带括号，而抽象类，需要个括号</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogiMouse</span></span>(mouseName: String, <span class="keyword">override</span> <span class="keyword">var</span> j: <span class="built_in">Int</span>) : LogiMouse(mouseName), USBInputDevice</span><br></pre></td></tr></table></figure><p>Abstract 类默认是 open的，如果不是抽象类，需要添加open才能被继承</p><p>如果方法需要被复写，如果不是abstract的，就需要被添加open</p><p>kotlin中属性也能进行复写</p><p>接口代码  by  接口代理</p><p>当名字相同的时候。</p><p>internal 模块内可见</p><p>object 就是单例的</p><p>伴生对象和静态方法</p><p>@JvmStatic 这样java就可以正常的静态方法调用了</p><p>@JvmOverloads这个重载方法</p><p>jvm函数签名，默认参数和方法重载可以相互转换</p><p>在java中看到默认参数相当于重载，</p><p>反例就是  remove(Object o) ， remove(int i)</p><p>字符串很多方法</p><p><strong>扩展成员</strong>：二次加工 </p><p>加了个 什么点  </p><p>fun String.multiply() {}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(value)&#123;</span><br><span class="line">    field = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lazy 前面的变量名字实际就是个傀儡</p><p>kotlin 的锁， 怎么数据源排序</p><p>（）== data class 就是 componentN的调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;View基础&quot;&gt;&lt;a href=&quot;#View基础&quot; class=&quot;headerlink&quot; title=&quot;View基础&quot;&gt;&lt;/a&gt;View基础&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;getLeft(), getRight(),getTop(),g
      
    
    </summary>
    
    
      <category term="android" scheme="http://zhousaito.top/categories/android/"/>
    
    
      <category term="android 自定义View" scheme="http://zhousaito.top/tags/android-%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>file和stream</title>
    <link href="http://zhousaito.top/2019/11/11/2019-05-14-file_stream%E6%93%8D%E4%BD%9C/"/>
    <id>http://zhousaito.top/2019/11/11/2019-05-14-file_stream%E6%93%8D%E4%BD%9C/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:32.840Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="File和Stream"><a href="#File和Stream" class="headerlink" title="File和Stream"></a>File和Stream</h3><p>Java io, okio,   apk加固 okio封装socket</p><p>并发的 io</p><p>学习</p><p>整体设计要有自己的理解，</p><p>i/o的发展历史，</p><p>文件-》 FileOutputStream-》BufferedOutputStream -》</p><p>DataOutputStream可以具体获取字节类型</p><p>传递上下文，</p><p>view相关的用activity的context其他用getApplication()，</p><p>代理模式-》 对方法增强 代理模式对外部增强</p><p>装饰者设计模式-》 继承并进行扩展</p><p>包含 菱形的那个标志，是包含的意思</p><p>装饰设计模式，分析context</p><p>如何去学习，</p><p>为了装饰，所以把read抽象了起来， FileDescript —&gt; 是newIO出来的</p><p>FilterOuputStream：就是为了持有OutputStream的装饰类 Decorator</p><p>FileOutputStream</p><p>BufferOutputStream-》  flush 进入才进入文件，当buffer满了也进行了一次flush，flush就是一次性把剩下的刷入到文件中。</p><p>flush写入文件， 在close的时候会自动flush进去</p><p>实现了closeable，重写close方法，可以自动释放</p><p>字符流和字符流，有个readLine() 这是核心区别</p><p>readNewLine</p><p>FilterWriter 是 SinglePerson类，跟FilterOuputStream不一样</p><p>字符有编码格式的，所以字符尽量读的时候用UTF-8来进行读写</p><p>FileWrite  FileReader 只是转换用的</p><p>pipedWriter</p><p>非流操作</p><p>File</p><p>RandomAccessFile 指哪打哪</p><p>setLength 设置文件的长度，设置一个空文件长度</p><p>Seek 只是移动到10000，文件的长度还是0</p><p>协变， out-》 只读的   </p><p>逆变： in是只写的 </p><p>api processor anntation</p><p>类名获取，</p><p>对象去拿</p><p>ClassName</p><p>getDeclareMethod -&gt; 获取当前类的所有方法</p><p>公开方法，静态方法，单例进行找hook点</p><ol><li>hook就是单例，或者 找hook点，然后去代理它  </li></ol><p>通过反射动态代理</p><ol start="2"><li>分析hook点， 动态代理，还是静态代理</li></ol><p>反射做什么呢</p><ol start="3"><li><p>获取到getDefault 的原始对象</p></li><li><p>使用动态代理</p><p> 通过activity，最骚的是当前线程</p><p>classloader， 获取当前线程的</p><p>融入到framework里面</p></li></ol><p>   驱动装载可能会报找不到类异常？？？</p><p>   欺骗ams，的检测，然后替换</p><p>   Window 是什么</p><p>   Window 和 activity 是什么关系</p><p>   Window  windowManager  windowManagerService</p><p>   如何通过WM 添加WIndow</p><p>   Dialog   传入context  ，如果你传入的是appcontext 会报错。</p><p>   悬浮窗口：</p><p>   window分为两个部分，  在应用进程内，wm处理后，然后再交给 wms处理</p><p>   window是个抽象的概念，</p><p>   window所有的view管理，怎么把view添加上去呢，怎么删除viewn呢</p><p>   windowManager来管理这些。</p><p>   PhoneWindow—&gt;是具体window的实现类</p><p>   PhoneWindow由windowManager，进行管理的<br>   ViewManager接口 有  -&gt; 添加view， 更新view， 删除view</p><p>   windowManager，继承了ViewManager，具体实现类 WindowManagerImpl</p><p>   最终 通过 WindowManagerGlobal来进行跟WMS通信</p><p>   DecrView</p><p>   布局参数： type，窗口类型：三种类型的窗口， 应用窗口的，子窗口，系统窗口</p><p>   1-99，  activity，  视图的最下层</p><p>   子窗口， dialog， 1000-1999</p><p>   系统window，如：toast和系统状态栏，  2000-2999 需要权限声明相关的，最上层</p><p>   window的flags，事件穿透</p><p>   window的softInputMode， 控制键盘弹出，其实</p><p>   是系统窗口发生变化了</p><p>   设置window的type，</p><p>   悬浮窗口： </p><p>   1.系统级别的 type， toast，状态栏什么的，用的时候会需要权限</p><p>   校验，android  N 系统窗口，权限验证</p><p>   2.应用级别的</p><p>   addwindow的时候需要权限验证</p><p>   wms是其他服务初始化的 wms是管理窗口的</p><p>   所有的view显示，需要在 DisplayThread.getHandler 进行处理</p><p>   PhoneWindowManager里面进行权限控制</p><p>   类似于相应码</p><p>   设置成type_application 为2的type</p><p>   达到目的，代价最小就好了。</p><p>   显示在activity上面用type_application就可以了</p><p>   system_alert_window 权限写入</p><p>   还要设置flags</p><p>   时间传递有关系</p><p>   FlagNotfocusable， nottouachable</p><p>   gravity 属性</p><p>   添加，更新，移除</p><p>   WM.添加view的过程</p><p>   ActivityStackSupervisor<br>   RealStartActivityLocked</p><p>   ClientTransaction，</p><p>   看代码，查找关键点</p><p>   PhoneWindow</p><p>   换肤公开课，有讲到。</p><p>   子view都准备好了，没有显示</p><p>   LounchActivityItem</p><p>   ResumeActivityItem - &gt; hanlde ResumeActivity</p><p>   global添加，</p><p>   ViewRootImpl view树的根，<br>   测量，布局</p><p>   ， 子线程不能更新ui在ViewRootImpl中判断的</p><p>   ViewRootImpl 跟WMS通信， IWindowSession  addtoDisplay</p><p>   -&gt; Session.java里面去了</p><p>   一个应用只有一个WindowManagerGlobal，</p><p>   子窗口一定要有个token，然后显示</p><p>   最终给 Surface 的服务</p><hr><p>   问老师个问题  三星开放出来的系统权限api  也有静默安装的   那些sdk怎么实现的  是不是也和这个技术有关系</p><p>   CGlib，如果方法是final类型，就没办法代理了</p><p>   Hal层会讲不  不知道这个是什么东西。  hal层，就是硬件抽象层</p><p>   PKms也是跑在System_server进程中的</p><p>   负责android系统中的安装 升级 卸载</p><p>   对外提供统一的信息查询工呢，其中包含匹配某个intent的 activity，broadcast，service</p><p>   pkms，在 引导服务中启动的， 继承IPackageManager.Stub</p><p>   ServiceManager，里面去了</p><p>   SystemServiceRegistry， 所有的service，其他binder，都用注册到ServiceManager中</p><p>   所有binder， 所有的binder都能拿到它，地址为0的地址</p><p>   getIServiceManager()就是获取了binder大管家</p><p>   installPackagerManagerAsUser()</p><p>   SystemServer是系统服务进程，里面启动很多系统service。通过BInder跨进程通信的方式来让app使用这些服务。ServiceManager是sdk提供的各种服务的大管家，通过get方式来拿service</p><p>   SystemServiceManager里面一大把的服务</p><p>   ServiceManager.addService()</p><p>   PowerManagerService<br>   一种继承SystemService</p><p>   添加到ServiceManager.addService() ,相当于window上的注册表</p><p>   真正的是在C++层的。</p><p>   到ServiceManager里面进行注册</p><p>   stub接收器</p><p>   kerner那一块</p><p>   serviceManager大管家</p><p>​    PackageManagerService :  构造方法真1000行代码。</p><p>​    系统启动 会 apk安装的过程，所以手机应用多，速度越慢。</p><p>​    shareUserId   （uid） 打电话的apk，</p><p>​        系统默认安装，设置为android.uid.system， 要求要有系统签名，然后可以静默安装</p><p>​             </p><p>​    PKMS.scanPackageLI() -&gt; manifest文件扫描，存起来    </p><p>​    installPackage  静默安装    </p><p>​    aapt，资源映射表。</p><p>​    MergedManifest</p><p>​    要签名才能进行安装</p><p>​    v1 v2  v3签名的区别</p><p>​    需要android.uid.system</p><p>​    静默安装： rom定制的，需要系统的厂商，可以进行静默安装。</p><p>​    智能安装：就是不用自己点安装，vivo，oppo需要密码</p><p>​         apk打包过程，系统服务注册流程</p><p>​    Dropbox 日志系统。</p><p>​    handler：</p><p>​    跟web开发的ajax有异曲同工之妙</p><p>​    大大降低了开发难度<br>​    几乎看不到多线程死锁问题</p><p>内存共享：</p><p>都是内存共享：<br>handler：核心思想，就是内存共享</p><p>mmap</p><p>final</p><p>static </p><p>一个线程 -》 另一个线程的数据， 线程间最终的通信是内存共享</p><p>Message /messageQueue /message/looper/ThreadLocal</p><p>内存管理设计思想优秀。  为什么没有wait和notify变量 线程通信</p><p>handler包揽所有的线程通信</p><p>最小知识原则：handler，</p><p>最后入队到了messageQueue</p><p>messageQueue.next</p><p>Looper.loop() 是thread调用的。</p><p>Looper.prepare()</p><p>装饰的话，就要装饰共有的接口，叫装饰者设计模式<br>线程里面的单例<br>如何实现线程数据的隔离， 线程的上下文独一无二</p><p>ThreadLocal</p><p>java容器，</p><p>剑指off的java面试题讲解真的不错，bat的面试官讲解</p><p>ThreadLocal 里面用数组来替换了map</p><p>就是 hash[index]  hash[index + 1] </p><p>​    key                 value</p><p>​    hash[index]  hash[index + 1]</p><p>通过静态来进行，确定单一的hash值。整个系统都只有一个hash值</p><p>AtomicInteger</p><p>一一对应的，就可以用ThreadLocal</p><p>gc的时候会有标记整理算法，但是gc得时候会短暂停顿，甚至new的多了，内存扩大，会有内存抖动现象，而且从代码角度，我们一般减少不必要的内存开销</p><p>getParent().requestDisallowInterceptTouchEvent(true);<br>就可以</p><p>dispatchTouchEvent进行事件分发的</p><p>viewGroup里面没有事件消费 onTouchEvent  事件消费</p><p>如果onTouch返回值为true，点击事件就不在执行了</p><p>aessablity是一个虚拟点击，虚拟点击可以使用</p><p>dispatchTouchEvent</p><p>onTouchEvent.</p><p>playSoundEffet()是个发声音的，这个可以进行自己进行修改</p><p>1.安全点击，什么叫不安全点击</p><p>2.</p><p>onTouchEvent</p><p>onClickListener在up里面的点击事件</p><p>onTouch  拦截了，就不会有onClick了，</p><p>ViewPager -&gt; </p><p>onInterceptTouchEvent拦截方法</p><p>Activity# dispatchTouchEvent-&gt;PhoneWindow#</p><p>superDispatchTouchEvent<br>Super.DispatchTouchEvent<br>ViewGroup#DispatchTouchEvent</p><p>在android中，是activity的dispatchTouchEvent方法</p><p>PhoneWindow中进行查找</p><p>VIew#dispatchTouchEvent，指的是处理事件的的dispatch的view去调取</p><p>down事件 :<br>move:<br>up事件:</p><p>buildTouchDispatchChildList()—&gt;对子view排序</p><p>buildTouchDispatchChildList使用了什么排序？？？</p><p>点击的位置的判断</p><p>1.人脸识别算法，举手识别率，前三排</p><p>智慧罗庄：事件，权限，</p><p>安迪网格化-&gt; H5（商城，共享单车）</p><p>硬件测试 需要长时间测试。</p><p>new 方向，</p><p>升降式的摄像头。UV光，个性化。解决问题。</p><p>人脸采集<br>webview封装</p><p>down move   阿斯顿发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;File和Stream&quot;&gt;&lt;a href=&quot;#File和Stream&quot; class=&quot;headerlink&quot; title=&quot;File和Stream&quot;&gt;&lt;/a&gt;File和Stream&lt;/h3&gt;&lt;p&gt;Java io, okio,   apk加
      
    
    </summary>
    
    
      <category term="android" scheme="http://zhousaito.top/categories/android/"/>
    
    
      <category term="android file" scheme="http://zhousaito.top/tags/android-file/"/>
    
  </entry>
  
  <entry>
    <title>activity生命周期与task启动方式</title>
    <link href="http://zhousaito.top/2019/11/11/2019-05-19-activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8Etask%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhousaito.top/2019/11/11/2019-05-19-activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8Etask%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:38.433Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="从四个视角理解android-activity启动模式"><a href="#从四个视角理解android-activity启动模式" class="headerlink" title="从四个视角理解android activity启动模式"></a>从四个视角理解android activity启动模式</h3><p>操作系统角度，Task是什么</p><p>用户的角度</p><p>学东西，要总体来学，要以架构师角度来学东西</p><p>一开始学，都是学习4大组件</p><p>task是可以跨应用的， app是静态的，task的动态的，</p><p>task是属于android操作系统的</p><p>android service有任务栈吗，或者说service怎么存放的</p><p>新建，startActivity</p><p>要从结构上去学习，就会</p><p>静态的fragment和动态的fragment</p><p>如果activity启动不成功，就不会执行上个界面，onstop</p><p>onPause（）不能做耗时操作，影响启动速度</p><p>standard不是每次都100%新建， launch启动的时候，如果已经存在了，就不会再创建了。</p><p>flag = 0x10200000</p><p>每个页面展示不同的数据</p><p>newTask</p><p>affinity 就是新task名字 affinity  要和newtask标志一起使用</p><p>有没有拉起进程的</p><p>管道机制</p><p>bander机制，binder就跟快递小哥一样，</p><p>用户放入到内存空间， copy_from_user 第一次</p><p>然后 copy_to_user</p><p>这是传统的</p><p>binder传输数据：<br>服务端的一个空间，内核空间都是 虚拟空间</p><p>实际操作是物理空间，mmap 内存，内存映射</p><p>就是数据放到内存，然后内存映射，去取，就是一次拷贝</p><p>共享内存是 三个共享化，</p><p>binder两个共享</p><p>c/s架构的，易用性高； 控制复杂</p><p>共享内存，在同一个空间，需要同步机制去处理，同步的开销大 </p><p>同步延迟+内存开销</p><p><strong>mmap 资料</strong>memory mapping</p><p>binder 安全性。   pid，进程的id，依赖上层协议，不安全，<br>相当于造假身份证去干坏事，就是用进程id去欺骗</p><p>访问接入点是开发的，不安全</p><p>为每个app分配UID，同时支持实名和匿名，</p><p><strong>加上bean类，要求导包</strong></p><p>为什么binderservice就能绑定服务，</p><p>客户端如何获取到AIDL的<strong>遥控器</strong>（句柄）的</p><p>通过这个遥控器是如何调到服务端的呢</p><p>服务端又是如何</p><p>每个服务要有一个aidl与之对应</p><p>发送数据proxy 发送数据</p><p> 接收数据  stub 是用来接收数据的</p><p>或aidl对象的方法</p><p>LeoAidl.Stub.asInterface(binder) — 》 就会拿到 proxy的对象</p><p>服务端，一进来就会初始化，new了一个stub</p><p>如果进过判断是因为判断是不是同一个进程</p><p>_data 用来存储发送数据，就是调用方法的出入参数</p><p>_reply //服务端返回的数据</p><p>//就会把客户端线程挂起来，知道服务端返回结果</p><p>mRemote.transact()</p><p>flag 0 -</p><p>Flag 1 -&gt; 客户端给服务端，服务端不能进行返回</p><p>transact后就到binder了   transact 到C里面去了， 可以去查查</p><p>服务端， onTransact方法接收处理</p><p>binder机制，看framework的源码有一定的理解</p><p>c端和 s端是如何捆绑再一起的</p><p>getSystemService</p><p>闹钟服务，通话服务等， 实际上也是跨进程的，</p><p>服务好比房子一样，</p><p>ServiceManager（相当于android中的间接），其实也是进程间的通信</p><p>通过proxy，</p><p>comtextImpl里面</p><p>bindService  - &gt; ContextImpl#bindServiceCommon</p><p>-&gt; ActivityManagerNative.getdDefalut（）-》proxy对象</p><p>ActivityManagerNative就是 == stub</p><p>IActivityManager=  ILeoAidl 接口</p><p>getService() 获取了 IBinder， 然后返回proxy</p><p>我的理解是生成的单独为这个类服务的，所以用内部类，而谷歌的这个是通用的所以单独是个类</p><p>调用的是正在的服务</p><p>调用到了 activityManagerService。java</p><p>调用到真正的服务</p><p>ActivityManagerService#bindServiceLocked</p><p>bringupServiceLocked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestServiceBindingLocked 猜</span><br></pre></td></tr></table></figure><p>1.进程B，整个进程没有启动</p><p>2.进程B启动了，service没有创建出来</p><p>2.启动了，也创建了，未绑定，onBInde</p><p>4.启动了，也创间了，也绑定了，onbinde</p><p>、、app</p><p>ActiveServices.java</p><p>每创建一个进程，都会有个进程，app.thread ，就是activityTHread，</p><p>如果启动了，app.thread肯定不为空</p><p>23的代码</p><p>ActivityThread的</p><p>handleCreateService， 通过反射， 创建了服务</p><p>binder只能绑定一次，创建一次，如果找到了，可以直接使用，</p><p>app没有创建</p><p>startProcesslocked</p><p>process.create</p><p>android是个消息驱动的系统</p><p>handleCreateService</p><p>handleBindService</p><p>课后自己手写，实现aidl</p><p>a 调用系统服务</p><p>ActivityManagerNative  -&gt;  stub  - &gt; ontrnsact</p><p>ActivityManagerProxy -&gt; proxy -&gt; trnsact</p><p>ActivityManagerSerivce-&gt;   stub的实现类</p><p>IActivityManager -&gt; AIDL接口</p><p>大型登录架构实现</p><p>支付宝纳入海量应用</p><p>四大主键，和activity启动流程，都是用了binder机制</p><p>3358434706</p><p>Clinet : 通过 asInterface()-&gt; proxy对象, -&gt; proxy# transact() -&gt; 进行传递，到服务端的  onTransact上-&gt; 因为stub是个抽象方法，被服务端的binder实现了，所以最后调用，服务端的binder实现aidl接口的方法-&gt;最后沿路返回</p><p>因为，两边的接口都是一模一样的，所以调取的时候传 个 1，2…n作为方法的标识</p><p>app每创建一个进程，都会启动一个 activityThread吗。怎么去验证一下。</p><p>activityManagerService:</p><p>android 7.0：</p><p>基于liunx内核开发的，</p><p>看两本liunx的相关书籍， liunx内核设计与实现， 深入理解liunx</p><p>进程管理，进程调度， io流操作， epoll， 底层读写靠的是这个</p><p>Init.rc<br>用户空间和内核空间</p><p>之间通信靠系统调用，创建android的进程鼻祖，zygote</p><p>然后拉起SystemServer，</p><p>加载系统预加载的类，加载服务</p><p>ams属于引导服务，然后其他服务。launch服务，启动</p><p>引导服务，</p><p>核心服务，</p><p>​    然后里面启动了ams -&gt; launcher启动</p><p>其他服务</p><p>整体概念讲</p><p>​    </p><p>rpc，rmi，socket和管道</p><p>ipc， socket， 管道， 型号量，binder， 共享内存</p><p>binder驱动，在内核内存中，通过binder，然后传到另外一个进程</p><p>SystemtServer里面有个binder列表<br>SystemtServer的binder地址是固定的，然后拿着这个binder，跟其他binder<br>进行通信<br>0号驱动，</p><p>serviceManager存放地址，<br>类似于 dns 或 路由表一样的东西，找到serviceManager就能找到所需要的binder</p><p>asInterface 判断是否在同一个进程， 同进程不走binder了</p><p>生成的代码，像动态代理</p><p>客户端不能直接访问对象，所以需要代理，</p><p>然后都实现共同的接口</p><p>android aidl的原理</p><p>android 为什么要使用binder，</p><p>稳定性，C/S模式，客户端挂了，不影响服务端。</p><p> 安全考虑：传统的传统的不可靠， binder会调用进程，容易被中间者攻击</p><p>系统启动的时候，注册了各种，serviceManager，</p><p>通过binder驱动，然后服务端，ontrancsact，</p><p>LocalSocket,改变进程id等，zygote，复制了一个分身</p><p>launch启动应用，</p><p>ams  socket与zygote进程通信， 然后zygote创建ActivityThread</p><p>activity启动</p><p>状态设计模式</p><p>AMS家族</p><p> xx record</p><p>android进程模型与优先级</p><p>可见进程（对话框弹窗），服务进程（后台进行播放，音乐播放），后台进程（stop状态了），空进程（加快下次创建数据）</p><p>startActivity的时序图</p><p>hook插件话</p><p>Instra ActivityThread， AMS</p><p>hook Activity 的启动 </p><p>未注册的activity，<br>Activity的</p><p>ActivityThread</p><p>AMS的</p><p>applicationThread对象，什么时候被创建的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;从四个视角理解android-activity启动模式&quot;&gt;&lt;a href=&quot;#从四个视角理解android-activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;从四个视角理解android activity启动
      
    
    </summary>
    
    
      <category term="android" scheme="http://zhousaito.top/categories/android/"/>
    
    
      <category term="android file" scheme="http://zhousaito.top/tags/android-file/"/>
    
  </entry>
  
  <entry>
    <title>broadcoast发送与接收</title>
    <link href="http://zhousaito.top/2019/11/11/2019-05-26-BroadcastReceiver%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://zhousaito.top/2019/11/11/2019-05-26-BroadcastReceiver%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2019-11-11T05:40:29.457Z</published>
    <updated>2019-11-14T00:13:52.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3></li></ul><p>上一节已经讲过了启动的过程，其中<strong>第三小步1.1</strong>里面的2.x系列将了发送回来的过程，这篇文章会继续加上。</p><h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AsyncTask.THREAD_POOL_EXECUTOR.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">                <span class="comment">//子线程发出一个带有这个信号的intent</span></span><br><span class="line">                intent.setAction(Constant.MY_BROADCAST_ACTION);</span><br><span class="line">                intent.putExtra(<span class="string">"mydata"</span>, <span class="string">"你好"</span>);</span><br><span class="line">                sendBroadcast(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>特意在子线程中发出，其实都一样，消息接收的时候，会回到主线，因此，在BroadcastReceiver中的onReceive尽量不要做耗时操作。</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContextWrapper#sendBroadcast()  --&gt; ContextImpl#sendBroadcast()</span><br><span class="line">    然后在ContextImpl的sendBroadcast中调用了ActivityManager.getService().broadcastIntent(...)</span><br><span class="line">    <span class="comment">//实际上这个就是AIDL的IActivityManager的一个proxy对象调用的broadcastIntent方法</span></span><br></pre></td></tr></table></figure><p>最终就是把 Intent 中的action找 AMS 要对应的broadcast的action去发送</p><h4 id="step-3-ActivityManagerService-broadcastIntent"><a href="#step-3-ActivityManagerService-broadcastIntent" class="headerlink" title="step 3 ActivityManagerService#broadcastIntent"></a>step 3 ActivityManagerService#broadcastIntent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            intent = verifyBroadcastLocked(intent);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            <span class="comment">// 1.</span></span><br><span class="line">            <span class="keyword">int</span> res = broadcastIntentLocked(callerApp, callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>, intent, resolvedType, resultTo, resultCode, resultData, resultExtras,requiredPermissions, appOp, bOptions, serialized, sticky,callingPid, callingUid, userId);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>broadcastIntent 最后调用了broadcastIntentLocked</p><h4 id="step-4-ActivityManagerService-broadcastIntentLocked"><a href="#step-4-ActivityManagerService-broadcastIntentLocked" class="headerlink" title="step 4 ActivityManagerService#broadcastIntentLocked"></a>step 4 ActivityManagerService#broadcastIntentLocked</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;content&lt;br&gt;{:toc}&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一节已经讲过了启动的过程，其中&lt;strong&gt;第三小步1.1&lt;
      
    
    </summary>
    
    
      <category term="broadcoast" scheme="http://zhousaito.top/categories/broadcoast/"/>
    
    
      <category term="android java 进阶" scheme="http://zhousaito.top/tags/android-java-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>jvm原理</title>
    <link href="http://zhousaito.top/2019/11/11/2019-04-14-jvm2/"/>
    <id>http://zhousaito.top/2019/11/11/2019-04-14-jvm2/</id>
    <published>2019-11-11T05:40:29.456Z</published>
    <updated>2019-11-14T00:12:30.221Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h4><p>以太坊，区块链1.0版本 比特币是1.0  以太坊2.0 -EVM</p><p>jvm就是对字节码的翻译</p><p><strong>虚拟机的发展</strong>  go语言写jvm非常的简单</p><blockquote><p>hotSpot VM<br> 目前最广的java虚拟机</p><p>JRockit VM<br> 号称最快的java虚拟机</p><p>J9 VM  ibm公司的</p><p>Dalvik VM </p></blockquote><p><strong>未来java技术</strong></p><blockquote><p>模块化， GFGI 模块化，微服务</p><p>混合语言（java，Scala） </p><p>多核并行（函数式编程） </p><p> 丰富语法   </p><p> 64位 </p><p> 更强的垃圾回收 回收gb级的 jdk11可以是tb级别</p></blockquote><p>所有的东西都是放内存的  内存的划分，</p><p><strong>程序计数器</strong>：指向当前线程的字节码，线程间切换来切换去<br>FILO  first in last out</p><p>非常符合java间的方法调用</p><p>虚拟机栈 -Xss 里面有栈帧<br>javap</p><p><strong>局部变量表</strong>，只能放32位的数据，局部变量表， this，money</p><p>​    持有引用，</p><p><strong>操作数栈</strong> ，<br>出栈进行相减<br>count++， dup - idd 总共4不<br>操作的入栈，</p><p><strong>返回地址</strong>return，正常执行</p><p>异常会在一个叫 异常处理器表 处理</p><p>多态的的话，就要使用<strong>动态连接</strong>， java动态运行性，</p><p>局部变量表一个引用</p><p>​    native栈 hotspot吧本地方法栈和虚拟机栈合二为一的</p><p>​    加了入参，可能有点影响</p><p>​    </p><p>为什么jvm要用栈，因为：非常符合java间的方法调用</p><p>指令 + 数据， </p><p>虚拟机栈帧，<strong>默认是1m</strong>， 可以进行修改</p><p><strong>方法区</strong>： 类信息，常量，静态变量，即时编译器编译后的代码</p><p>java堆： <strong>对象的实例（几乎所有）</strong>    <strong>数组</strong></p><p>​    -xmx 最大<br>​    -xms 最小</p><p>直接内存： nio会使用</p><p>​    不超过，内存调用<br>​    每个线程归属于单个线程，栈</p><p>堆内存是对所有线程可见的</p><p>空间大小：并发可以跑一个100个线程，就100m</p><p>java虚拟机中的对象</p><p>分配内存</p><blockquote><p>指针碰撞 和 空闲列表<br>规整用指针碰撞，不规整用空闲列表</p><p>如果相同地址时：要使用cas锁</p><p>cas锁：比较和交换  乐观锁</p><p>cas操作带来的ABA</p><p>ABA 问题   中间状态，被用了，不管， 只要管再次分配的时候 b这个状态不管</p></blockquote><p>char的初始值  \u0000 ？？？</p><p>对象初始化、</p><p>设置是那些类的， 然后对象初始化</p><p><strong>对象内存的布局</strong></p><blockquote><p>对齐填充<br>对象头：线程 垃圾回收也有点关系</p><p>。。。</p></blockquote><p>对象的访问定位</p><p>​    句柄方式访问对象<br>​    直接指针访问对象</p><p><strong>虚拟机优化技术 — 逃逸分析</strong></p><p>有对象可以在<strong>栈上分配</strong>的，<strong>几乎所有</strong>对象在栈上分配</p><p>hotSpot 默认有<strong>逃逸分析</strong></p><p>本地线程缓冲区<br>如果有逃逸分析，对象可能会在<strong>栈上分配</strong>，这是虚拟机的优化的技术<br><strong>本身这个对象，没有在其他地方使用，所以就直接在栈上分配了</strong> </p><p>逃逸分析使用了可见性？？？，其他的线程也是可见的</p><p><strong>热点跟踪</strong>，使用频繁就会保存起来</p><p>静态方法是也在栈帧里面吗？？？？？</p><p> 逃逸分析为什么快？？？？</p><p>异常处理表？？？ 出现异常了，异常处理表</p><p>oom 和栈溢出区别<br>混合模式，</p><p><strong>直接内存，</strong>元空间（直接内存） 直接内存会挤压堆， 2面性</p><p>一个进程只能开启一个虚拟机吗</p><p>静态属性和静态方法 ,</p><p>当不持有引用的时候可以使用静态方法</p><p><a href="https://www.jianshu.com/p/3ecc626ce304" target="_blank" rel="noopener">逃逸分析和栈上分配</a></p><p><a href="https://blog.csdn.net/chunyuan314/article/details/73266700" target="_blank" rel="noopener">静态属性和静态方法</a></p><p><a href="https://blog.csdn.net/paopaoandguoer/article/details/76206586" target="_blank" rel="noopener">内存溢出OOM和内存泄露memory leak 小结</a></p><p><a href="https://www.cnblogs.com/javaadu/p/10703970.html" target="_blank" rel="noopener">需求管理做不好，等着9-12-7吧</a></p><p><a href="https://www.jianshu.com/p/8de8c6a839e8" target="_blank" rel="noopener">CAS中的ABA问题解决方案</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/6490953.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/zhengbin/p/6490953.html" target="_blank" rel="noopener">深入分析对象的内存布局</a></a><br><a href="https://blog.csdn.net/championhengyi/article/details/78760590" target="_blank" rel="noopener">JVM–详解虚拟机字节码执行引擎之静态链接、动态链接与分派</a></p><h5 id="2019-04-16-jvm"><a href="#2019-04-16-jvm" class="headerlink" title="2019-04-16 jvm"></a>2019-04-16 jvm</h5><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>深入理解垃圾回收器<br>1.jvm垃圾回收及案例分析</p><ul><li>学习垃圾回收的意义，</li><li>java与C++之间的区别：</li></ul><p>GC </p><ul><li>谁需要垃圾回收</li></ul><p>栈=不需要，凡是共享的对象</p><p>堆-重点， 方法区，元空间（也有）</p><ul><li>GC要做的事</li><li>为什么我们要去了解GC和内存分配？</li></ul><p>堆里面继续划分</p><blockquote><p>eden</p><p>from  Survivor</p><p>To Survivor</p><p>ODEGEn  , 堆 -xmn</p></blockquote><p>回收效率低，就抛出了oom GC overhead limit exceeded</p><p>交换区 是 1：1的比列<br>两个交换区始终占两份，所以，当eden为2时， 就是 2：1：1</p><p>-XX：SurvivorRatio =8 </p><p>引用计数：JVM早期使用</p><p>A == &gt; B   （1）</p><p>C ==&gt; B  （1+1）=2</p><p>取消引用 -1 引用+1</p><p>缺点，<br>相互引用<br>A ==》 B  同时 b ==》 a 很难判断是不是该回收 （PHP在使用）</p><p>可达性算法（java）<br>GC Roots 是因为多加了个 s</p><p>1.方法区：类静态属性的对象</p><p>2.方法区：常量</p><p>3.虚拟机栈（本地变量表）中的对象  （方法没完）</p><p> 本地栈jni对象</p><p>只要方法没跳出来，就是gc roots</p><p>new 出来的都是强引用</p><p><strong>软引用</strong>：softreference   当系统要oom了，就会去回收<br>–图片使用内存，然后要oom要释放了</p><p>System.gc主动回收 //gc会消耗性能</p><p>-XX：+printGCDetails</p><p><strong>弱引用</strong>：</p><p>弱引用只要垃圾回收，就会被回收</p><p>weakHashMap<br>ThreadLocal 线程隔离</p><p><strong>虚引用</strong>：PhantomReference 用得非常少 jvm层开发容易用到，回收了会告诉你我要回收了，回收会通知你一下</p><p>新生代：</p><p><strong>复制回收算法</strong>，每次只能用一半</p><ul><li><p>利用率只有一半，</p></li><li><p>实现简单，运行高效</p></li><li><p>内存复制，没有内存碎片</p></li></ul><p>90%的对象不需要进行主动回收，10%   8：1：1<br>很多对象不用去主动回收，使用完了，就释放了</p><p> <strong>8：1：1？？？？？理解</strong></p><p>是取eden里面的对象，是通过对象在serviver区间的移动</p><p>90%对象会被回收，10%不回收，所以复制只有10%</p><p><strong>空间担保：放不下了怎么办</strong></p><p><strong>标记-清除算法</strong>，会产生内存碎片</p><p><strong>标记-整理算法</strong>，内存移动，一定会涉及到效率问题 效率一般般</p><p>minor GC   FUllGc<br>1m只是数据，所有大约占据1.5m空间，对象头和填充</p><p>新生代会带一些头的信息所以大一些<br><strong>新生代为什么会大一点？？？？</strong></p><p><strong>老年区实际大小差不多？？？</strong></p><p><strong>GC的时候才会去交互区吗</strong></p><p>eden存新创建的对象<br>eden经过回收，就去交换区</p><p>eden快满了，就触发GC，然后就交换区间复制</p><p>堆内存的分配策略：</p><ol><li>对象优先在Eden分配  一开始这个区分配</li><li>大对象直接进入老年代 （eden区放不下，就相当于大对象）</li><li>长期存活的对象进入老年代</li><li>动态年龄判断判断</li><li>空间担保</li></ol><p>gc触发条件，就是空间不够了</p><p>分带收集：</p><p>Serial 单线程</p><p>cms 老年代，标记清除算法， （效率很好，空间碎片严重，主流移动互联网用的多）</p><p>GC的时候，出来GC线程，会把所有的线程暂停</p><p>CMS垃圾回收器工作示意图</p><p><strong>cms</strong>给予并行收集与并发收集的<br>并发标记，和用户线程一起进行的</p><p>COncMarkSweep</p><p>怎么设置自己的项目使用哪个收集器。</p><p>初始标记 — 暂停</p><p>并发标记 — 同时进行</p><p>重新标记 — 暂停</p><p>并发清除 — 同时进行</p><p><strong>有浮动垃圾</strong></p><p><strong>jps -v 看垃圾回收命令</strong></p><p>G1垃圾回收器是 1.7提出来的， 可预测性停顿<br>标记整理 + 化整为零</p><p>垃圾回收，都有个内存停顿</p><p>吞吐量  =  cpu时间 100%    gC 10%  业务线程90%   业务线程/总的时间</p><p>内存不够了，垃圾回收不成功了，所以就oom了</p><p>需要的分配空间不够了， </p><p>gc回收不了了，还有对象要进来</p><p>内存泄漏，<br>MAT  GC ROOT 引用的线程是否在频繁调用，    monitor  </p><p>Leakcanary， 代码可以追踪内存</p><p>空间不够了，就触发GC</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;java虚拟机&quot;&gt;&lt;a href=&quot;#java虚拟机&quot; class=&quot;headerlink&quot; title=&quot;java虚拟机&quot;&gt;&lt;/a&gt;java虚拟机&lt;/h4&gt;&lt;p&gt;以太坊，区块链1.0版本 比特币是1.0  以太坊2.0 -EVM&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://zhousaito.top/categories/JVM/"/>
    
    
      <category term="android java jvm" scheme="http://zhousaito.top/tags/android-java-jvm/"/>
    
  </entry>
  
</feed>
