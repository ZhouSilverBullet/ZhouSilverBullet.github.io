{"meta":{"title":"周周博客","subtitle":"很高兴能帮到你","description":"一名Android开发者","author":"Zhou Saito","url":"http://zhousaito.top","root":"/"},"pages":[{"title":"About","date":"2019-11-13T04:54:47.715Z","updated":"2019-11-13T04:54:39.270Z","comments":true,"path":"/about/index.html","permalink":"http://zhousaito.top/about/index.html","excerpt":"","text":"关于我 先后就职过草花互动,然后在深圳呆过一阵子,最后到了朋友的公司旭兴科技工作。 主要兴趣是进行android的应用开发。android动画，嵌套滑动，滑动冲突解决等一些问题解决，有时通过自定义view来进行不满足现有的需求。通过自己去解决这些问题后，感到非常的有成就感。 热爱美好的事物，喜欢看一些技术类的书籍，如技术类：《android设计模式》《android系统源码情景分析》《android开发艺术探索》 非技术类：《三国演义》《水浒传》《基督山伯爵》等 旅游方面：去年去爬过泰山，看泰山的日出。在北京呆着，然后去过故宫，天安门，八达岭长城，圆明园，鸟巢和水立方等，差不多应该是这些地方。 很喜欢李白将敬酒中说的：天生我材必有用，千金散尽还复来。 还有，学习是一个非常愉快的过程。共同加油！ 2018.5.1入职旭兴科技 2018.4.26 离职于草花互动 2016.11.11 入职草花互动技术部 2017.6 毕业于湖南科技学院 联系我 GitHub：ZhouSilverBullet email：zhousaito@163.com 知乎"},{"title":"Categories","date":"2019-06-09T16:31:38.000Z","updated":"2019-11-13T06:08:46.230Z","comments":true,"path":"categories/index.html","permalink":"http://zhousaito.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-09T16:39:17.000Z","updated":"2019-11-10T15:47:04.000Z","comments":true,"path":"tags/index.html","permalink":"http://zhousaito.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-09T16:39:17.000Z","updated":"2019-11-10T15:47:04.000Z","comments":true,"path":"links/index.html","permalink":"http://zhousaito.top/links/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-13T05:10:36.312Z","updated":"2019-11-10T15:47:04.000Z","comments":true,"path":"images/html2canvas.min.js","permalink":"http://zhousaito.top/images/html2canvas.min.js","excerpt":"","text":"/*! * html2canvas 1.0.0-rc.5 * Copyright (c) 2019 Niklas von Hertzen * Released under MIT License */ !function(A,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(A=A||self).html2canvas=e()}(this,function(){\"use strict\"; /*! ***************************************************************************** Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. See the Apache Version 2.0 License for specific language governing permissions and limitations under the License. ***************************************************************************** */var r=function(A,e){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(A,e){A.__proto__=e}||function(A,e){for(var t in e)e.hasOwnProperty(t)&&(A[t]=e[t])})(A,e)};function A(A,e){function t(){this.constructor=A}r(A,e),A.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}var K=function(){return(K=Object.assign||function(A){for(var e,t=1,r=arguments.length;t"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-11-13T01:07:32.832Z","updated":"2019-11-13T01:07:32.832Z","comments":true,"path":"2019/11/13/hello-world/","link":"","permalink":"http://zhousaito.top/2019/11/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"自己的域名绑定github博客","slug":"2019-11-11-自己的域名绑定github","date":"2019-11-11T05:52:57.099Z","updated":"2019-12-07T02:18:03.067Z","comments":true,"path":"2019/11/11/2019-11-11-自己的域名绑定github/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-11-11-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9Agithub/","excerpt":"","text":"[toc] 开始第一步先有自己的域名，然后才有后续的操作 如：zhousaito.top 第二步 找到自己博客的位置，然后在根路径下添加 CNAME这个文件 然后到自己的 xx.github.io 的位置上进入的settings 第三步 去买域名的地方去加两个解析，解析自己的 xx.github.io 地址的ip 3.1 确定xx.github.io的ip地址 ping www.ZhouSilverBullet.github.io 图上的185.199.108.153 就是对于的ip了 3.2 去买域名的地方绑定解析","categories":[{"name":"博客搭建指南","slug":"博客搭建指南","permalink":"http://zhousaito.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"个人博客搭建","slug":"个人博客搭建","permalink":"http://zhousaito.top/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"author":"Zhousaito"},{"title":"2019-07-11-想到学的","slug":"2019-07-11-想到学的","date":"2019-11-11T05:40:29.459Z","updated":"2019-11-11T05:40:29.459Z","comments":true,"path":"2019/11/11/2019-07-11-想到学的/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-07-11-%E6%83%B3%E5%88%B0%E5%AD%A6%E7%9A%84/","excerpt":"","text":"webview的优化 https://juejin.im/post/5d2605f8f265da1bc23fa07c?utm_source=gold_browser_extension javaweb简单的知识 Vue idea 添加 VUE 的语法支持和开发 https://blog.csdn.net/sl1990129/article/details/83794024 getter 获取值 Setter 比较赋值了，监视当前属性值的变化 回调函数满足的三个条件：1.你定义的 2.你没有调用 3.但最终它执行了 双向管理 虚拟dom class和style绑定 “ ‘a’ “ 相当于写死了 “a” 这个a是个变量 123456789&lt;!-- 动态确定类名 --&gt;&lt;p :class=&quot;&#123;aClass: isA, bClass: isB&#125;&quot;&gt; xxx是个对象&lt;/p&gt;&lt;!-- style来确定 --&gt;&lt;p :style=&quot;&#123;color: firstColor, fontSize: fontSize +&apos;px&apos;&#125;&quot;&gt; style来进行绑定&lt;/p&gt; 条件渲染 12345678&lt;!-- v-if的隐藏会移除 --&gt;&lt;p v-if=&quot;ok&quot;&gt; 成功了！！！&lt;/p&gt;&lt;p v-else&gt; 失败了！！！&lt;/p&gt;&lt;!-- v-show的隐藏只是应酬，标签其实还在内存里面 --&gt;&lt;p v-show=&quot;ok&quot;&gt;你好&lt;/p&gt;&lt;p v-show=&quot;!ok&quot;&gt;不好好&lt;/p&gt;&lt;button @click=&quot;&#123;ok=!ok&#125;&quot;&gt;切换&lt;/button&gt; v-for 12345678910111213141516171819202122// vue只是监听本身，如果数组没有改变本身，只是里面的值改变，这个时候是不会刷新的//方法如果是个关键字，可能不生效，直接就报错了delete-&gt;是个关键字，所以不能行//&lt;!-- 遍历数组--&gt; &lt;ul&gt; &lt;li v-for=&quot;(p, index) in persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;----&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125; --- &lt;button @click=&quot;deleteP(index)&quot;&gt;删除&lt;/button&gt; --- &lt;button @click=&quot;addP(index, &#123;name:&apos;xxx&apos;, age:28&#125;,)&quot;&gt;添加&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 遍历对象--&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in persons[1] &quot; :key=&quot;key&quot;&gt; &#123;&#123;value&#125;&#125; -- &#123;&#123;key&#125;&#125; &lt;/li&gt; &lt;/ul&gt; 列表的收缩过滤和排序 12345678910111213141516171819filterPerson() &#123; //取出相关的数据 const &#123;persons, searchName, orderType&#125; = this; let fPersons; fPersons = persons.filter(p =&gt; p.name.indexOf(searchName) !== -1); if (orderType != 0) &#123; //原本的顺序不进行排序处理 fPersons.sort(function (p1, p2) &#123; //如果返回-1 p1在前 返回正数 p2在前 if (orderType == 2) &#123; return p2.age - p1.age; &#125; else &#123; return p1.age - p2.age; &#125; &#125;); &#125; //对person进行过滤 return fPersons;&#125; 绑定监听 12345678910111213//默认的情况下test1方法相当于 test1($event) 默认传递了event//如果需要自己传值的话test1(&apos;你好&apos;, $event) 最好自己传一个$event,不然就没有默认传递$event对象了&lt;button @click=&quot;test1&quot;&gt;test1&lt;/button&gt; &lt;button @click=&quot;test2(&apos;你好&apos;, $event)&quot;&gt;test2&lt;/button&gt; data: &#123; test1() &#123; alert(&quot;assdfa&quot;); &#125;, test2(msg, event) &#123; alert(msg+&quot;---&quot; + event.target.innerHTML) &#125; &#125; js event 停止事件冒泡 1234567@click.stop=&quot;test6(&apos;inner&apos;)&quot;&lt;div @click=&quot;test4(&apos;outter&apos;)&quot; style=&quot;background: blue; width:200px; height: 200px&quot;&gt; &lt;div @click.stop=&quot;test6(&apos;inner&apos;)&quot; style=&quot;background: red; width:100px; height: 100px&quot;&gt; &lt;/div&gt; &lt;/div&gt; 阻止事件的行为 1234&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;test6(&apos;prevent&apos;)&quot;&gt;百度&lt;/a&gt;&lt;h2&gt;按键修饰符&lt;/h2&gt;&lt;input type=&quot;text&quot; @keyup.enter=&quot;test7&quot;&gt; 表单数据的自动收集 生命周期函数（钩子函数）： 初始化显示 更新 死亡 mounted 挂载 1234//匿名函数，函数作为参数的时候setInterval(() =&gt; &#123; this.isShow = !this.isShow&#125;, 1000) el去进行配置，也可以动态的配置 el 生命周期 在内存中挂载好后，然后再进行页面更新 created beforeMount mounted beforeUpdated updated beforeDestroy destroy destroy后页面还在，只是vue不管事情了，比如清除定时器 12 mounted() ajax请求，启动定时器，等异步任务*beforeDestroy : 做收尾工作，清除定时器 https://www.bootcdn.cn/ https://momentjs.com/ 过滤器 1234567891011121314151617 &lt;p&gt;完整版: &#123;&#123;date | dateFormat(&apos;YYYY年MM月DD日 HH:mm:ss&apos;)&#125;&#125;&lt;/p&gt;//定义过滤器 函数对象Vue.filter(&apos;dateFormat&apos;, function (value, formate) &#123; // return moment(value).format(&quot;YYYY年MM月DD日 HH:mm:ss&quot;) return moment(value).format(formate || &quot;HH:mm:ss&quot;) &#125;);或者用在参数上这样使用 Vue.filter(&apos;dateFormat&apos;, function (value, formate=&quot;HH:mm:ss&quot;) &#123; // return moment(value).format(&quot;YYYY年MM月DD日 HH:mm:ss&quot;) return moment(value).format(formate) &#125; ); 常用的内置指令v-cloak 指令的好处 1234567[v-cloak] &#123; display: none;&#125; &lt;p v-cloak&gt;&#123;&#123;date&#125;&#125;&lt;/p&gt; 这样一开始就不会显示&#123;&#123;date&#125;&#125;了 vue开发插件 123456789101112131415&lt;!--引入插件--&gt;&lt;script src=&quot;./vue-myplugin.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //声明使用插件 Vue.use(MyPlugin) //插件安装上 const vm = new Vue(&#123; el: &quot;#example&quot;, data: &#123; msg: &apos;NBA I Love this Game&apos; &#125; &#125;)&lt;/script&gt; Vue cli安装 项目名不能用大写 vue init webpack vue_demo Dev.env.js 开发环境 prod.env.js 生产环境 什么是组件：component：局部的功能界面，相关的资源是它的组成部分， html，css，js 页面三要素 Jsx =&gt; js + xml 打包 npm run build Npm intall -g serve serve dist 然后把dist改成和 webpack_prod #ouput 加入这个 publicPath :”/demo” 123*.js*.vue 都是组件化编码，组件开发 静态组件 1.拆分组件 2.静态组件（没有交互）3.动态组件 (初始化状态，可以操作) 12&lt;!-- 引入CSS样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./static/css/bootstrap.css&quot;&gt; 1&lt;template&gt; 标签里面要先写个div 组件间通信 props 定义好后，都可以this访问 12345&gt;:comment=&quot;comment&quot; 在组件标签里面写这个&gt;props:[&apos;comment&apos;], //这个只进行了属性名的指定&gt;// props: &#123; 这个是第二种实现&gt;// comment :Object&gt;// &#125;, 12//数据在哪个组件，更新数据的行为（方法）就应该在哪个组件//this.comments.unshift(comment) 放到最前面 type:Founction 1234var comment = &#123; name: this.name, content: this.content&#125; js的等于 是 === 三个等于好 !== 是也是两个 npm info pubsub-js PubSub 组件间通信 slot slot可以传标签，传什么标签就显示什么标签 一开始通过站位，先把位置占好，然后传递标签进去，不传就没有，传就显示传的 存储 localStorage window.localStorage.getItem() 得到的是文本，是个字符串 Json.parse(window.localStorage.getItem() || ‘[]’) 123456789watch: &#123; arrays: &#123; deep:true, //深度监视 handler: function(value) &#123; //json数据存储在LocalStorage window.localStorage.setItem(&apos;todos_key&apos;, JSON.stringify(value)) &#125; &#125;&#125; 自定义绑定监听 123456addTodo@addTodo=&apos;addTodo&apos;//触发事件this.$emit(&apos;addTodo&apos;, data) 获取组件对象 1234&lt;TodoHeader ref=&quot;header&quot;/&gt;this.$refs.header PubSub PubSub.subscribe(‘search’, (msg, searchName) =&gt; { ​ const url = https://api.github.com/search/users?q=${searchName}; }) 数组的 map 方法 123items.map(item =&gt; (&#123; url: item.html_url&#125;)) UI库学习 饿了么： mint UI Elment 这两个都是饿了么开源的库 npm install –save mint-ui Import {Button} from ‘mint-ui’ Vue.componet(Button.name, Button) 路由(vue_05) 路由就是一种映射关系 处理请求的回调函数 前台路由，组件 路径和组件名 路由组件 123&lt;router-link to=&quot;/xx&quot;&gt;当前路由组件&lt;router-view&gt; 路由组件和非路由组件 views/pages 包名 优化路由配置 嵌套路由 path最左侧的 / 是 根路径 12345678910111213&#123; path: '/home', component: Home, children: [ &#123; path: '/message', component: Message &#125;, &#123; path: '/news', component: News &#125; ]&#125; 正常情况下，路由切换后，被切换的路由会死亡，下次进来的时候，会重新创建 如果要保存起来 说是缓存路由组件实际上 缓存的是 组件的对象 123&lt;keep-alive&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 实时性比较高，就不能使用缓存来进行 :id 进行占位 query 是？后面的参数 params，就是路径上的 变参数 &#39; ‘ 空串和 undefined 没什么区别，都不会在界面显示 进行查找 方法返回东西，返回值 this.$route.params.id * 1 如果是文本的情况下 allMessageDetails.find(detail =&gt; detail.id === this.$route.params.id) 12345watch: &#123; //监听路由路径发生改版，就是param 发送变化 $route: function(value) &#123; &#125;&#125; 问题：打包的过程 界面适配 :id 这种是变量，就是js变量，就会去获取js变量，进行传值了 msg=”aaa” 直接写就是，把msg作为变量传递过去 跳转页面 window.location = url，可以进行跳转 路由如何实现的， hash，通过改变hash值来进行的，浏览器可以监视这个路由变化，所以我们可以拿到这个变化，可以得到路径进行，匹配显示就可以了。 getState setState push replace 基本实现原理 https://github.com/DMQ/mvvm 函数中的this只有在执行的时候被确定。this是一直变化的 节点：document element attr text 数据代理 通过对象代理对另一个对象中属性的操作 //数据代理 Object.definProperty() ![image-20190715175528462](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190715175528462.png) 模板解析 模板，html嵌套js代码。(指令属性，表达式) 12//引入js的时候需要先引入，然后再使用&lt;script src=&quot;../js/compile.js&quot;&gt;&lt;/script&gt; js的可以通过 updater[‘aaa’] 可以去方法名 也可以去对象 this.$vm = vm 就变成了内部的对象了 Updater &amp;&amp; updaterFn() 1 数据绑定 123//回调函数什么时候调用//回调函数做了些什么事情//回调函数的this是谁 Dep 初始化的给data的属性进行数据劫持时创建 个数？与data中的属性一一对应关系 dep的结构？ ​ id：标识 ​ subs：[] n个相关的watcher的容器 Watcher ​ 它的实例什么时候创建？ ​ 初始化的解析 大括号表达式/一般指令时创建 ​ 个数？ ​ 与模板中的表达式(不包含事件指令[事件指令在methods里面调用了，不用进行数据绑定]) ​ 12345this.cb = cb; //用于更新界面的回调this.vm = vm; // vmthis.expOrFn = expOrFn; //对应的表达式this.depIds = &#123;&#125;; //相关的n个dep的容器对象this.value = this.get(); //当前表达式对应的value (改的时候加判断) Dep和watcher的关系 ( 1对多，多对多，多对一) 什么关系？ ​ 多对多的关系 ​ data属性—》 Dep —》 n个watcher {{name}} / v-text=”name” 多写几次就是多个watcher了 属性在模板中多次被使用 ​ 表达式—》 watcher —》 n个Dep() ​ 一个表达式永远是对应一个watcher a.b 的时候，就2个dep了 多层表达式，就多个Dep()了 多个表达式使用了此属性。 n个Dep(多层表达式：a.b.c) 如何建立的？ dep和watcher创建的先后。 dep先 watcher在后面 data中属性的get()中建立 什么时候建立？ ​ 初始化的解析模块中的表达式创建watcher对象时 取属性值的时候，get方法会被调用 双向绑定，就是双向赋值，dep持有watcher ，watcher持有dep 一个表达式对应一个watcher 同一个属性对应同一个Dep 初始化的时候建立了关系 vm.name = ‘abc’ —&gt; data中的name属性变化 —》 name中的set()调用 —》 dep.notify() —&gt; wather. update() 并不是观察的对象本身，观察的是对象中的属性。 observer进行数据劫持 双向绑定 dom事件监听 12345678910//计算的computed: &#123; eventOrAdd () &#123; if (this.count % 2 === 0) &#123; return &apos;偶数&apos; &#125; else &#123; return &apos;奇数&apos; &#125; &#125;&#125;, vuex的库 vuex是vue的一个插件 vue应用中多个组件的共享状态进行集中式管理(读/写) state -&gt;data 驱动应用的数据源 view -&gt; 界面 声明的方式将state映射到视图 ​ 初始化显示 ​ 更新显示 actions是行为，就是更新状态的函数 ​ 包含n个更新数据状态的方法 单向数据流 ![image-20190716163430568](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190716163430568.png) 多组件共享状态问题 多个视图依赖于同一状态 来自不同视图的行为需要变更同一个状态 原来的解决 将数据操作行为定义在父组件 将数据以及操作数据传递到各个组件 vuex就是这样产生的 Vue相关介绍 组件调action Actions Mutations Const state = {} 计算属性的一部分 get vue.x depatch(actionName, data) 触发 action vuex应用npm install --save vuex 主键里面如何得到一个对象 计算属性，对应的是getters 12this. 表示组件对象this.$store vuex结构图(管理多组件的状态) actions 里面可以进行 ajaix请求 vuex是个全局 每个组件都能看到 $store dispatch 更新状态就是 dispatch render render: h =&gt; h(App) · =&gt; · 同时是个函数，还是return render: function(createElement) { ​ return createElement(App) } 项目1 监听回车 @keyup.enter=”addTodo” 123456789//方法一@keyup=\"toClick\"toClick (event) &#123; //keycode =13的时候是回车 console.log(event.keyCode) alert(event.keyCode) &#125;// 方法二 @keyup.enter=\"addTodo\" props: [‘todos’] 是跟data()同级的 //取出相关的数据 const {persons, searchName, orderType} = this; v-model 去绑定checkbox就可以了 1&lt;input type=\"checkbox\" v-model=\"todo.complete\"&gt; 放入到 computed 里面的方法，每次都会被调用， methods是事件处理的 不能在子的 vue组件中 进行 父类的 对象改变 ​ 就是 props 传过来的对象 ![image-20190717113739958](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190717113739958.png) mapState vuex 注意事项 1234567891011121314151617 ...mapState([&apos;todos&apos;]) //是个括号包起来的state : &#123; todos: []&#125;dispatch -&gt; actions : &#123; deleteItem(&#123;commit, state&#125;, data) &#123; commit(&apos;mutations里面的方法名&apos;, &#123;data&#125;) &#125;&#125;-&gt;mutations : &#123; mutations里面的方法名(state, &#123;data&#125;) &#123; //操作state，然后进行数据操作，最后更新到了界面上 &#125;&#125; vuex只要更新状态就要进行 dispatch 状态非常多的时候用modules来进行 状态控制 项目量非常大的时候 123methods: &#123; ...mapActions([&apos;deleteSelectItem&apos;])&#125;, ![image-20190719102456735](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190719102456735.png) 逆向思维 1234567891011const arr = []let minArr = []categorys.forEach(c =&gt; &#123; if(minArr.lenth === 8) &#123; minArr = [] &#125; if(minArr.length === 0) &#123; arr.push(minArr) &#125; minArr.push(c)&#125;) 123456789101112131415161718192021watch: &#123; //watch里面可以直接写对应的方法 categroys(value) &#123; new Swiper(&apos;.swiper-container&apos;, &#123; loop: true, pagination: &#123; el:&apos;.swiper-pagination&apos; &#125; &#125;) //怎么才能已经把数据加载完了，然后进行相应的设置 //界面更新后立马创建Swiper对象 this.$nextTick(()=&gt; &#123; //一旦界面更新。理解调用 //下一次dom完成后调用 //这条语句要放在数据更新之后调用 &#125;) //项目遇到什么问题 &#125;&#125; item in 6, 提高用户体验 123props: &#123; score: Number&#125; {} 对象属性 计算属性，最难的时候，不知道什么时候使用计算属性 12345678910111213141516171819:class=&quot;&apos;star-&apos;+size&quot;5个span&lt;span class=&quot;start-item&quot; v-for=&quot;(sc, index) in startClasses&quot; :class=&quot;sc&quot;/&gt;类名常量const CLASS_ON = &quot;on&quot;小数部分大于等于0.5出现halfconst scoreInteger = Math.floor(score)if(score*10 - scoreInteger*10 &gt;=5) &#123; 小数点不精确，所以 *10 scs.push(CLASS_HALF) &#125;while(scs.length&lt;5) &#123; scs.push(CLASS_SAFT)&#125; js对象 {} 在html中都直接这样就好了 观察者设计模式 ![image-20190716215758766](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190716215758766.png) ![image-20190716222831469](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190716222831469.png) 定一个小项目读书（类似fm吗），小视 前端：android、小程序、ios/flutter 后端：java后台进行实现 &gt; 资源储备： &gt; &gt; 1. 如何建立表结构，如何设计 (X) &gt; 2. 后台使用SpringBoot(√) &gt; &gt;","categories":[],"tags":[]},{"title":"2019-07-11-撑起职场bug","slug":"2019-07-11-撑起职场bug","date":"2019-11-11T05:40:29.459Z","updated":"2019-11-11T05:40:29.459Z","comments":true,"path":"2019/11/11/2019-07-11-撑起职场bug/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-07-11-%E6%92%91%E8%B5%B7%E8%81%8C%E5%9C%BAbug/","excerpt":"","text":"[TOC] git的使用服务自己启动通过修改返回值 not_stick 协程写过回调，那么需要使用 kotlin协程，协程上下文，拦截器，挂起函数 Job 调度器 作用域 Job start join cancel Deferred 是Job的子线程，Job类似于thread的地位 Deferred有返回结果，Job的话没有 deffered.await() MainScope 进行了线程切换，然后优雅的使用 上下文，启动模式， 上下文接收调度器 2.6.0 版本的retrofit就携带了 可以直接使用suspend的方法 回调转换为协程 如何捕获协程的异常，异常处理在cache里面处理就可以了 Job类似于Thread 如何通过launch启动协程 初识调度器以及主线程调度器 3.协程的启动模式(Lazy, Atomic, ) 12345var job = GlobalScope.launch (start = CoroutineStart.LAZY)&#123;&#125;job.cancel() deffer 有await","categories":[],"tags":[]},{"title":"2019-07-24-app开发步骤","slug":"2019-07-24-app开发步骤","date":"2019-11-11T05:40:29.459Z","updated":"2019-11-11T05:40:29.459Z","comments":true,"path":"2019/11/11/2019-07-24-app开发步骤/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-07-24-app%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"先配置好统一版本控制 123project.ext.set(\"appcompat\", \"1.0.2\")project.ext.set(\"corektx\", \"1.0.2\")project.ext.set(\"constraintlayout\", \"1.1.3\") 对应下面 123implementation \"androidx.appcompat:appcompat:$project.appcompat\"implementation \"androidx.core:core-ktx:$project.corektx\"implementation \"androidx.constraintlayout:constraintlayout:$project.constraintlayout\" 致力封装一个简洁、实用、易移植的网络框架模块. kotlin的静态代码块 1234567891011121314151617//静态代码块companion object &#123; var INSTANCE: Context by Delegates.notNull() //静态代码块 init &#123; setDefaultRefreshHeaderCreator &#123; context, layout -&gt; layout.setPrimaryColorsId(R.color.colorPrimary, android.R.color.white) ClassicsHeader(context) &#125; setDefaultRefreshFooterCreator &#123; context, layout -&gt; //指定为经典Footer，默认是 BallPulseFooter ClassicsFooter(context).setDrawableSize(20f) &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"反编译","slug":"2019-06-10-反编译","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-14T00:14:08.266Z","comments":true,"path":"2019/11/11/2019-06-10-反编译/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-06-10-%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"","text":"content{:toc}0x01 目的 主要最近公司需要一个类似于运动类的app的地图路线一样的记录，所以需要查看别人怎么实现的，所以就只好反编译keep这个app来进行看看，有没有什么可以得到的 0x02 工作进行通过去百度下载apk包，这个包才好没有进行加固保护，不然就要使用hook dex 的技术来进行提取了，这个我以前通过手机安装 VirtualXposed来进行hook dex。 通过topActivity来进行查看需要的界面，然后去反编译后找到 1.文件中的 id 2131494206 反编译出来是10进制，要而在，反编译出来的public.xml（res/values/public.xml）中对应的是16进制的，即：0x7F0C053E，","categories":[{"name":"反编译","slug":"反编译","permalink":"http://zhousaito.top/categories/%E5%8F%8D%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"android java 反编译","slug":"android-java-反编译","permalink":"http://zhousaito.top/tags/android-java-%E5%8F%8D%E7%BC%96%E8%AF%91/"}],"author":"Zhousaito"},{"title":"求导","slug":"2019-06-11-自定义view2","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-14T00:14:18.135Z","comments":true,"path":"2019/11/11/2019-06-11-自定义view2/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-06-11-%E8%87%AA%E5%AE%9A%E4%B9%89view2/","excerpt":"","text":"content{:toc} 1.自定义view，必经之路 为什么要自定义view； andorid系统内置的view无法实现我们的需求 处于性能考虑 自定义view某种情况下也要实现onLayout ​ 自绘和组合： 不知道怎么下手 数学功底 TextView是最难的view，内置的StaticLayout 树形结构，window是虚拟的概念，是为了管理view来虚拟出来的 android的角度是顺时针的， motionEvent里面有getX getRawX getTop ViewRoot，是个管理view的， WindowManagerGlobal -&gt; 里面创建ViewRootImpl （setView） ViewRoot 中 requestLayout performTraversals -&gt; 计算host.measure host.layout host.draw() addDisplay() 如何绘制wrap_content，绘制一个好的view树上 为了自己适应屏幕，measure，就是把各种尺寸得到一个具体像素，来绘制到屏幕上面来，如果绘制一个自定义树。 UNSPECIFIED: 这个多次measure来确定子布局的位置 EXACTLY MeasureSpecs：避免过多的内存分配 ；MeasureSpec 是View的一个内部类viewGroup#getChildMeasureSpec； Measure这个过程会多次测量的 DecorView是根据屏幕大小来决定的 LayoutParams -》 是在LayoutInflater里面用到；自定义view generateLayoutParams MarginLayoutParams 支持margin参数 自定义LayoutParams getRootMeaurse -&gt; performMeasure -&gt; mView.measure() -&gt; onMeasure() 除了UNSPACE都是用父类的那个测量宽度了 getMeaureWidth 和 getWidth 的区别：通常情况下是相同的 //frameLayout的规则代码 Math.max（0， specSize- padding） 可以绘制的剩余空间 measureChildWidthMargins contentView 在一个线性布局里面，因为还有titlebar在上面 线性模具 resolveSizeAndState 自定义attrs也可以通过@bindingAdapter的方式 getWidth()和getMesureWidth()讲了嘛 SurfaceFling可以进行优化性能 启航 自定义View系列也不错 DecorView跟刘海屏有什么关系吗 从外往内递归，然后从内往外返回宽高 父如果自适应，那父的大小就是由子决定的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SystemServer # startOtherServices wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager()); //这里直接new了一个phoneWindowManager //...中间是启动activity的过程，直接跳过了activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); activity#attatch &#123; mWindow = new PhoneWindow(this, window, activityConfigCallback); //把windowmanager设置进去了 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);&#125; //这个winodow实际是PhoneWindow对象Window#setWindowManager &#123; //创建了WindowManagerImpl，并且传进了 PhoneWindow对象，这里和service不一样的地方，所以可以显示对话框 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125;然后跑到 ActivityThread#handleResumeActivity 进行了addView操作，因为onCreate的时候界面还没有显示出来ActivityThread#handleResumeActivity &#123; //进行了addView //这个就是获取了activity#attach获取的创建好的PhoneWindow的mWindowManager = mWindow.getWindowManager(); //这里用了 依赖倒置原则，vm其实本质是个WindowManagerImpl ViewManager wm = a.getWindowManager(); wm.addView(decor, l);&#125;然后接下来就 WindowManagerImpl # addView -》 global # addView -》 ViewRootImpl # addView ...~~//这里断了，不知道怎么调到 WindowManagerImpl # addView -》 global # addView~~~ activityManagerService 怎么socket通知Zygote创建进程的，这个socket在哪里发送的 最近看源码发现：怎么保护线程不死 ZygoteInit-&gt; runSelectLoop方法里面while(true) -&gt; socket#accept来进行阻塞 要么就是用Looper.prepare() -&gt; Looper.loop() 这两个组合来进行维护这个线程不被释放 SystemServer；ActivityThread 我觉得吧，如果要到自己线程进行干事情的话，肯定是使用Looper这个组合。​ ZygoteInit是通过sokect这种通信机制来进行等待AMS的请求 创建一个新的进程 1234567891011121314151617181920zygoteInit# main &#123; forkSystemServer &#123; &#125; runSelectLoop &#123; //这个方法有等待，等待AMS的socket信号 acceptCommandPeer() &#125;&#125;AMS # startProcessLocked AMS # startProcessLocked(参数多)AMS # startProcess &#123; startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);&#125; 马尔科夫模型 和算法相关的。 时间复杂度，空间复杂度 知道多少种算法 【深度优先遍历，广度优先遍历】 ，回溯法，分治算法，贪心算法，动态规划 一个问题怎么想到用动态规划 问题得到问题规模增大导致的变化 递推式–状态转移方程 结合侓，，每天学一点算法，挺有意思的 朴素算法。逆波兰表达式，栈的典型应用，（编译原理）可能会用到 zero老师有没有管理经验 1.ViewGroup开始测量自己的尺寸 ​ 1.尺寸值，200dp， match_parent，wrap_content 2.为每个子view计算测量的限制信息 3.把上一步确定的限制信息，传递给每个子view ​ 树形递归过程，子view调取自己的measure过程 4.viewGroup 获取每个子view测量的尺寸，wrap_content5.ViewGroup根据自身的情况计算自己的尺寸 6.保存自身的尺寸 类图+时序图 ； 多动手 getWidth 和 getLayoutParams().width的区别：getLayoutParams()返回的是xml布局里面设置的。getLayoutParams().width返回的是xml里面android:width的值。是在onMeasure之前的值。getwidth返回的是onMeasure之后的值。 18670301864 Wrap_content怎么确定控件的高度和宽度的， 绘制完了才有的getHeight的值 measure之后，wrap_content，match_parent都有值了 performLayout -&gt; decroVIew (View的layout).layout -&gt; setFrame view里面尽然有onLayout onLayout：基本都是if else 加坐标计算 ​ 根据规则确定子view的位置 ​ 流程： ​ 1.遍历子view，for ​ 2.确定自己的规则 ​ 3.子View的测量尺寸 l ,t, b,r left,top,bottom,right ​ 4.left,top,bottom,right ​ 5.child.layout 如何去阅读源码 1带着问题去看：找到什么东西 2点到为止：不要太在意细节 3看方法，方法名，返回值，参数， 问题： 控件的wrap_content，match_patent怎么确定的 控件在onLayout的时候为什么不用getHeight/getWidth而是用getMeasureHeight/getMeasureWidth， layoutParams getwith， 和控件的getWidth的区别-》layoutParams getwith相当于xml布局里头的layout_width 而getWidth是 mRight - mLeft, 1.时间复杂度， n 表示数据规则 O(f(n)) 表示运行算法所需要 二分查找法 O(logn) 寻找数组 O(n) 细节上的优化 归并排序 算法时间复杂度 O(nlogn) O(n^2 + nlogn) n的规模是一样的情况下就是 O(n^2) 快速排序算法，可能会退化成O(n^2) 平均情况是 nlogn ![image-20190615102246363](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615102246363.png) 多开一个辅助的数组 O(n) 多开一个辅助的二维数组：O(n) 多开一个常量O(1) 递归调用是有空间代价的 Assert(n &gt;= 0) ![image-20190615102827840](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615102827840.png) 递归的深度多少，就是多少空间复杂度 递归的深度是多 O(m) 级别的空间复杂度,m是深度 ![image-20190615103301021](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615103301021.png) ![image-20190615103350803](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615103350803.png) for循环里面先进行 int j+1; j&lt;n 这个判断后才会往下走，然后走完就j++ 选择排序 For(int j=0, j&lt;n ;j++) { For(int j=0, j&lt;10000 ;j++) { //这个10000不算入时间复杂度上 } } ![image-20190615103800925](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615103800925.png) ![image-20190615104015935](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615104015935.png) ![image-20190615104235105](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615104235105.png) n 除以 xx 等于1，然后就是logn ![image-20190615104546622](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615104546622.png) O(sqrt(n)) 根号n 判断是否是个素数 具体问题，具体分析。 二分查找法基本就是递归查找法 binarySearch 二分查找 ![image-20190615110649958](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615110649958.png) pow (double x, int n) ![image-20190615110944775](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615110944775.png) ————]————————- ![image-20190615133355295](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190615133355295.png) 二分查找法 没有没有bug的二分查找法在1962年 l+(r-l)/2 -&gt; 通过减法来进行 考虑边界情况，是否为空，是否不在集合中 如何写出正确的程序： 明确变量的含义 ， 循环不变量， 小数据量调试 forceClosed, —&gt; true 就是个闭合的 false就是开口的 getLength 获取具体的长度 getSegment 路径的片段 是否截取上次的 getPosTan 路径上的某点坐标，起始点的坐标 弗兰克尔在 追寻生命的意义 中说过 环境可能是无法改变的，唯一可以改变的是自己的态度 我们所处的环境就是一个巨大的鸟笼 我们无时无刻都生活在这个鸟笼中 有太多的人想要飞出这个笼子寻找自由 但不是每个人都能像安迪那样长出丰满的羽翼 所以固化的生活成了我们大部分人的常态 onTouchEvent来进行判断 mCacheViews —默认大小 2 每次移除第一个 pool 的大小是5个 onLayout 布局里面 mChangeScrap 与 mAttachedScrap mCachedViews mViewCacheExtension RecyclerViewPool 什么时候回收，什么时候复用 滑动快的时候，多创建的ViewHolder是怎么回事 1234567891011121314151617RecyclerView#OnTouchEvent的move事件中 RecyclerView#scrollByInternal LayoutManager#scrollHorizontallyBy LayoutManager#scrollBy LayoutManager#fillLayoutManager#fill (回收和复用) layoutManger#layoutChunk &#123; layoutState.next(recycler); &#125; recycler（RecyclerView.recycler已经回到了RecyclerView中 ）.getViewForPosition(mCurrentPosition) &#123; getScrapOrCachedViewForId中经过 mAttachedScrap mViewCacheExtension mRecyclerPool &#125; onCreate onBind getViewForPosition ItemTouchHelper 来进行RecyclerView的拖动View ItemTouchHelper的使用 Callback callback = new C() ItemTouchHelper touch = new ItemTouchHelper(callback) touch.attachToRecyclerView(rv) 15怎么来的可以解析一下不 onChidrenDraw 就是 RecyclerView onDraw回调的 recyclerView.getChildCount是4个，而不是8个，指的是显示的个数是4个 只要子view把事件消耗了，中间的view，就没有UP事件了，可能有move事件 平滑滚动： 自定义布局的流程： ​ 1.自定义属性：声明，设置，解析获取自定义值 ​ 2.测量：在onMeasure中 MeasureSpac.AT_MOST/EXACTIY ​ 自身的宽与高/child的宽高 3.布局：onLayout 4.绘制：onDraw方法 绘制分割线什么的 5.处理LayoutParams 6.触摸反馈：滑动事件 onDispatchDraw？？？ 互联网思维啊(迭代思想) 123//要想滑动必须消耗事件//onTouchEvent里面返回true，才有后续的move和up事件//就是说不返回true的话，就没有move和up事件了 实现滑动，然后再实现阻尼效果，然后实现滑动选择器。这些都跟滑动有关 厉害的人很早就开始厉害了 拥有强烈的成功欲望 拥有说干就干的行动力 都是深度学习的机器 都善于坚持 都愿意延迟满足 [袁阔成评书网]Xfermode UNSPECIFIED 部分测试 wrap_content往往会传个携带父类大小的size给子类 ​ 然后往往是小于父类这个值得 相当于padding是什么时候有效：是在测量的时候有效吗 ​ measureChild(child, Wspec, Hspec) textView放大镜 zero老师最拿手textView 控件滑动起来：1.view的scrollBy scrollTo方法实现滑动 ​ 2.通过动画来给view添加位移效果，实现滑动 ​ 3.通过改变view的LayoutParams，让view重新布局，从而重新滑动 wps visio professional visio 相当于canvas坐标移动了50 移动的是画布 相当于原点变成了（50，50） //移动的是画布 canvas.translate(mLeft-sx,mTop-sy) 6中方式实现移动~ 最终的两种移动方式：layout参数；移动动画布 压力信号-》 InputWindowManager 最初的是InputManagerService？ 然后传到窗口的activity 事件的分发流程 事件的监听流程 事件的记忆机制：如果已经返回true了，就不会给其他的view了 每一个viewGroup都是事件的分发节点，维护了一个TouchTarget的链表 记录哪个子View的消耗该时间的 截获机制：action_down事件一定可截获的， 非down时间，若子类 分裂机制： 设置gravity，事件的几种机制 如何重构 版本冲突解决： https://blog.csdn.net/qq_32452623/article/details/81323193 1234567androidTestImplementation ('com.android.support.test:runner:1.0.2')&#123; exclude group: 'com.android.support' &#125; androidTestImplementation ('com.android.support.test.espresso:espresso-core:3.0.2')&#123; exclude group: 'com.android.support'&#125; 本身来进行消耗：dx &lt; dy dy&gt; min 排除误操作 1finalChild 曾经有伟人说过，30岁之前做加法，因为不知道自己能做什么，30岁之后要做减法，做有把握的事 滑动的是内容 长按会影响，滑动效果，会有滑动跳动 realHeight - 父布局高度 computeScroll invalidate如果没 invalidate完，就不会再调用了 postInvalidate如果 这里和属性动画那一块内核倒是很像 plos sourceTree git区块链算法： 集中式，只有服务器有一份，服务器连接不上 ​ 就commit和回滚都不能做了 分布式，本地也有一份管理 ​ 分布式的话每一个人本地都是一份完整的代码版本，即使服务器版本比你低，也会进行分享覆盖的 ​ 文件的形式进行存储，快照就是当前文件的copy Fetch是拉新分支 刷新本地分支的状态， 就可以看到本地的分支可以远程分支一样了 gitk&amp; git后缀的那个文件里面会保存你的详细信息，以及版本的详细信息，存在暂存区和本地仓库中，版本那个比较貌似是tree，文件blob的形式 git status Git add —all 到了暂存区 Git commit -m clone checkout add commit push unmodify已经被管理了 不需要进行add操作 Untracked （追踪）没有被管理起来的文件 —&gt; stage 文件的4中状态 你们的分支管理有按照git flow管理吗developfeature/release/bugfix/master 更换远程仓库 git remote add git的权威文档 https://git-scm.com/book/zh/v2 alicode这个比较好，免费的 git remote add origin https://gitee.com/zhousaito/adadfa.git git branch -vv 当前处于哪个分支 Fetch 是拉取远程仓库信息 到 本地仓库，pull 是拉取远程分支代码到当前分支 Git config core.ignorecase false 不要忽略大小写 git config core.ignorecase false https://github.com/github/gitignore objects里面存了blob文件和tree，tree比较计算版本信息 git status 多执行这个命令 git diff 比较没有提交的修改的文件 git diff --staged git diff --cached git push —set-upstream origin master git branch gitk 命令 需要自己安装 git branch -D HEAD 指针 Rebase 会有多次冲突的 ，分支上的历史就没了 merge的话，分支的还有 git checkout –conflict=diff3 conflicts/testfile git checkout –ours conflicts/testfile OverScroller 视图动画 &gt;补间动画(旋转，平移，缩放，透明) &gt; &gt;帧动画 &gt; &gt;​ AnimationDrawable对象来添加，这样可以通过代码来实现 &gt; &gt;​ &gt; &gt;插值器:缓动函数 &gt; &gt;​ startOffset &gt; &gt; &gt; &gt;触摸反馈动画 &gt; &gt;转场动画 [ 共享元素的动画] &gt; &gt;视图状态动画 &gt; &gt;矢量图动画 &gt; &gt;约束布局 &gt; &gt;揭露动画 &gt; &gt;Spring动画 &gt;lottie-android &gt; &gt; &gt;属性动画 draw： ![image-20190702201748578](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190702201748578.png) 设置绘制风格 抗锯齿 绘制路径效果 setPatchEffect 绘制虚线 setShader setStyle 设置画笔的填充风格 setTextAlign 文字对齐方式 setTextScaleX 设置文字水平拉伸比例 setStokeCap 画笔形状 setStrokeJoin 画笔转弯处的连接风格 Canvas. drawArc (也可以画圆吗) drawCircle drawOval 椭圆 drawRoundRect 圆角矩形 convas.drawPicxture (画图片) 一般webView stroke会把圆占地面积变大 ![image-20190702203410555](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190702203410555.png) ​ path.close() ​ android 顺时针为正，跟数学的坐标角度相反 ​ useCenter 这个为true就可以画扇形， ​ 如果useCenter为false，如果fill就会直接封过去 moveTo lineTo shader 渐变器 线性渐变，弧形渐变 LinearGradient skew扭曲 Canvas.scale 画布是可以缩放的 Canvas.clipRect 获取裁剪 Xfermode玩不动 保存与回滚 (就跟栈一样，每次保存就保存在栈里面 最后，restore，然后就相当于弹栈) 裁剪和平移不一样 裁剪不会改变坐标的，平移会改变坐标的 canvas相当于一个图层 setShadowLine 设置阴影 文字测量 Staticlayout 来进行测试 mPaint.setStrokeCap(Paint.cap.round) //画出椭圆的效果 mPaint.setTestAlign() 方法一、 //来进行得到text的一个rect mPaint.getTextBounds() (ract.top + ract.bottom)/2 方法二、 Ascent descent mPaint.getFontMetics(founmetric) (founmetric.ascent + fontMetrics.descent)/2 来计算 自定义view，大小要通过onMeasure来确定的应为放在scrollView里面，会变白，是因为没有重写onMeasure方法 列个Android坑大全 文字有默认间距 多行文字绘制：StaticLayout 丘比特之线 对于大部分中文英文，distance用top和bottom计算，有偏差，字体被偏下了一点点，应该用ascent和descent计算部分国家的特殊字符的上下高度会超过descent，ascent，用top和bottom计算 一个基于 Python 的简单服务一行代码搞定服务器 python -m SimpleHTTPServer Python3 -m http.server 视频剪辑这一类， 自定义view， breakText 做多行绘制 裁剪画布 可以做出多种类型的图片出来绘制bitmap D:\\android9\\development\\samples\\ApiDemos\\src\\com\\example\\android\\apis\\graphics 官方demo要个手写签名 canvas的底层原理matrix canvas的操作原理 横着 乘以 竖着 matrix.set 会清空上次的操作 旋转，如果没设置就是(0，0)，可以进行设置 局部缩放 matrix.setScale() 扭曲 -》可以做翻页 扭曲做3d效果 preTranslate postRotate rgba 还是 argb 安徽数学会学到高数和微积分","categories":[{"name":"求导","slug":"求导","permalink":"http://zhousaito.top/categories/%E6%B1%82%E5%AF%BC/"}],"tags":[{"name":"java 数学","slug":"java-数学","permalink":"http://zhousaito.top/tags/java-%E6%95%B0%E5%AD%A6/"}],"author":"Zhousaito"},{"title":"exercise","slug":"2019-06-26-exercise","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-14T00:14:30.754Z","comments":true,"path":"2019/11/11/2019-06-26-exercise/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-06-26-exercise/","excerpt":"","text":"content{:toc}0x01 准备 生成keystore签名文件","categories":[{"name":"项目","slug":"项目","permalink":"http://zhousaito.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/tags/android/"}],"author":"Zhousaito"},{"title":"自定义view(二)","slug":"2019-06-23-自定义View2","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-14T00:14:26.874Z","comments":true,"path":"2019/11/11/2019-06-23-自定义View2/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-06-23-%E8%87%AA%E5%AE%9A%E4%B9%89View2/","excerpt":"","text":"content{:toc}0x01 最近公司要求要出一个暂开内容，然后还能收缩内容的控件 其实一开始我想用ExpendListView，但是后面寻思着用了自定义View，毕竟现在自己也在学这一块 0x02 效果 0x03 代码一、SubExpendLayout代码 SubExpendLayout 这个是上面那个view，上面那个view实际上是叠加了一个textView，然后进行的，因为需要要求第一个textView收缩之后要点点，所以加上了singleLine =true 根据分析 对应的expend()和close()代码如下 123456789101112131415public void expend() &#123; tvContentClose.setVisibility(INVISIBLE); //close的textview ivExpend.setVisibility(INVISIBLE);//close展开按钮图片 tvContentExpend.setVisibility(VISIBLE);//展开的textview ivClose.setVisibility(VISIBLE);//关闭的按钮图片&#125;public void close() &#123; tvContentClose.setVisibility(VISIBLE); ivExpend.setVisibility(VISIBLE); tvContentExpend.setVisibility(INVISIBLE); ivClose.setVisibility(INVISIBLE);&#125; 对应的测量代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); measureChildren(widthMeasureSpec, heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int width = 0; int height = 0; switch (widthMode) &#123; case MeasureSpec.UNSPECIFIED: case MeasureSpec.AT_MOST: &#123; //宽度我这里实际默认了屏幕宽度 for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int measuredWidth = view.getMeasuredWidth(); width = Math.max(widthSize, measuredWidth); &#125; &#125; break; default: &#123; width = widthSize; &#125; break; &#125; switch (heightMode) &#123; case MeasureSpec.UNSPECIFIED: case MeasureSpec.AT_MOST: &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); //隐藏的就不进行测量了 if (view.getVisibility() != GONE) &#123; int measuredHeight = view.getMeasuredHeight(); if (i &gt; 0) &#123; //第一个就照着第二个展开内容的摆放就好了,因为第一个内容和第二个的内容相同,但是是单行的,所以第二个的内容肯定比第一个打 height += measuredHeight; &#125; &#125; &#125; &#125; break; default: &#123; height = heightSize; &#125; break; &#125; Log.e(TAG, \"onMeasure: \" + height); setMeasuredDimension(width, height);&#125; 对应的onLayout的代码 123456789101112131415161718192021222324252627282930@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int tempHeight = 0; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); if (view.getVisibility() == GONE) &#123; //隐藏的就下一个，就不在布局 continue; &#125; int measuredHeight = view.getMeasuredHeight(); view.layout(0, tempHeight, view.getMeasuredWidth(), measuredHeight + tempHeight); //第二个和第一个重叠，所以不进行高度添加 if (i &gt; 0) &#123; tempHeight += measuredHeight; &#125; else &#123; //记录这个singleLine的textView closeHeight = measuredHeight; &#125; &#125; //这里应该执行动画的时候多次执行，所以只能得到第一次的值就是我们想要的 if (expendHeight == 0 || reLayout) &#123; expendHeight = getMeasuredHeight(); midHeight = (closeHeight + expendHeight) / 2; reLayout = false; &#125;&#125; 最后可以来一个触摸事件的方法 123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: if (isExpend) &#123; closeLayout(); //执行关闭动画 &#125; else &#123; expendLayout();//执行展开动画 &#125; break; default: break; &#125; return true;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public void expendLayout() &#123; ValueAnimator animator = ValueAnimator.ofInt(closeHeight, expendHeight); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int changeHeight = (int) animation.getAnimatedValue(); LayoutParams layoutParams = getLayoutParams(); layoutParams.height = changeHeight; setLayoutParams(layoutParams); if (changeHeight &gt;= midHeight) &#123; expend(); &#125; &#125; &#125;); animator.setDuration(500); animator.start(); isExpend = true;&#125;public void closeLayout() &#123; ValueAnimator animator = ValueAnimator.ofInt(expendHeight, closeHeight); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int changeHeight = (int) animation.getAnimatedValue(); LayoutParams layoutParams = getLayoutParams(); layoutParams.height = changeHeight; setLayoutParams(layoutParams); if (changeHeight &lt;= midHeight) &#123; close(); &#125; &#125; &#125;); animator.setDuration(500); animator.start(); isExpend = false;&#125; 具体的动画实现 1234567891011121314151617181920212223242526272829303132333435363738394041public void expendLayout() &#123; ValueAnimator animator = ValueAnimator.ofInt(closeHeight, expendHeight); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int changeHeight = (int) animation.getAnimatedValue(); LayoutParams layoutParams = getLayoutParams(); layoutParams.height = changeHeight; setLayoutParams(layoutParams); if (changeHeight &gt;= midHeight) &#123; expend(); &#125; &#125; &#125;); animator.setDuration(500); animator.start(); isExpend = true;&#125;public void closeLayout() &#123; ValueAnimator animator = ValueAnimator.ofInt(expendHeight, closeHeight); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int changeHeight = (int) animation.getAnimatedValue(); LayoutParams layoutParams = getLayoutParams(); layoutParams.height = changeHeight; setLayoutParams(layoutParams); if (changeHeight &lt;= midHeight) &#123; close(); &#125; &#125; &#125;); animator.setDuration(500); animator.start(); isExpend = false;&#125; 二、RecordExpendLayout代码分别设置了2个类，SubmissionExpendAdapter是个实现类 RecordExpendLayout的代码如下： 123456789101112131415161718192021public RecordExpendLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; //设置了个背景 setBackgroundColor(getResources().getColor(R.color.background)); //把点击关闭和开启状态的title提前加入了进来 View titleView = LayoutInflater.from(getContext()).inflate(R.layout.view_record_expend_title, this, false); cardItemViews.add(titleView); addView(titleView); ivCtrolStatus = (ImageView) findViewById(R.id.iv_ctrol_status); setStatus(Status.EXPEND); &#125; 进行对应的测量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec);// measureChildren(widthMeasureSpec, heightMeasureSpec); for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); measureChildWithMargins(view, widthMeasureSpec, 0, heightMeasureSpec, 0); &#125; int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int width = 0; int height = 0; switch (widthMode) &#123; case MeasureSpec.UNSPECIFIED: case MeasureSpec.AT_MOST: &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int measuredWidth = view.getMeasuredWidth(); width = Math.max(widthSize, measuredWidth); &#125; &#125; break; default: &#123; width = widthSize; &#125; break; &#125; switch (heightMode) &#123; case MeasureSpec.UNSPECIFIED: case MeasureSpec.AT_MOST: &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); MarginLayoutParams lp = (MarginLayoutParams) view.getLayoutParams(); //隐藏的就不进行测量了 if (view.getVisibility() != GONE) &#123; int measuredHeight = view.getMeasuredHeight() + lp.topMargin + lp.bottomMargin; height += measuredHeight; &#125; &#125; &#125; break; default: &#123; height = heightSize; &#125; break; &#125; Log.e(TAG, \"onMeasure: \" + height);// int currentHeight = ViewUtil.dp2px(getContext(), 20); if (expendHeight == 0 || reLayout) &#123; expendHeight = getMeasuredHeight(); &#125; setMeasuredDimension(width, height); &#125; 进行onLayout 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int tempHeight = 0; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); if (view.getVisibility() == GONE) &#123; //隐藏的就下一个，就不在布局 continue; &#125; int measuredHeight = view.getMeasuredHeight(); MarginLayoutParams lp = (MarginLayoutParams) view.getLayoutParams(); view.layout(lp.leftMargin, tempHeight + lp.topMargin, view.getMeasuredWidth() + lp.rightMargin, measuredHeight + tempHeight + lp.topMargin - lp.bottomMargin); tempHeight += measuredHeight + lp.topMargin + lp.bottomMargin; //记录这个singleLine的textView if (i == 0) &#123; closeHeight = measuredHeight; &#125; &#125; //这里应该执行动画的时候多次执行，所以只能得到第一次的值就是我们想要的 if (expendHeight == 0 || reLayout) &#123; expendHeight = getMeasuredHeight(); midHeight = (closeHeight + expendHeight) / 2; reLayout = false; &#125; Log.e(TAG, \"onLayout: expendHeight: \" + expendHeight + \" \" + getMeasuredHeight());&#125; 剩下的就是ExpendAdapter 接口的设置了 12345678910111213public interface ExpendAdapter &#123; int getItemCount(); /** * 已经在内部添加，因为是已知 item * * @param position * @param view * @param parent */ void getView(int position, View view, RecordExpendLayout parent);&#125; RecordExpendLayout和adapter相关的代码 123456789101112131415161718192021222324252627282930313233343536@Overridepublic LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs);&#125;private ExpendAdapter mAdapter;public void setAdapter(ExpendAdapter adapter) &#123; mAdapter = adapter; notifyAllData();&#125;private void handleData() &#123; int itemCount = mAdapter.getItemCount(); for (int i = 0; i &lt; itemCount; i++) &#123; View view = LayoutInflater.from(getContext()).inflate(R.layout.view_record_expend_item, this, false); cardItemViews.add(view); addView(view); mAdapter.getView(i, view, this); &#125;&#125;public void notifyAllData() &#123; if (mAdapter != null) &#123; handleData(); &#125; Log.e(TAG, \"notifyAllData: \"); //重新加入值，就重新测量一次 reLayout = true; requestLayout();&#125; 以上就是上周觉得比较有意思而又比较重要的代码","categories":[{"name":"自定义View","slug":"自定义View","permalink":"http://zhousaito.top/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"}],"tags":[{"name":"android view","slug":"android-view","permalink":"http://zhousaito.top/tags/android-view/"}],"author":"Zhousaito"},{"title":"android动画(转)","slug":"2019-07-09-自定义view3","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-14T00:14:43.502Z","comments":true,"path":"2019/11/11/2019-07-09-自定义view3/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-07-09-%E8%87%AA%E5%AE%9A%E4%B9%89view3/","excerpt":"","text":"content{:toc}要求 实现：123456789101112131415private void init(Context context, int width, int height) &#123; mContext = context; mWidth = width; mHeight = height; //初始化画背景的paint mBgPaint = new Paint(); mRect = new Rect(); initCirclePaint(); //初始化画旋转的外圆paint initBallPaint(); //初始化变成点的piant initForkPaint(); //初始化叉叉的paint initLinePaint(); //初始化画勾勾的paint &#125; 画外圆paint123456789101112131415161718192021222324252627/** * 画外围转的圆 */ private void initCirclePaint() &#123; mCirclePaint = new Paint(); mCirclePaint.setStyle(Paint.Style.STROKE); mCirclePaint.setStrokeWidth(10); mCirclePaint.setAntiAlias(true); mCirclePaint.setStrokeCap(Paint.Cap.ROUND); int[] colors = &#123;Color.WHITE, Color.TRANSPARENT&#125;; mPositions = new float[2]; mPositions[0] = 0.7f; mPositions[1] = .9f; //渐变 SweepGradient sweepGradient = new SweepGradient(200, 200, colors, mPositions); Matrix matrix = new Matrix(); matrix.setRotate(130, 200, 200); sweepGradient.setLocalMatrix(matrix); mCirclePaint.setShader(sweepGradient); int padding = 20; mRectF = new RectF(); mRectF.set(0 + padding, 0 + padding, mWidth - padding, mHeight - padding); &#125; 画叉 paint12345678910111213/** * 画叉叉 */private void initForkPaint() &#123; mPath = new Path(); mForkPaint = new Paint(); mForkPaint.setStrokeCap(Paint.Cap.ROUND); mForkPaint.setAntiAlias(true); mForkPaint.setStrokeWidth(10); mForkPaint.setStyle(Paint.Style.STROKE); mForkPaint.setColor(Color.WHITE);&#125; 画小球12345678910/** * 画小球 */private void initBallPaint() &#123; mBallPaint = new Paint(); mBallPaint.setAntiAlias(true); mBallPaint.setStyle(Paint.Style.FILL); mBallPaint.setColor(Color.WHITE);&#125; 画勾勾123456789101112131415161718192021222324252627282930313233343536/** * 画勾勾 */private void initLinePaint() &#123; int centerX = mWidth / 2; int centerY = mHeight / 2; mLinePaint = new Paint(); mLinePaint.setAntiAlias(true); mLinePaint.setStyle(Paint.Style.STROKE); mLinePaint.setStrokeWidth(10); mLinePaint.setColor(Color.WHITE); mLinePaint.setStrokeCap(Paint.Cap.ROUND); //勾勾的线 mGPath = new Path(); float leftPathHeight = mHeight * 0.4f / 2f; mGPath.moveTo(centerX, centerY + leftPathHeight); mGPath.lineTo((float) (centerX - leftPathHeight / Math.tan(40 * Math.PI / 180)), centerY); mPathMeasure = new PathMeasure(); mPathMeasure.setPath(mGPath, false); mLineRightPaint = new Paint(); mLineRightPaint.setAntiAlias(true); mLineRightPaint.setStyle(Paint.Style.STROKE); mLineRightPaint.setStrokeWidth(10); mLineRightPaint.setColor(Color.WHITE); mLineRightPaint.setStrokeCap(Paint.Cap.ROUND); mGRightPath = new Path(); float rightPathHeight = mHeight * 0.4f / 2f; mGRightPath.moveTo(centerX, centerY + rightPathHeight); mGRightPath.lineTo((float) (centerX + rightPathHeight / Math.tan(40 * Math.PI / 180)), centerY - rightPathHeight); mPathRightMeasure = new PathMeasure(); mPathRightMeasure.setPath(mGRightPath, false);&#125; 最终onDraw1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 @Override public void draw(@NonNull Canvas canvas) &#123; //防止还有个 半径为10的小球还在，所以清理的画布 if (mDashPathEffect != null) &#123; canvas.drawColor(Color.WHITE, PorterDuff.Mode.CLEAR); canvas.drawColor(Color.WHITE); &#125; int centerX = mWidth / 2; int centerY = mHeight / 2; mBgPaint.setColor(Color.GREEN); mBgPaint.setStyle(Paint.Style.FILL); canvas.drawRoundRect(0, 0, mWidth, mHeight, 30, 30, mBgPaint); //旋转外面的圆圈 canvas.save(); canvas.rotate(90 + mRotate, mWidth / 2f, mHeight / 2f); //画运动圆弧 canvas.drawArc(mRectF, -180, 240, false, mCirclePaint); canvas.restore(); prepareForkPath(centerX, centerY); //画叉 canvas.drawPath(mPath, mForkPaint); if (mDashPathEffect != null) &#123; //把小球变小 canvas.drawCircle(centerX, centerY - mMoveHeight, 5, mBallPaint); canvas.drawPath(mGPath, mLinePaint); canvas.drawPath(mGRightPath, mLineRightPaint); &#125; else &#123; //画移动后的小球 canvas.drawCircle(centerX, centerY - mMoveHeight, 10, mBallPaint); &#125; &#125;private void prepareForkPath(int centerX, int centerY) &#123; double cos45Value = Math.cos(45 * Math.PI / 180); double sin5Value = Math.sin(45 * Math.PI / 180); float len = mForkLenScale * centerX; Log.e(TAG, \"draw: \" + len); //左上角 float x1 = (float) (centerX - len * cos45Value); float y1 = (float) (centerY - len * sin5Value); //右上角 float x2 = (float) (centerX + len * cos45Value); float y2 = (float) (centerY - len * sin5Value); //右下角 float x3 = (float) (centerX + len * cos45Value); float y3 = (float) (centerY + len * sin5Value); //左下角 float x4 = (float) (centerX - len * cos45Value); float y4 = (float) (centerY + len * sin5Value); //要进行reset，不然一直运行就会卡顿,并且一直是把叉在那里看不到变化 mPath.reset(); mPath.moveTo(x1, y1); mPath.lineTo(x3, y3); mPath.moveTo(x2, y2); mPath.lineTo(x4, y4); &#125; 启动动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 /** * 启动动画 */ public void startAnimator() &#123; AnimatorSet animatorSet = new AnimatorSet(); ValueAnimator rotateAnimator = ValueAnimator.ofFloat(0, 1); rotateAnimator.setDuration(1000); //有了这个加速器 中间就不会产生停顿了 rotateAnimator.setInterpolator(new LinearInterpolator()); rotateAnimator.setRepeatCount(2); rotateAnimator.setRepeatMode(ValueAnimator.RESTART); rotateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float animatedValue = (float) animation.getAnimatedValue(); mRotate = -360 * animatedValue;// if (mForkLenScale != 0) &#123;// mForkLenScale = 1 - 0.6f * animatedValue;// &#125; invalidateSelf(); &#125; &#125;);// rotateAnimator.start(); ValueAnimator forkAnimator = ValueAnimator.ofFloat(0.6f, 0); forkAnimator.setDuration(1000); //有了这个加速器 中间就不会产生停顿了 forkAnimator.setInterpolator(new LinearInterpolator());// forkAnimator.setRepeatCount(ValueAnimator.INFINITE);// forkAnimator.setRepeatMode(ValueAnimator.RESTART); forkAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float animatedValue = (float) animation.getAnimatedValue(); mForkLenScale = animatedValue; if (mForkLenScale == 0) &#123; mForkPaint.setAlpha(0); &#125; invalidateSelf(); &#125; &#125;);// forkAnimator.start(); ValueAnimator ballAnimator = ValueAnimator.ofFloat(0, mHeight * 0.6f / 2f, -mHeight * 0.6f / 2f, -mHeight * 0.4f / 2f); ballAnimator.setDuration(1500); ballAnimator.setStartDelay(1000); //有了这个加速器 中间就不会产生停顿了 ballAnimator.setInterpolator(new LinearInterpolator());// forkAnimator.setRepeatCount(ValueAnimator.INFINITE);// forkAnimator.setRepeatMode(ValueAnimator.RESTART); ballAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float animatedValue = (float) animation.getAnimatedValue(); mMoveHeight = animatedValue; invalidateSelf(); &#125; &#125;);// ballAnimator.start(); ValueAnimator gAnimator = ValueAnimator.ofFloat(1, 0); gAnimator.setDuration(500); gAnimator.setStartDelay(2500); //有了这个加速器 中间就不会产生停顿了 gAnimator.setInterpolator(new LinearInterpolator()); gAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float animatedValue = (float) animation.getAnimatedValue(); mDashPathEffect = new DashPathEffect(new float[]&#123;mPathMeasure.getLength(), mPathMeasure.getLength()&#125;, mPathMeasure.getLength() * animatedValue); mDashPathRightEffect = new DashPathEffect(new float[]&#123;mPathRightMeasure.getLength(), mPathRightMeasure.getLength()&#125;, mPathRightMeasure.getLength() * animatedValue); mLinePaint.setPathEffect(mDashPathEffect); mLineRightPaint.setPathEffect(mDashPathRightEffect); invalidateSelf(); &#125; &#125;);// gAnimator.start(); animatorSet.playTogether(rotateAnimator, forkAnimator, ballAnimator, gAnimator); animatorSet.start(); &#125; 适当的的地方可以用用Interpolator，有更加吸引人的地方。 总结： path绘制的时候要进行reset，否则就会一直画，然后执行的动画去绘制的时候就会进行卡顿 可以用canvas的旋转来进行旋转动画绘制 SweepGradient 或者 LinearGradient等 position是传递 0-1的值就好了 setInterpolator(new LinearInterpolator()) 这样，repeatCount多次以后就不会停顿一下，再继续下一个动画 repeatCount是指重复的次数，所以2表示重复2次，一开始的那一次不包含在内，也就是说肉眼看到是有3次的动画 清空某个点什么的可以用 canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);来进行全部清除，只要保证后面不再执行绘制这个清除的内容就可以了","categories":[{"name":"项目","slug":"项目","permalink":"http://zhousaito.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/tags/android/"}],"author":"Zhousaito"},{"title":"2019-07-09-javaweb","slug":"2019-07-09-javaweb","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-11T05:40:29.458Z","comments":true,"path":"2019/11/11/2019-07-09-javaweb/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-07-09-javaweb/","excerpt":"","text":"直接可以进行http访问 1234567891011/** * 作为http的正文进行返回 */@RestControllerpublic class HelloController &#123; @RequestMapping(value = \"/hello\", method = RequestMethod.GET) public String hello() &#123; return \"hello Spring boot\"; &#125;&#125; 数据库用包装类型，是因为Integer可以进行判空处理 #{aa} 获取参数值 keyColumn =”area_id” 保留字 使用这种方法 `name` 问题： Mysql出现Table ‘performance_schema.session_status’ doesn’t exist","categories":[],"tags":[]},{"title":"2019-07-11-小细节","slug":"2019-07-11-小细节","date":"2019-11-11T05:40:29.458Z","updated":"2019-11-11T05:40:29.463Z","comments":true,"path":"2019/11/11/2019-07-11-小细节/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-07-11-%E5%B0%8F%E7%BB%86%E8%8A%82/","excerpt":"","text":"[TOC] listView 在 NestedScrollView中解决滑动冲突1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class NestedListView extends ListView implements NestedScrollingChild &#123; private final NestedScrollingChildHelper mScrollingChildHelper; public NestedListView(Context context, AttributeSet attrs) &#123; super(context, attrs); mScrollingChildHelper = new NestedScrollingChildHelper(this); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; setNestedScrollingEnabled(true); &#125; &#125; @Override public void setNestedScrollingEnabled(boolean enabled) &#123; mScrollingChildHelper.setNestedScrollingEnabled(enabled); &#125; @Override public boolean isNestedScrollingEnabled() &#123; return mScrollingChildHelper.isNestedScrollingEnabled(); &#125; @Override public boolean startNestedScroll(int axes) &#123; return mScrollingChildHelper.startNestedScroll(axes); &#125; @Override public void stopNestedScroll() &#123; mScrollingChildHelper.stopNestedScroll(); &#125; @Override public boolean hasNestedScrollingParent() &#123; return mScrollingChildHelper.hasNestedScrollingParent(); &#125; @Override public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) &#123; return mScrollingChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow); &#125; @Override public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) &#123; return mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow); &#125; @Override public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) &#123; return mScrollingChildHelper.dispatchNestedFling(velocityX, velocityY, consumed); &#125; @Override public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123; return mScrollingChildHelper.dispatchNestedPreFling(velocityX, velocityY); &#125;&#125;","categories":[],"tags":[]},{"title":"注解和序列化","slug":"2019-04-28-注解和序列化","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:16.414Z","comments":true,"path":"2019/11/11/2019-04-28-注解和序列化/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-28-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"[TOC] lambda表达式1.无参时，无返回值 1Runnable runnabl = () -&gt; System.out.println(\"adfa\"); 2.有一次参数 1View.OnClickListener onClickListener = v -&gt; System.out.println(); 3.2个参数 12MyCallback2 myCallback2 = (s, i) -&gt; System.out.println(\"sfasdfa\");myCallback2.call(\"saf\", 2); 函数 是第一等公民了 相当于函数指针 c/c++ 1234567891011view.setOnClickListener(v -&gt; &#123; System.out.println();&#125;);//一行代码的时候，就这样写 view.setOnClickListener(v -&gt; System.out.println()); //带返回值的 Callable callable = () -&gt; \"11\"; Method reference方法引用： Inherited， Retotent默认是 source类型吗 @Repeatable 多个标签 jdk8 的新注解 反射必须是runtime， 可以让注解使用多次 运行时的注解，通过反射来进行获取 提供信息，编译器来进行检查错误。 class类型的，通过注解信息来进行生成 代码和 html文档等 运行时的处理：某些注解可以程序运行时获取 annotationProcessor google内置的 apt， processors注解扫描程序 @AutoService， auto-service gradlew build gradlew clear build 断点调试： 处理注解在 getsupportedAnnotationTypes中生成 build -&gt; gen -&gt; source -&gt; apt 注解的使用场景， source类型，编译器 class类型， apt runtime类型， 在运行时去反射获取 aapt2 ，apk打包过程中就要用到一个工具，aapt2， 编译资源的 Wpa 攻克：annotationProcessor annotationProcessor生成额外文件的规则是在依赖库里定义的，只在编译的时候执行，但是库最终不打包到apk中，所以使用Butterknife这类编译注解框架并不会增加apk的大小 使用： 先创建java libaray annotations, javaPoet ,processors ，创建androidlib api 接口利于扩展，本地定义好，Map&lt;ViewFinder&gt;, ViewFinder就代表了这一类，后面继承的ViewFinder，都可以在这个代码里面使用这个ViewFinder使用好的类 小插曲： Android studio 默认jdk路径 /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home mac本地安装的jdk路径 通过 /usr/libexec/java_home -V 进行查看, 内置的没有源码， 不是内置的路径的jdk有源码 插曲结束 api写到一半写不下去了，需要生成的代码，然后引入javapoet项目，进行一顿修改，把jdk的版本调整到jdk 8，然后javapoet运行正常 然后进行编写Processors，需要导入 12345api project(':annotations')implementation 'com.google.auto.service:auto-service:1.0-rc4'implementation 'com.google.auto:auto-common:0.10'api project(':JavaPoet') javapoet的基本使用 $T 会进行映射，自动import声明 $S 代表一个string ClassName： 可以识别任何的声明类 $N 可以应用另外一个通过名字生成的声明。 Modifiers 创建接口和抽象类 Constructors 可以用来创建构造函数 Parameters 创建参数，或者使用类 MethodSpec 类中addParameters Fields 创建枚举类型： typedec.enumBuilder() $L通过$L引用匿名内部类 默认返回值是void，所以methodSpec中的returns不是必须要写的 方法一定要有 addModifiers， 不然会报错 modifiers [] must contain one of [abstract, static, default] 如何跟大佬交流 遇到一个坑，就是在写完Processor的时候，没加resources这个，就不能生成apt文件，哎，弄了半小时，终于可以生成代码了，到时看看，不用这个可以生成代码没，先往下做 解决不能进行AutoService 不能进行启动Processor多个的问题； 编写好bindview gradlew clean build 通过这个命令进行看processor编译，然后打印 1234ElementKind kind = element.getKind();TypeMirror typeMirror = element.asType();List&lt;? extends AnnotationMirror&gt; annotationMirrors = element.getAnnotationMirrors();System.out.println(\"kind: \" + kind + \" typeMirror: \" + typeMirror + \" annotationMirrors:\" + annotationMirrors); 结果： kind: FIELD typeMirror: android.widget.TextView annotationMirrors: @com.sdxxtop.annotations.BindView(2131165325) 12345 variableElement.getSimpleName() 结果： mTextView variableElement.getEnclosingElement() 结果:com.sdxxtop.annotationstudydemo.MainActivity这玩意是关键啊 123TypeName.get(hostElement.asType()).getClass() 不能 = hostElement.asType() com.sdxxtop.javapoet.ClassName这个是ClassName 引用： glide为什么可以同步生命周期 看懂编译注解annotationProcessor和kapt","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android 注解和序列化","slug":"android-注解和序列化","permalink":"http://zhousaito.top/tags/android-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"Zhousaito"},{"title":"4月份的总结2","slug":"2019-05-02-4月份的总结2","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:24.322Z","comments":true,"path":"2019/11/11/2019-05-02-4月份的总结2/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-05-02-4%E6%9C%88%E4%BB%BD%E7%9A%84%E6%80%BB%E7%BB%932/","excerpt":"","text":"{:toc} java多线程和线程池多线程1：java天生就是多线程的java的main方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，实际上java程序天生就是个多线程程序，因为执行的方法是一个名称为main的线程。 123456//通过这个代码可以获取到当前的线程数量ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); for (ThreadInfo threadInfo : threadInfos) &#123; System.out.println(threadInfo.getThreadName()); &#125; Monitor Ctrl-Break //监控 Ctrl-BreakSignal Dispatcher //分发处理发送给jvm信号的线程Finalizer // 调用对象finalizeReference Handler //清除 reference的线程main // 用户入口线程 2：线程的启动与中止启动的方式 Thread ， Runnable和callable start() Suspend(), resume()和stop()， 但是这些api是过期的，线程调用suspend()，调用后，线程不会释放已经占用的资源（比如锁），如果不保证线程正常释放，可能没有给予线程释放工作的机会，因此会导致程序可能工作在不确定的状态下。 Thread.interrupted()和Thread.currentThread().isInterrupted()的区别 Thread.currentThread().isInterrupted():是一个很正常的方法，就是判断线程的状态，不会做出什么改变 Thread.interrupted()会将状态重置，如果是 false的情况下，就不会重置状态，因为就是调用后，让这个线程。感觉线程重新获取了生命，所以后面调用Thread.interrupted()，不会将状态重置了，除非重新调取 Thread.currentThread().interrupt(): 1234567891011121314151617public static void main(String[] args) &#123; Thread thread = new Thread(); thread.start(); Thread.currentThread().interrupt(); //如果这行代码没有写，第一次也是false System.out.println(\"第一次返回的值\" + Thread.interrupted()); System.out.println(\"第二次返回的值\" + Thread.interrupted()); System.out.println(\"第三次返回的值\" + Thread.interrupted()); System.out.println(\"第四次返回的值\" + Thread.interrupted()); System.out.println(\"第五次返回的值\" + Thread.interrupted()); &#125;结果：第一次返回的值true第二次返回的值false第三次返回的值false第四次返回的值false第五次返回的值false 这就充分解释了，interrupt是协作式的，不是强制式，这样就比较安全，可以正常释放线程的一些资源 3: 处于死锁状态的线程无法通过interrupt中断草稿： 写一个基于线程池的例子，就是下载文件。可以自己进行网络请求封装，等等一些操作。可以网络查找一下","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android 总结","slug":"android-总结","permalink":"http://zhousaito.top/tags/android-%E6%80%BB%E7%BB%93/"}],"author":"Zhousaito"},{"title":"4月份的总结","slug":"2019-05-01-4月份的总结","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:20.656Z","comments":true,"path":"2019/11/11/2019-05-01-4月份的总结/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-05-01-4%E6%9C%88%E4%BB%BD%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"content{:toc}复习内容 gradle使用 jvm gradle使用 gradle是一种自动构建化语言，目前是android的默认构建工具，是一个编程框架 一些使用命令： gradlew clean clean项目 gradlew build 构建项目 gradlew assembleDebug or gradlew aD 编译并打包Debug包 gradlew assembleRelease or gradlew aR 编译并打release包 gradlew installRelease or gradlew iR release模式打包并安装 gradlew installDebug or gradlew iD Debug模式打包并安装 gradlew uninstallRelease or gradlew uR 卸载Release模式包 gradlew uninstallDebug or gradlew uD 卸载Debug模式包 需要说明的是，有些可以叠加使用 gradlew clean build —info &gt; bugTags.log grooxy语言 def 关键字：返回值 String: 分两种类型 groovy.lang.GString , java.lang.String List: 定义 def value = [“a”,”c”, “b”]; value[0] = 4; 默认是ArrayList ​ 如果需要 LinkedList value = []; 这样就强制为了 LinkedList了 Map： def value = [“a”: “str”, “b”: 1] 这里的map是个 []的，不是 {} Range：范围值 metaClass: 在groovy运行期间使用metaClass添加方法和属性 闭包： 123456&gt;def listener = (&#123; -&gt; println(\"click on\") &#125;)&gt;演变成：&gt;def listener = &#123; -&gt; println(\"click on\") &#125;&gt;def listener = (&#123; println(\"click on\") &#125;)&gt;再演变：&gt;def listener = &#123; println(\"click on\") &#125; gradle的执行流程 初始化界面：解析settings.gradle来获取模块信息 配置阶段：配置每个模块，构建task树 执行阶段：执行任务 project相关的api getRootProject: 获取根project getAllProjects：获取所有Project getSubProjects：获取所有的子project allProjects：遍历所有的project subprojects：遍历所有子project 属性相关的API hasProperty：检测属性是否存在 findProperty：查找属性 自定义property： 命令行定义属性 ： gradle build -P pro = 100 通过project.ext定义参数 12345ext.a = 1或者：ext &#123; a = 1&#125; task相关的api getTasks: 获取当前project所有task task 创建一个task、 文件相关的API file： 获取文件 fileTree: 获取文件夹 getBuildDir：获取build文件夹 gradle生命周期API beforeEvaluate： 配置阶段开始之前 afterEvaluate： 配置阶段结束 当走到这里，所有的task的配置都已经完成，然后可以在这里加入自定义的task gradle.buildFinished：执行阶段结束 其它api 执行外部命令 exec：执行外部命令；是project中的 mac的执行 1234 &gt;project.exec &#123;executable 'bash'args '-c', cmd &gt;&#125; windows执行方式 1234 &gt;project.exec &#123;executable 'cmd'args '/c', cmd &gt;&#125; Task gradle很重要的一个东西 task定义 task myTask { ​ println “myTask” } 最后一个参数是闭包，所以这里省略了圆括号 可以通过下面方式创建 project.tasks.create(name: “myTask”) { ​ println “myTask” } task的基本信息配置 1234567task MyTask (a: \"a\", b: \"b\") &#123;println \"$a和$b\"&#125;或者task MyTask &#123; a \"a\" b \"b\" println \"$a和$b\"&#125; Task依赖 123456task A&#123; &#125;task b &#123; dependsOn A&#125; 我们需要执行b的时候会先执行A，然后再执行b task执行 12345678910task myTask &#123; println \"1\" doFirst &#123; println \"2\" &#125; doLast &#123; println \"3\" &#125;&#125; 实战自定义plugin 1todo JVM1:虚拟机的发展 go语言去实现jvm是比较简单的 hotSpot VM 目前使用最广的虚拟机； 我的mac上面的sdk用的就是类的 JRockit VM 号称是最快的java虚拟机； J9 VM ibm公司的 Dalvik VM google给android使用的虚拟机 未来的java技术 模块化 OSGI 模块化 微服务 混合语言 （java ， scala） 多核并行 （函数式编程） 丰富的语法 64位 更强的垃圾回收 回收 gb级别的， jdk11是gb级别的。 2：内存的划分线程间共享的：堆和方法区 线程间独享的： 程序计数器，虚拟机栈，本地方法栈 ​ 虚拟机栈中有-&gt; 栈帧：局部变量表，返回地址，操作数栈，动态连接 独享就是当线程结束了，内容也随之释放了，没有线程安全问题；共享的话，就引入了锁这些问题，不是线程安全的 程序计数器：指向当前程序的字节码，线程间需要切来切换去，唯一个没有OOM的地方 为什么java要是用栈来进行方法调用：因为非常符合java间方法的调用 javap -v Test.class &gt; 1.txt 然后获取字节码 局部变量表：只能存放32位的数据，放一些方法内部的一些变量，如果是64位，就会使用高低位占用两个也可以存放下来。存放基本类型的变量数据和对象的引用 操作数栈：存放我们方法执行的操作数。它就是一个栈的结构，进行一些数据的计算 动态连接：用来多态使用，java动态运行性，需要类加载运行时，才能确定具体的方法 返回地址：程序正常执行的时候，就会执行到这里，然后返回 本地方法栈：各虚拟机自由实现线程的共享区域方法区/永久代 用于存储已经被虚拟机记载的类信息，常量（”123“，”asfda“等），静态变量（static变量） Jdk7 以及以前： -XX:PermSize: -XX:MaxPermSize; jdk1.8 以后： -XX：MetaspaceSize： -XX：MaxMetaspaceSize jdk1.8 以后大小就只受本机总内存的限制 堆 几乎所有的对象都分配在这里，也是垃圾回收发生的主要区域，可用一些参数进行太调整 … 直接内存 不是虚拟机运行时的数据区的一部分，也不是java虚拟机规范中的定义的内存区域；但是受本机总内存限制。也会产生OOM 站在线程的角度来看线程的私有内存区：随着产生和消亡，因此不要过多考虑内存回收的问题，编译时就确定了所需内存的大小。 深入辨析堆和栈功能 以栈帧的方式存储方法的调用过程，并存储方法调用过程中基本数据类型的变量，已经对象的应用变量，其内存分配在栈上，变量出了作用域，就会自动释放。 而堆内存用来存储java中的对象，无论成员变量，局部变量，还是类的变量，指向的位置是在堆中。（这个怎么画图，应该是对象模型图？？？） 线程独显还是共享 栈是属于单个线程所有，相当于线程的私有内存 堆中的所有对象，对所有线程可间。 空间大小 栈的空间远远小于对内存 当栈进行无限制的递归调用的时候，会出现OOM，方法的执行要打包成栈帧，所以天生实现同一个功能的时候要慢，比如树的遍历递归，比较简单，但是比一般的实现要慢，一般的实现代码比较复杂，但是速度快 对象的分配虚拟机遇到一条new的指令时： 1）检查加载： 先执行相应的类加载过程。 2）分配内存： ​ 指针碰撞：确定一块内存是否能存放下这个对象，如果不能，就继续往下找，找不到就进行垃圾回收了，在eden去就进行mirror Gc 等。这个分配过程就是指针碰撞。 ​ 空闲列表：如果java堆中的内存并不规整的，已使用的内存空间相互交错，那就没有办法简单的进行指针碰撞，虚拟机必须维护一个列表，记录那些内存块可以用，那些不可用，在分配的时候从列表中找到一块足够大的空间划分给对象，并更新列表上的几率，这个分配方式称为”空闲列表“。 选择哪种方式由java堆是否规整决定了，还有和采取的算法有关系 并发安全 除如何划分空间外，还要考虑并发安全的问题。 cas操作，如果内存分配失败，会进行重试， bab问题 分配缓冲 TLAB，Thread local allocation Buffer，TLAB， 本地线程的分配缓冲，提高分配效率，如果容量不够了，就重新重Eden区域申请。 内存空间初始化 就是给 没有初值的成员变量，进行初始值设定 设置 接下来，虚拟机堆对象进行必要的设置，例如这个对象是那个类的实例、如何找到类的元数据信息，对象的hash码，对象的GC分带年龄等信息。这些信息存放在对象的对象头之中。 对象的初始化 在上面工作完成后，从虚拟机的角度来看，一个新的对象已经产生了，从程序的角度来讲，才刚刚开始。在程序员new了之后，对象就产生了。 对象的内存布局在hotSpot的虚拟机中，对象在内存中存储的布局分为三块区域：对象头，实例数据和对齐填充。 对象头包括两部分形象，第一部分用于存储对象自生 栈上分配 字符串存放在什么位置 基本数据类型存放在什么位置 对象的内存模型 学习垃圾回收的意义java与C++等语言的最大技术的区别：自动化的垃圾回收机制 为什么要了解GC和内存分配策略 1、面试需要 2、GC对应的 3、写代码有好处 栈：堆中的生命周期是跟随线程，所以一般不需要关注 堆：堆中的对象是垃圾回收的重点 GC案例自动回收机制也有失败的时候oom 新生代配置新生代大小配置参数的优先级： 判断对象的存活引用计数法：快，方便，实现简单，缺点：对象相互引用的时候不好判断 虚拟机栈（栈帧中常用的引用变量表）中引用对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象 各种引用强引用：new出来的对象都是强引用 软引用：softWeakReference 软引用即将发生oom的时候进行回收 弱引用：weakReference 发生GC的时候就会被回收，不管内存足不足，都会被回收 虚引用：垃圾回收的时候会通知一下 草稿： 异常处理器表 Class.forName() 和 ClassLoader加载类的区别 Class.forName()：本质是通过ClassLoader加载的，但是会进行一些初始化操作，静态代码块的操作。 ClassLoader：只是把类记载到虚拟机中，不会有任何初始化操作 在Java的反射中，Class.forName和ClassLoader的区别 final关键在内存中的常量区，但是和static不同的是，static类进行加载后，就会被初始化，而final的是在用的时候初始化 Final of Java，这一篇差不多了 native堆还是在用户空间，是存在数据从内核到堆外空间的拷贝的 native堆是在用户空间堆外内存 1次拷贝堆内存 2次拷贝 空间担保 优化一下简历 产考gradlew常用命令 gradle闭包的官方文档","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android 总结","slug":"android-总结","permalink":"http://zhousaito.top/tags/android-%E6%80%BB%E7%BB%93/"}],"author":"Zhousaito"},{"title":"自定义View","slug":"2019-05-06-自定义view","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:28.305Z","comments":true,"path":"2019/11/11/2019-05-06-自定义view/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-05-06-%E8%87%AA%E5%AE%9A%E4%B9%89view/","excerpt":"","text":"[TOC] View基础 getLeft(), getRight(),getTop(),getBottom(),是相对于父view的位置 view的左边距离父view左边的距离 view的右边距离父view左边的距离 view的顶部距离父view的顶部的距离 view的顶部距离父view的顶部的距离 点击事件的距离： 触摸点相对于其所在组件坐标系的坐标 event.getX() view自己左边的距离 event.getY() view自己顶部的距离 触摸点相对于屏幕默认坐标系的坐标 event.getRawX() event.getRawY() 角度增大是逆时针， 颜色值： 123int color1 = Color.argb(147,22,33,33);int color2 = Color.GRAY;int color3 = 0xffffddaa; 先measure ，然后OnMeasure 在unspacified 默认的 宽/高=默认大小 ，会去判断是否有背景大小 显示布局， 贝塞尔曲线 b(t) = p0 + t(p1 - p0) = (1-t)p0 + tp1 , 0&lt;=t&lt;=1; 一阶的没有控制点 所以三阶是2个控制点，三个点就可以确定了，控制点和结束点，贝塞尔曲线 paint 画线的话 用stroke for循环耗时 和 减少个for循环进行判断 onMeasure - 》 onSizeChange Path , 贝塞尔曲线，canvas 1234567&gt;mPath.reset(); //这个就相当于重新将画笔放到0，0&gt;mPath.lineTo(100, 100);&gt;//相当于 ，但是有一点区别，这个不会重置原来画的界面&gt;mPath.moveTo(0, 0);&gt;mPath.lineTo(100, 100);&gt;对称的时候，用宽度- 那边的位移就可以了&gt;后面发现中心点没有找对，所以出现了问题 Kotlin：成员变量问题 kotlin 没有了 三目运算 用 if else 来代替 转Int的时候 用 toInt() 来进行转换 Reified 告别class lateinit var c：String val e: String by lazy { ​ String() } 12345678910111213141516171819202122232425262728293031kotlin 中成员变量应该一开始就确定，进行初始化get的修饰范围，随成员变量的属性走private var c = 1 private get() &#123; return field; &#125; private set(value) &#123; field = value &#125; 基本类型： 指定一个值就可以了 lateinit 不能作用在8的基本类型上roomList?size ?: 0 //当list是空是就返回0deiliget运算符：infix 中缀表达式 关键字 可以不用 DSL 里面使用， 代码可读性会降低kotlinjetbrainsreadLine文件操作if 还可以有返回值 注解就相当于打标签， 注解的本质就是动态代理的实现 注解生成对象是proxy0吗 运行时，可以获取属性或方法，进行修改或调取 依赖注入， dagger2和butterknife有一定的区别 什么是依赖？ 就是一种需要，需要这个对象； 人需要买房子。 依赖倒置： 复习六大基本原则， 能用父类的地方用父类，如果有改变的时候，就要修改原来的源代码， 高层模块不应该有底层的依赖，，细节应该依赖抽象 上层 控制下层，就是依赖倒置了。 抽象约束行为，具体实现行为， 面向抽象编程，面向接口编程， 依赖倒置 控制反转。 person只要关系功能，不关心实现， 依赖-）依赖倒置-》控制反转（父类的应用，传子类对象） 构造方法注入： set方法注入： 接口注入： 设计模式：就是六大基本原则的体现 工厂设计模式， Jsr-330 是java的依赖注入的标准 a类型依赖b类型 运行时查找依赖的过程，称为“解析resolving”依赖 如果没找到实例，称该依赖unsatisfied javax.inject 依赖注入 @Inject 方法，构造器，方法或字段 @Provider&lt;T&gt; 结构 Provider 用于类型T的实例 @Qualifier，定义新注解的时候用到它 @Named 基于String的限定器 @Scope，作用域，某个线程有效，某个范围有效 @Singleton， 注入器实例化一次类型，该注解不被继承 依赖注入只能做到解耦性， 程序员的最高境界，就是解耦 保证代码的健壮 灵活 可维护 Dagger2 ： apt技术，生成一些辅助代码，dagger2是dagger的升级版，是square公司出的第一版，然后dagger2是google工程师fork过去，然后重构了。 dagger2单例的原理 @Inject 标记要依赖的变量 2，标记构造函数，来为标记了@Inject的变量 @Module：提供依赖第三方的，需要提供依赖的构造函数，是三方，提供第三方的依赖 @Provides： 预先提供依赖的对象给标注了@Inject的变量赋值 @Inject 只能标志一个构造方法，编译的时候会报错 构造方法，也是可以的 如果既有inject的也有module，优先使用module的 提供两个一样类型的， 限定符 module也使用限定符，来进行注解 @Qualifier 可以当两个一样类型的时候，可以使用到 @Named就是限定符的一种 scope全局引擎 同一个范围的，对象只会创建一次；使用了范围构造，就只会调用一次了， 提供第三方 注射器也要有个范围， doublecheck双重检测的方式来进行的 mv vm mvp Scope 不能放在module 类上面 ，放在provides的方法上面 @Inject 构造方法会生成对应的 factory 就是 类名_Factory @Inject 成员变量 就会生成 对应的注解器_MembersInjector @Module &amp;&amp; @Provides 注入第三放对象，会生成类名_方法名大写Factory 的这样的类 具体当在对应的注入类中初始化的时候用到 12345678//就是注入容器的Builder方法调用，初始化的时候调用private void initialize(final Builder builder) &#123; this.getActivityProvider = DoubleCheck.provider(ActivityModule_GetActivityFactory.create(builder.activityModule)); &#125; 在scope下，让后就通过这些factory进行创建独一的对象 1234567891011//就是注入容器的Builder方法调用，初始化的时候调用private void initialize(final Builder builder) &#123; this.getActivityProvider = DoubleCheck.provider(ActivityModule_GetActivityFactory.create(builder.activityModule)); this.homePresenterProvider = HomePresenter_Factory.create(MembersInjectors.&lt;HomePresenter&gt;noOp()); ...&#125; ``这个符号是强行将不合法的改为合法的 在Kotlin中可以用反引号解决关键字冲突的问题，可以强行将一个不合法的字符变为合法。 cookie HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 Android 使用Okhttp/Retrofit持久化cookie的简便方式 12345var e: ApiException? = null局部变量声明@JvmOverloads //重载的标志getRetrofit(baseUrl: String, provider: NetProvider? = null)两个参数的方法竟然可以传一个值 okhttp3 interceptor 原理 Okhttp3 https标准的访问 Okhttp3 websocket java网络这一块 JAVA基础知识之网络编程——-使用MutilcastSocket实现多点广播 应用层， 传输层， 网络层，网络接口层 Tcp端对端的传输 应用层，表示层，会话层 Seq =0Seq=0 ack = 1Seq =1 ack=1 HTTP 的3次握手是准备资源的过程；HTTP 的4次握手是释放资源的过程 Tcp 三次握手：tcp目的是为了通讯 ，客户端和服务端都要确保，能读能写 断开，也可以服务器断开，也可以客户端断开 fin + 1 ack 服务端还有数据没发完，当发完的时候，然后 在发送 服务器端的 fin 数据，所以分两次 http2.0 2015出现的 socket去请求，可以保持这次socket，可以下次拿来使用，如果是connecttion：keep-alive 就是可以进行长连接，通信 spdy google提出来的 okhttp也实现了这个，被http2.0代替了 http2.0，和http.1x想是一个全新的一个协议了。1.x的时代是字符串通信。2.0是二进制通信了 \\r\\n 读取449行，然后就成功响应了 builder，okhttp有责任链模式接口设计是否合理 http有一种keepalive connections的机制，可以在传输后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手 责任链设计模式 1、开闭原则 对扩展开放，对修改关闭 多使用抽象类和接口2、里氏代换原则 基类可以被子类替换 使用抽象类继承，不使用具体类继承3、合成复用原则 要依赖于抽象，不依赖于具体 要针对接口编程，不根据实现编程4、接口隔离原则 使用多个隔离的接口，比使用单个接口好 建立最小的接口5、迪米特法原则 一个软件实体应尽可能少地与另一个实体发生相互作用 通过中间类建立联系6、依赖倒转原则 尽量使用合成/聚合，而不是使用继承 尽量使用合成/聚合，而不是使用继承 单一职责：一个类就干一个事情里氏替换：能用到父类的地方就用父类（这个指抽象类）依赖倒置：能用接口的地方就用接口（这个指接口）开闭原则：对修改关闭，对扩展开放接口隔离：尽量把接口拆分成多个接口，让接口不那么的臃肿迪米特（也叫 最小知识）：一个实体尽可能少的更另一个实体接触 单一职责和接口隔离，感觉是有点像，但是接口隔离注重接口；单一职责重点值 职责单一里氏替换和依赖倒置：也差不多，只不过一个是指抽象类，一个指的是接口 序列化 如果传输用serializable进程之间的通信，传输数据： AIDL，contentProvide 远程 rpc 也可以数据通信 内核内存共享 xml json protobuf 都是序列化的一个手段，不能叫序列化吧序列化：将对象或数据结构转换成二进制的过程 反序列化， 谷歌出的序列化方案，可以压缩32位数据，很多im传输用protobuf来实现的 为什么activity之间是同一个进程为什么还要序列化？？ ams是跨进程的。 序列化只对变量进行序列化，针对于对象，不针对方法进行序列化 序列化协议： 技术层面：是否要跨平台，跨语言，通用性问题 流行程度： 健壮性：xml json protobuf 成熟度不够 性能： 空间和时间方面： 空间开销： 时间开销：复杂的序列化协议会导致较长的解析时间，这可能会使用序列化和反序列化阶段成为整个系统的瓶颈， 可扩展性/兼容性 安全性/访问限制 Protocol buffers 19000 -19999 不能使用，是保留字段 32，这里是4个字节原因，会压缩32位 压缩算法在里面，压缩算法32位 proto的目录Base-128 整形可变长编码 rpc 调试 rpc效率优先 protobuf 32位的可以压缩合成一个，几十倍的压缩率， transient 修饰的不需要进行序列化。静态变量不会进行序列化。需要一个无参的构造方法 不加入 serialVersionUID ，不好兼容了，如果修改信息了，然后就会又根据类进行反序列化成新的 serialVersionUID了，兼容性可能不好 Externalable 也是实现Seralzible接口，只不过要手动实现里面的方法 .java的文件，jvm，怎么知道是java文件， 也有个魔术，文件头，对象头 objectStream里面，会进行反射 writeObject 可以用于特殊需求 arrayList 中有 wirteObject实现了，但是elmentData进行了序列化，因为elmentData，大部分会为空，所以为空的就不进行序列化，只对有效数据序列化，这是jdk序列化的优化。 序列化的坑： 同一个引用只会写一次，要做一些处理 oos.wirteUnshare ,或者重置流 子类实现了序列化，父类实现 serializable 类的演化，反序列化的时候不会报错，但是会没有值 枚举类型 序列化单例对象：打单机游戏什么的可能有需求要存单例对象。 serializable，很多反射，会产生很多中间变量，导致大量的内存碎片， parcel parcelable，就是打包的意思 parcelable，只是存在内存中，内存中序列化的方案，硬是要写硬盘也可以 parcelable 性能方面 存文件用serializable， 只是跨进程用parcelable SQLite与SP binder，的缓冲区是有限制的，一般默认一个进程只有16个binder， xml：是基于树形结构 操作频繁，文档较小，动态添加，删除节点用DOM解析 js解析html就是dom解析 知识储备 版本问题， 移动端不怎么相关的但是是互联网端的：负载均衡 Keepalives -&gt; okhttp复用池 找姐夫说一下，自己公司现在是个什么状态，听听他的意见，不一定要全听，但是要去提取有用的条件 依赖倒置-》 在构造方法里面直接用 父类的引用 = 子类对象 控制反转-》构造函数或者方法用父类的引用，外面传子类的对象，相当于内部的对象，有外部提供了，不在是自己亲自创建了 毒瘤应用-进程保活 jsonwriteObject 和 readObject 原理， 时序图很重要 json的网络请求 json是来传输的 json小于100m，数据多的时候用 protobuf 1JSONObject //基于文档驱动的，会全部加载到内存中 retrofit有默认解析吗？默认是gson解析吗？ 文档驱动：就是一次性把文档加入进去 gson基于事件的启动方式， gson，什么时候有隐藏bug了，忘记听了 jackson解析也是基于事件驱动， jackson效率比gson高，配置一下也可以不用一一对应可以进行正常解析 FastJson：有隐藏的bug 切片 ， 按照 “\\n\\t\\br” 来进行切片 算法匹配，词法分析 “{” “}” 这种符号，是词法分析然后再语法分析jsonDe getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。 具体编码如下： ArrayList 增删，效率都不高，因为伴随的System.arraycopy这个操作符很低 Kotlin 中 实现 接口 ，没带括号，而抽象类，需要个括号 1class MyLogiMouse(mouseName: String, override var j: Int) : LogiMouse(mouseName), USBInputDevice Abstract 类默认是 open的，如果不是抽象类，需要添加open才能被继承 如果方法需要被复写，如果不是abstract的，就需要被添加open kotlin中属性也能进行复写 接口代码 by 接口代理 当名字相同的时候。 internal 模块内可见 object 就是单例的 伴生对象和静态方法 @JvmStatic 这样java就可以正常的静态方法调用了 @JvmOverloads这个重载方法 jvm函数签名，默认参数和方法重载可以相互转换 在java中看到默认参数相当于重载， 反例就是 remove(Object o) ， remove(int i) 字符串很多方法 扩展成员：二次加工 加了个 什么点 fun String.multiply() {} 123set(value)&#123; field = value;&#125; lazy 前面的变量名字实际就是个傀儡 kotlin 的锁， 怎么数据源排序 （）== data class 就是 componentN的调用","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android 自定义View","slug":"android-自定义View","permalink":"http://zhousaito.top/tags/android-%E8%87%AA%E5%AE%9A%E4%B9%89View/"}],"author":"Zhousaito"},{"title":"file和stream","slug":"2019-05-14-file_stream操作","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:32.840Z","comments":true,"path":"2019/11/11/2019-05-14-file_stream操作/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-05-14-file_stream%E6%93%8D%E4%BD%9C/","excerpt":"","text":"[TOC] File和StreamJava io, okio, apk加固 okio封装socket 并发的 io 学习 整体设计要有自己的理解， i/o的发展历史， 文件-》 FileOutputStream-》BufferedOutputStream -》 DataOutputStream可以具体获取字节类型 传递上下文， view相关的用activity的context其他用getApplication()， 代理模式-》 对方法增强 代理模式对外部增强 装饰者设计模式-》 继承并进行扩展 包含 菱形的那个标志，是包含的意思 装饰设计模式，分析context 如何去学习， 为了装饰，所以把read抽象了起来， FileDescript —&gt; 是newIO出来的 FilterOuputStream：就是为了持有OutputStream的装饰类 Decorator FileOutputStream BufferOutputStream-》 flush 进入才进入文件，当buffer满了也进行了一次flush，flush就是一次性把剩下的刷入到文件中。 flush写入文件， 在close的时候会自动flush进去 实现了closeable，重写close方法，可以自动释放 字符流和字符流，有个readLine() 这是核心区别 readNewLine FilterWriter 是 SinglePerson类，跟FilterOuputStream不一样 字符有编码格式的，所以字符尽量读的时候用UTF-8来进行读写 FileWrite FileReader 只是转换用的 pipedWriter 非流操作 File RandomAccessFile 指哪打哪 setLength 设置文件的长度，设置一个空文件长度 Seek 只是移动到10000，文件的长度还是0 协变， out-》 只读的 逆变： in是只写的 api processor anntation 类名获取， 对象去拿 ClassName getDeclareMethod -&gt; 获取当前类的所有方法 公开方法，静态方法，单例进行找hook点 hook就是单例，或者 找hook点，然后去代理它 通过反射动态代理 分析hook点， 动态代理，还是静态代理 反射做什么呢 获取到getDefault 的原始对象 使用动态代理 通过activity，最骚的是当前线程 classloader， 获取当前线程的 融入到framework里面 驱动装载可能会报找不到类异常？？？ 欺骗ams，的检测，然后替换 Window 是什么 Window 和 activity 是什么关系 Window windowManager windowManagerService 如何通过WM 添加WIndow Dialog 传入context ，如果你传入的是appcontext 会报错。 悬浮窗口： window分为两个部分， 在应用进程内，wm处理后，然后再交给 wms处理 window是个抽象的概念， window所有的view管理，怎么把view添加上去呢，怎么删除viewn呢 windowManager来管理这些。 PhoneWindow—&gt;是具体window的实现类 PhoneWindow由windowManager，进行管理的 ViewManager接口 有 -&gt; 添加view， 更新view， 删除view windowManager，继承了ViewManager，具体实现类 WindowManagerImpl 最终 通过 WindowManagerGlobal来进行跟WMS通信 DecrView 布局参数： type，窗口类型：三种类型的窗口， 应用窗口的，子窗口，系统窗口 1-99， activity， 视图的最下层 子窗口， dialog， 1000-1999 系统window，如：toast和系统状态栏， 2000-2999 需要权限声明相关的，最上层 window的flags，事件穿透 window的softInputMode， 控制键盘弹出，其实 是系统窗口发生变化了 设置window的type， 悬浮窗口： 1.系统级别的 type， toast，状态栏什么的，用的时候会需要权限 校验，android N 系统窗口，权限验证 2.应用级别的 addwindow的时候需要权限验证 wms是其他服务初始化的 wms是管理窗口的 所有的view显示，需要在 DisplayThread.getHandler 进行处理 PhoneWindowManager里面进行权限控制 类似于相应码 设置成type_application 为2的type 达到目的，代价最小就好了。 显示在activity上面用type_application就可以了 system_alert_window 权限写入 还要设置flags 时间传递有关系 FlagNotfocusable， nottouachable gravity 属性 添加，更新，移除 WM.添加view的过程 ActivityStackSupervisor RealStartActivityLocked ClientTransaction， 看代码，查找关键点 PhoneWindow 换肤公开课，有讲到。 子view都准备好了，没有显示 LounchActivityItem ResumeActivityItem - &gt; hanlde ResumeActivity global添加， ViewRootImpl view树的根， 测量，布局 ， 子线程不能更新ui在ViewRootImpl中判断的 ViewRootImpl 跟WMS通信， IWindowSession addtoDisplay -&gt; Session.java里面去了 一个应用只有一个WindowManagerGlobal， 子窗口一定要有个token，然后显示 最终给 Surface 的服务 问老师个问题 三星开放出来的系统权限api 也有静默安装的 那些sdk怎么实现的 是不是也和这个技术有关系 CGlib，如果方法是final类型，就没办法代理了 Hal层会讲不 不知道这个是什么东西。 hal层，就是硬件抽象层 PKms也是跑在System_server进程中的 负责android系统中的安装 升级 卸载 对外提供统一的信息查询工呢，其中包含匹配某个intent的 activity，broadcast，service pkms，在 引导服务中启动的， 继承IPackageManager.Stub ServiceManager，里面去了 SystemServiceRegistry， 所有的service，其他binder，都用注册到ServiceManager中 所有binder， 所有的binder都能拿到它，地址为0的地址 getIServiceManager()就是获取了binder大管家 installPackagerManagerAsUser() SystemServer是系统服务进程，里面启动很多系统service。通过BInder跨进程通信的方式来让app使用这些服务。ServiceManager是sdk提供的各种服务的大管家，通过get方式来拿service SystemServiceManager里面一大把的服务 ServiceManager.addService() PowerManagerService 一种继承SystemService 添加到ServiceManager.addService() ,相当于window上的注册表 真正的是在C++层的。 到ServiceManager里面进行注册 stub接收器 kerner那一块 serviceManager大管家 ​ PackageManagerService : 构造方法真1000行代码。 ​ 系统启动 会 apk安装的过程，所以手机应用多，速度越慢。 ​ shareUserId （uid） 打电话的apk， ​ 系统默认安装，设置为android.uid.system， 要求要有系统签名，然后可以静默安装 ​ ​ PKMS.scanPackageLI() -&gt; manifest文件扫描，存起来 ​ installPackage 静默安装 ​ aapt，资源映射表。 ​ MergedManifest ​ 要签名才能进行安装 ​ v1 v2 v3签名的区别 ​ 需要android.uid.system ​ 静默安装： rom定制的，需要系统的厂商，可以进行静默安装。 ​ 智能安装：就是不用自己点安装，vivo，oppo需要密码 ​ apk打包过程，系统服务注册流程 ​ Dropbox 日志系统。 ​ handler： ​ 跟web开发的ajax有异曲同工之妙 ​ 大大降低了开发难度​ 几乎看不到多线程死锁问题 内存共享： 都是内存共享：handler：核心思想，就是内存共享 mmap final static 一个线程 -》 另一个线程的数据， 线程间最终的通信是内存共享 Message /messageQueue /message/looper/ThreadLocal 内存管理设计思想优秀。 为什么没有wait和notify变量 线程通信 handler包揽所有的线程通信 最小知识原则：handler， 最后入队到了messageQueue messageQueue.next Looper.loop() 是thread调用的。 Looper.prepare() 装饰的话，就要装饰共有的接口，叫装饰者设计模式线程里面的单例如何实现线程数据的隔离， 线程的上下文独一无二 ThreadLocal java容器， 剑指off的java面试题讲解真的不错，bat的面试官讲解 ThreadLocal 里面用数组来替换了map 就是 hash[index] hash[index + 1] ​ key value ​ hash[index] hash[index + 1] 通过静态来进行，确定单一的hash值。整个系统都只有一个hash值 AtomicInteger 一一对应的，就可以用ThreadLocal gc的时候会有标记整理算法，但是gc得时候会短暂停顿，甚至new的多了，内存扩大，会有内存抖动现象，而且从代码角度，我们一般减少不必要的内存开销 getParent().requestDisallowInterceptTouchEvent(true);就可以 dispatchTouchEvent进行事件分发的 viewGroup里面没有事件消费 onTouchEvent 事件消费 如果onTouch返回值为true，点击事件就不在执行了 aessablity是一个虚拟点击，虚拟点击可以使用 dispatchTouchEvent onTouchEvent. playSoundEffet()是个发声音的，这个可以进行自己进行修改 1.安全点击，什么叫不安全点击 2. onTouchEvent onClickListener在up里面的点击事件 onTouch 拦截了，就不会有onClick了， ViewPager -&gt; onInterceptTouchEvent拦截方法 Activity# dispatchTouchEvent-&gt;PhoneWindow# superDispatchTouchEventSuper.DispatchTouchEventViewGroup#DispatchTouchEvent 在android中，是activity的dispatchTouchEvent方法 PhoneWindow中进行查找 VIew#dispatchTouchEvent，指的是处理事件的的dispatch的view去调取 down事件 :move:up事件: buildTouchDispatchChildList()—&gt;对子view排序 buildTouchDispatchChildList使用了什么排序？？？ 点击的位置的判断 1.人脸识别算法，举手识别率，前三排 智慧罗庄：事件，权限， 安迪网格化-&gt; H5（商城，共享单车） 硬件测试 需要长时间测试。 new 方向， 升降式的摄像头。UV光，个性化。解决问题。 人脸采集webview封装 down move 阿斯顿发","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android file","slug":"android-file","permalink":"http://zhousaito.top/tags/android-file/"}],"author":"Zhousaito"},{"title":"activity生命周期与task启动方式","slug":"2019-05-19-activity生命周期与task启动方式","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:38.433Z","comments":true,"path":"2019/11/11/2019-05-19-activity生命周期与task启动方式/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-05-19-activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8Etask%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/","excerpt":"","text":"[TOC] 从四个视角理解android activity启动模式操作系统角度，Task是什么 用户的角度 学东西，要总体来学，要以架构师角度来学东西 一开始学，都是学习4大组件 task是可以跨应用的， app是静态的，task的动态的， task是属于android操作系统的 android service有任务栈吗，或者说service怎么存放的 新建，startActivity 要从结构上去学习，就会 静态的fragment和动态的fragment 如果activity启动不成功，就不会执行上个界面，onstop onPause（）不能做耗时操作，影响启动速度 standard不是每次都100%新建， launch启动的时候，如果已经存在了，就不会再创建了。 flag = 0x10200000 每个页面展示不同的数据 newTask affinity 就是新task名字 affinity 要和newtask标志一起使用 有没有拉起进程的 管道机制 bander机制，binder就跟快递小哥一样， 用户放入到内存空间， copy_from_user 第一次 然后 copy_to_user 这是传统的 binder传输数据：服务端的一个空间，内核空间都是 虚拟空间 实际操作是物理空间，mmap 内存，内存映射 就是数据放到内存，然后内存映射，去取，就是一次拷贝 共享内存是 三个共享化， binder两个共享 c/s架构的，易用性高； 控制复杂 共享内存，在同一个空间，需要同步机制去处理，同步的开销大 同步延迟+内存开销 mmap 资料memory mapping binder 安全性。 pid，进程的id，依赖上层协议，不安全，相当于造假身份证去干坏事，就是用进程id去欺骗 访问接入点是开发的，不安全 为每个app分配UID，同时支持实名和匿名， 加上bean类，要求导包 为什么binderservice就能绑定服务， 客户端如何获取到AIDL的遥控器（句柄）的 通过这个遥控器是如何调到服务端的呢 服务端又是如何 每个服务要有一个aidl与之对应 发送数据proxy 发送数据 接收数据 stub 是用来接收数据的 或aidl对象的方法 LeoAidl.Stub.asInterface(binder) — 》 就会拿到 proxy的对象 服务端，一进来就会初始化，new了一个stub 如果进过判断是因为判断是不是同一个进程 _data 用来存储发送数据，就是调用方法的出入参数 _reply //服务端返回的数据 //就会把客户端线程挂起来，知道服务端返回结果 mRemote.transact() flag 0 - Flag 1 -&gt; 客户端给服务端，服务端不能进行返回 transact后就到binder了 transact 到C里面去了， 可以去查查 服务端， onTransact方法接收处理 binder机制，看framework的源码有一定的理解 c端和 s端是如何捆绑再一起的 getSystemService 闹钟服务，通话服务等， 实际上也是跨进程的， 服务好比房子一样， ServiceManager（相当于android中的间接），其实也是进程间的通信 通过proxy， comtextImpl里面 bindService - &gt; ContextImpl#bindServiceCommon -&gt; ActivityManagerNative.getdDefalut（）-》proxy对象 ActivityManagerNative就是 == stub IActivityManager= ILeoAidl 接口 getService() 获取了 IBinder， 然后返回proxy 我的理解是生成的单独为这个类服务的，所以用内部类，而谷歌的这个是通用的所以单独是个类 调用的是正在的服务 调用到了 activityManagerService。java 调用到真正的服务 ActivityManagerService#bindServiceLocked bringupServiceLocked 1requestServiceBindingLocked 猜 1.进程B，整个进程没有启动 2.进程B启动了，service没有创建出来 2.启动了，也创建了，未绑定，onBInde 4.启动了，也创间了，也绑定了，onbinde 、、app ActiveServices.java 每创建一个进程，都会有个进程，app.thread ，就是activityTHread， 如果启动了，app.thread肯定不为空 23的代码 ActivityThread的 handleCreateService， 通过反射， 创建了服务 binder只能绑定一次，创建一次，如果找到了，可以直接使用， app没有创建 startProcesslocked process.create android是个消息驱动的系统 handleCreateService handleBindService 课后自己手写，实现aidl a 调用系统服务 ActivityManagerNative -&gt; stub - &gt; ontrnsact ActivityManagerProxy -&gt; proxy -&gt; trnsact ActivityManagerSerivce-&gt; stub的实现类 IActivityManager -&gt; AIDL接口 大型登录架构实现 支付宝纳入海量应用 四大主键，和activity启动流程，都是用了binder机制 3358434706 Clinet : 通过 asInterface()-&gt; proxy对象, -&gt; proxy# transact() -&gt; 进行传递，到服务端的 onTransact上-&gt; 因为stub是个抽象方法，被服务端的binder实现了，所以最后调用，服务端的binder实现aidl接口的方法-&gt;最后沿路返回 因为，两边的接口都是一模一样的，所以调取的时候传 个 1，2…n作为方法的标识 app每创建一个进程，都会启动一个 activityThread吗。怎么去验证一下。 activityManagerService: android 7.0： 基于liunx内核开发的， 看两本liunx的相关书籍， liunx内核设计与实现， 深入理解liunx 进程管理，进程调度， io流操作， epoll， 底层读写靠的是这个 Init.rc用户空间和内核空间 之间通信靠系统调用，创建android的进程鼻祖，zygote 然后拉起SystemServer， 加载系统预加载的类，加载服务 ams属于引导服务，然后其他服务。launch服务，启动 引导服务， 核心服务， ​ 然后里面启动了ams -&gt; launcher启动 其他服务 整体概念讲 ​ rpc，rmi，socket和管道 ipc， socket， 管道， 型号量，binder， 共享内存 binder驱动，在内核内存中，通过binder，然后传到另外一个进程 SystemtServer里面有个binder列表SystemtServer的binder地址是固定的，然后拿着这个binder，跟其他binder进行通信0号驱动， serviceManager存放地址，类似于 dns 或 路由表一样的东西，找到serviceManager就能找到所需要的binder asInterface 判断是否在同一个进程， 同进程不走binder了 生成的代码，像动态代理 客户端不能直接访问对象，所以需要代理， 然后都实现共同的接口 android aidl的原理 android 为什么要使用binder， 稳定性，C/S模式，客户端挂了，不影响服务端。 安全考虑：传统的传统的不可靠， binder会调用进程，容易被中间者攻击 系统启动的时候，注册了各种，serviceManager， 通过binder驱动，然后服务端，ontrancsact， LocalSocket,改变进程id等，zygote，复制了一个分身 launch启动应用， ams socket与zygote进程通信， 然后zygote创建ActivityThread activity启动 状态设计模式 AMS家族 xx record android进程模型与优先级 可见进程（对话框弹窗），服务进程（后台进行播放，音乐播放），后台进程（stop状态了），空进程（加快下次创建数据） startActivity的时序图 hook插件话 Instra ActivityThread， AMS hook Activity 的启动 未注册的activity，Activity的 ActivityThread AMS的 applicationThread对象，什么时候被创建的","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android file","slug":"android-file","permalink":"http://zhousaito.top/tags/android-file/"}],"author":"Zhousaito"},{"title":"broadcoast发送与接收","slug":"2019-05-26-BroadcastReceiver发送与接收的过程","date":"2019-11-11T05:40:29.457Z","updated":"2019-11-14T00:13:52.786Z","comments":true,"path":"2019/11/11/2019-05-26-BroadcastReceiver发送与接收的过程/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-05-26-BroadcastReceiver%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B/","excerpt":"","text":"content{:toc}开始 上一节已经讲过了启动的过程，其中第三小步1.1里面的2.x系列将了发送回来的过程，这篇文章会继续加上。 Step 112345678910AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; Intent intent = new Intent(); //子线程发出一个带有这个信号的intent intent.setAction(Constant.MY_BROADCAST_ACTION); intent.putExtra(\"mydata\", \"你好\"); sendBroadcast(intent); &#125; &#125;); 特意在子线程中发出，其实都一样，消息接收的时候，会回到主线，因此，在BroadcastReceiver中的onReceive尽量不要做耗时操作。 step 2123ContextWrapper#sendBroadcast() --&gt; ContextImpl#sendBroadcast() 然后在ContextImpl的sendBroadcast中调用了ActivityManager.getService().broadcastIntent(...) //实际上这个就是AIDL的IActivityManager的一个proxy对象调用的broadcastIntent方法 最终就是把 Intent 中的action找 AMS 要对应的broadcast的action去发送 step 3 ActivityManagerService#broadcastIntent123456789101112131415public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) &#123; synchronized(this) &#123; intent = verifyBroadcastLocked(intent); final long origId = Binder.clearCallingIdentity(); //.... // 1. int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras,requiredPermissions, appOp, bOptions, serialized, sticky,callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125; &#125; broadcastIntent 最后调用了broadcastIntentLocked step 4 ActivityManagerService#broadcastIntentLocked","categories":[{"name":"broadcoast","slug":"broadcoast","permalink":"http://zhousaito.top/categories/broadcoast/"}],"tags":[{"name":"android java 进阶","slug":"android-java-进阶","permalink":"http://zhousaito.top/tags/android-java-%E8%BF%9B%E9%98%B6/"}],"author":"Zhousaito"},{"title":"jvm原理","slug":"2019-04-14-jvm2","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:30.221Z","comments":true,"path":"2019/11/11/2019-04-14-jvm2/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-14-jvm2/","excerpt":"","text":"[TOC] java虚拟机以太坊，区块链1.0版本 比特币是1.0 以太坊2.0 -EVM jvm就是对字节码的翻译 虚拟机的发展 go语言写jvm非常的简单 hotSpot VM 目前最广的java虚拟机 JRockit VM 号称最快的java虚拟机 J9 VM ibm公司的 Dalvik VM 未来java技术 模块化， GFGI 模块化，微服务 混合语言（java，Scala） 多核并行（函数式编程） 丰富语法 64位 更强的垃圾回收 回收gb级的 jdk11可以是tb级别 所有的东西都是放内存的 内存的划分， 程序计数器：指向当前线程的字节码，线程间切换来切换去FILO first in last out 非常符合java间的方法调用 虚拟机栈 -Xss 里面有栈帧javap 局部变量表，只能放32位的数据，局部变量表， this，money ​ 持有引用， 操作数栈 ，出栈进行相减count++， dup - idd 总共4不操作的入栈， 返回地址return，正常执行 异常会在一个叫 异常处理器表 处理 多态的的话，就要使用动态连接， java动态运行性， 局部变量表一个引用 ​ native栈 hotspot吧本地方法栈和虚拟机栈合二为一的 ​ 加了入参，可能有点影响 ​ 为什么jvm要用栈，因为：非常符合java间的方法调用 指令 + 数据， 虚拟机栈帧，默认是1m， 可以进行修改 方法区： 类信息，常量，静态变量，即时编译器编译后的代码 java堆： 对象的实例（几乎所有） 数组 ​ -xmx 最大​ -xms 最小 直接内存： nio会使用 ​ 不超过，内存调用​ 每个线程归属于单个线程，栈 堆内存是对所有线程可见的 空间大小：并发可以跑一个100个线程，就100m java虚拟机中的对象 分配内存 指针碰撞 和 空闲列表规整用指针碰撞，不规整用空闲列表 如果相同地址时：要使用cas锁 cas锁：比较和交换 乐观锁 cas操作带来的ABA ABA 问题 中间状态，被用了，不管， 只要管再次分配的时候 b这个状态不管 char的初始值 \\u0000 ？？？ 对象初始化、 设置是那些类的， 然后对象初始化 对象内存的布局 对齐填充对象头：线程 垃圾回收也有点关系 。。。 对象的访问定位 ​ 句柄方式访问对象​ 直接指针访问对象 虚拟机优化技术 — 逃逸分析 有对象可以在栈上分配的，几乎所有对象在栈上分配 hotSpot 默认有逃逸分析 本地线程缓冲区如果有逃逸分析，对象可能会在栈上分配，这是虚拟机的优化的技术本身这个对象，没有在其他地方使用，所以就直接在栈上分配了 逃逸分析使用了可见性？？？，其他的线程也是可见的 热点跟踪，使用频繁就会保存起来 静态方法是也在栈帧里面吗？？？？？ 逃逸分析为什么快？？？？ 异常处理表？？？ 出现异常了，异常处理表 oom 和栈溢出区别混合模式， 直接内存，元空间（直接内存） 直接内存会挤压堆， 2面性 一个进程只能开启一个虚拟机吗 静态属性和静态方法 , 当不持有引用的时候可以使用静态方法 逃逸分析和栈上分配 静态属性和静态方法 内存溢出OOM和内存泄露memory leak 小结 需求管理做不好，等着9-12-7吧 CAS中的ABA问题解决方案 深入分析对象的内存布局JVM–详解虚拟机字节码执行引擎之静态链接、动态链接与分派 2019-04-16 jvm内存分配与回收策略深入理解垃圾回收器1.jvm垃圾回收及案例分析 学习垃圾回收的意义， java与C++之间的区别： GC 谁需要垃圾回收 栈=不需要，凡是共享的对象 堆-重点， 方法区，元空间（也有） GC要做的事 为什么我们要去了解GC和内存分配？ 堆里面继续划分 eden from Survivor To Survivor ODEGEn , 堆 -xmn 回收效率低，就抛出了oom GC overhead limit exceeded 交换区 是 1：1的比列两个交换区始终占两份，所以，当eden为2时， 就是 2：1：1 -XX：SurvivorRatio =8 引用计数：JVM早期使用 A == &gt; B （1） C ==&gt; B （1+1）=2 取消引用 -1 引用+1 缺点，相互引用A ==》 B 同时 b ==》 a 很难判断是不是该回收 （PHP在使用） 可达性算法（java）GC Roots 是因为多加了个 s 1.方法区：类静态属性的对象 2.方法区：常量 3.虚拟机栈（本地变量表）中的对象 （方法没完） 本地栈jni对象 只要方法没跳出来，就是gc roots new 出来的都是强引用 软引用：softreference 当系统要oom了，就会去回收–图片使用内存，然后要oom要释放了 System.gc主动回收 //gc会消耗性能 -XX：+printGCDetails 弱引用： 弱引用只要垃圾回收，就会被回收 weakHashMapThreadLocal 线程隔离 虚引用：PhantomReference 用得非常少 jvm层开发容易用到，回收了会告诉你我要回收了，回收会通知你一下 新生代： 复制回收算法，每次只能用一半 利用率只有一半， 实现简单，运行高效 内存复制，没有内存碎片 90%的对象不需要进行主动回收，10% 8：1：1很多对象不用去主动回收，使用完了，就释放了 8：1：1？？？？？理解 是取eden里面的对象，是通过对象在serviver区间的移动 90%对象会被回收，10%不回收，所以复制只有10% 空间担保：放不下了怎么办 标记-清除算法，会产生内存碎片 标记-整理算法，内存移动，一定会涉及到效率问题 效率一般般 minor GC FUllGc1m只是数据，所有大约占据1.5m空间，对象头和填充 新生代会带一些头的信息所以大一些新生代为什么会大一点？？？？ 老年区实际大小差不多？？？ GC的时候才会去交互区吗 eden存新创建的对象eden经过回收，就去交换区 eden快满了，就触发GC，然后就交换区间复制 堆内存的分配策略： 对象优先在Eden分配 一开始这个区分配 大对象直接进入老年代 （eden区放不下，就相当于大对象） 长期存活的对象进入老年代 动态年龄判断判断 空间担保 gc触发条件，就是空间不够了 分带收集： Serial 单线程 cms 老年代，标记清除算法， （效率很好，空间碎片严重，主流移动互联网用的多） GC的时候，出来GC线程，会把所有的线程暂停 CMS垃圾回收器工作示意图 cms给予并行收集与并发收集的并发标记，和用户线程一起进行的 COncMarkSweep 怎么设置自己的项目使用哪个收集器。 初始标记 — 暂停 并发标记 — 同时进行 重新标记 — 暂停 并发清除 — 同时进行 有浮动垃圾 jps -v 看垃圾回收命令 G1垃圾回收器是 1.7提出来的， 可预测性停顿标记整理 + 化整为零 垃圾回收，都有个内存停顿 吞吐量 = cpu时间 100% gC 10% 业务线程90% 业务线程/总的时间 内存不够了，垃圾回收不成功了，所以就oom了 需要的分配空间不够了， gc回收不了了，还有对象要进来 内存泄漏，MAT GC ROOT 引用的线程是否在频繁调用， monitor Leakcanary， 代码可以追踪内存 空间不够了，就触发GC","categories":[{"name":"JVM","slug":"JVM","permalink":"http://zhousaito.top/categories/JVM/"}],"tags":[{"name":"android java jvm","slug":"android-java-jvm","permalink":"http://zhousaito.top/tags/android-java-jvm/"}],"author":"Zhousaito"},{"title":"C,C++基础","slug":"2019-04-15-c语言一","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:35.474Z","comments":true,"path":"2019/11/11/2019-04-15-c语言一/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-15-c%E8%AF%AD%E8%A8%80%E4%B8%80/","excerpt":"","text":"[TOC] C语言1. 编译&amp;执行C程序 123456gcc hello.c./a.outgcc hello.c hello2.c -o main.out./main.out 错误： 12linker command failed with exit code 1 (use -v to see invocation)这个错误是因为我弄了2个main方法，然后就执行失败出现了这个问题 数组 数组的以第一个值的地址，作为数组本身的地址； 指针 int *p; 指针 int *p = NULL; C中的NULL指针，值是一个良好的编程习惯;被称为空指针 可以用if来进行判断if(p) 如果非空，则完成if(!p) 如果p为空，则完成 函数指针 int (*p)(int,int) = &max; 指针要带括号 (*pMethod) 12345678910111213int max(int a, int b) &#123; return 10;&#125;int main() &#123; //定义 int (*pMethod)(int, int) =&amp;max; //使用 int p = pMethod(1,2); //相当于 max(1,2) printf(\"%d\", p); &#125; 回调函数 12345void fun(int index, int (*pMethod)(int, int)) &#123; for (int i = 0; i &lt; index; ++i) &#123; printf(\"%d \\n\", pMethod(2, 1)); &#125;&#125; 结构体 1234struct NODE &#123; int value; struct NODE *next;&#125;; //结构体获取数据 12345struct NODE *node;node -&gt; value; struct NODE node2;node2.value; 结构体，共用体有什么区别结构体创建的时候为什么要用* 指针 共用体，union typeof：它来为类型取一个新的名字 #define是c指令，各种数据类型定义别名 HelloWorld字符数组 123int main(int argc， char* argv[]) &#123; &#125; 编译 clang -g -o helloworld helloword.c 基本数据类型 Short 16位 int 32位 long 32位 float 32位 double 32位 浮点型影响计算速度 char void void* 代表指针类型 变量和常量 这个里面讲了c语言的内存模型 变量：在内存中随时发生变化的 常量：const int len = 256 //常量定义 Malloc 和 new申请的区域临时变量是在栈空间的 指针与数组 内存地址 void* ，char* 常见的char* 字符串首地址， void*不关注内容，只关注地址 数组：如：char[2] , int arr[10] 连续的，同一类型的空间 就是地址中转，可能是普通的数值 任何一个变量都有自己的一个地址的 123456789101112 int *a, *b; a = (int *) malloc(sizeof(int)); b = (int *) malloc(sizeof(int));//一维数组申请int *d; d = (int *) malloc(sizeof(int) * 3);int **f;f = (int**)malloc(sizeof(int*)*3);//为二维数组分配3行 结构体 struct ： 和类有点相似，就是没成员方法； 相当于自定义类型，要写全 1234typedef struct NODE &#123; int value; struct NODE *next;&#125; Node; 枚举 枚举使用后，只能用枚举内部的值 123typedef enum aaaa&#123; MON, STU&#125; eum; 算术运算 +-*/ % for 和 while 函数： 最终的实现，都是函数堆积完成的， 函数尽量不超过100行，如果需要一些效率可能会有些变化 1void func(int a) &#123;&#125; c语言中的文件操作 FILE* file; FILE* fopen(path, mode); fclose(FILE* file); 再论指针 指针的物理意义，它就是相当于门牌号 指针本身可以进行运算的，可以通过计算获取到新的值 指针指的内容可以运算可以取值，可以吧 栈空间:操作系统自动分配的 堆空间 内存空间 void* mem = malloc(size); free(mem) //不用的时候要成对的释放 内存泄漏与野指针 不断的向系统申请内存。 申请的内存不用，也不释放。 占用别人的内存称为野指针（就是已经调用了释放free指针，然后就应该不要再用了，再用就出错） 1234567891011121314151617181920212223//CDemo1(24412,0x10fc0f5c0) malloc: *** error for object 0x7fb3e2c02b30: pointer being freed //was not allocated//CDemo1(24412,0x10fc0f5c0) malloc: *** set a breakpoint in malloc_error_break to debug//这个就是典型的野指针出现错误//解决三部曲//1、定义指针时，把指针变量赋值成NULL//2、释放内存是，先判断指针变量是否为NULL//3、释放完内存后，把指针变量重新复制成NULL#include &lt;iostream&gt;int main() &#123;// std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; char* p = NULL; p = (char*)malloc(sizeof(100)); stpcpy(p, \"sfasfasdf\"); if (p != NULL) &#123; free(p); p = NULL; //重新指向NULL就可以了， &#125; if (p != NULL) &#123; free(p); &#125; return 0;&#125; 函数指针 返回值类型（*指针变量名）（参数列表） 函数指针 fun() { } Gcc/glong Gcc/clang -g -O2 -o test tes.c -I… -L…. -l -g 输出文件中的调试信息 -O：对输出文件做指令优化 -o: 输出文件 -I：大写的i，指定头文件位置 -L: 指定库文件位置 -l:小写的L，指定哪个库 编译过程 预编译：头文件个文件编译在一起 编译： 链接，动态链接/静态链接 和其他库链接在一起代码执行过程中，链接是动态链接， #inculde “” 双引号，优先本地查找 -l默认没有 lib 调试器原理： 编译输出带调试信息的程序 调试形象包含：指令地址，对源代码及行号 指定完成后，回调 gdb/lldb break list看多少断点 Clang -g -c test.c 这个生成的是不能进行调试的clang -g test.c 这个才能进行调试 ffmpeg从何而来 2000年2011 Libav 从FFmpeg中分离出来的 H264 h265的api ffmpeg 开源代码 libavutil 常用的工具 Libavformat 多媒体格式的解析和封装 libavcodec 所有音频编解码 Libavdevice 对设备 Libavresample 对音频重采样 libavfilter 所有的视频后处理，滤镜 libswresampleLibswscale Share 文档和例子 include 头文件 bin 生成的所有的程序 ffmpeg ​ ffplay ​ ffprobe lib : 生成的动态库， mac dylib，liunx是.so","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://zhousaito.top/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C C++ NDK","slug":"C-C-NDK","permalink":"http://zhousaito.top/tags/C-C-NDK/"}],"author":"Zhousaito"},{"title":"ffmpeg","slug":"2019-04-16-ffmpeg使用一","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:40.422Z","comments":true,"path":"2019/11/11/2019-04-16-ffmpeg使用一/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-16-ffmpeg%E4%BD%BF%E7%94%A8%E4%B8%80/","excerpt":"","text":"[TOC] FFMPEG 目录及作用Libavcodec: 提供了一系列编码器的实现 libavformat： 实现在流协议，容器格式及基本io访问。 libavutil：包括了hash器，解码器和各例工具函数。 libavfilter：提供了各种音视频过滤器。 libavdevice：提供了访问捕获设备和回放设备的接口 libswresample：实现了混音和重采样 libswscale：实现色彩转换和缩放功能 FFMPEG基本概念在讲解FFMPEG命令之前，我们首先要介绍一些音视频的基本概念 音/视频流在音视频领域，我们把一路音/视频称为一路流。如我们小时候经常使用VCD看港片，在里面可以选择粤语和过于声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。 容器我们一般吧MP4，FLV，MOV等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以MP4为例，就可以存放一路视频流，多路视频流，多路字幕流。 channelchannel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。 FFMPEG命令我们按使用目的可以将FFMPEG命令分成以下几类： 基本形象查询命令 录制分解/复用处理原始数据滤镜切割与合并图/视互换直播相关处理FFMPEG 的基本形象查询命令外，其它命令都按下图所示的流程处理音视频。 …省略了一些 基本形象查询命令FFMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的ffmpeg都支持哪些filter，就可以用ffmpeg -filters来查询。详细参数说明如下： -version 显示版本-formats 显示可以用的格式（包括设备）。-demuxers 显示可以用的demuxers. //分流器-muxers 显示可用muxers //混合器-devices 显示可用的设备-codecs 显示libavcodec已经的所有编解码器-decoders 显示所有可用的解码器。-encoders 显示所有有用的编码器-bsfs 显示可用的比特流filter。-protocols显示可用的协议-filters 显示可用的libavfilter过滤器。-pix_fmts 显示可用的像素格式-sample_fmts 显示可用的采样格式-layouts 显示channel名称和标准的channel布局.-colors 显示识别的颜色名称。 接下来介绍的是ffmpeg 处理音频时使用的名利格式和参数。 命令基本格式及参数 下面是ffmpeg的基本命令格式： ffmpeg [global_options] {input_file_options -i i input_url} … {[output_file_options] output_url} ffmpeg 通过 -i 选项读取输入的任意数量的输入 “文件” （可以是常规文件，掼蛋哦，网络流，抓取设备等），并写入任意数量的输出“文件”。原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。流的数量和/或类型是有容器格式来限制。选择从哪个输入进入到那个输出将自动完成或使用 -map 选项。 主要参数-f fmt(输入/输出) 强制输入和输出文件格式。格式通常是自动检测输入文件。并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。 -i url （输入） 输入文件的网址 -y （全局参数）覆盖输出文件而不询问。 -n （全局参数）不要覆盖输出文件，如果指定的输出文件以及存在，请立即退出。 -c [: stream_specifier] codec （输入/输出， 每个流） 选择一个编码器（当输出文件之前使用）或者解码器（当在输入文件之前使用是）用于一个或多个流。codec是解码器/编码器的名称或copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT -codec [: stream_specifier] codec 同 -c -t duration （输入/输出）当用做输入选项（在-i之前）时，限制冲输入文件读取的数据的连续时间。当用作输出选项是（在输出url之前），在持续时间之后停止输出 -ss 位置（输入/输出）当用作输入选项时（在-i之前），在这个输入文件中寻找位置。请注意，在大多数格式中，不可能精确搜索。请注意，在大多数格式中，不可能精确搜索，因此ffmpeg将在位置之前寻找最近的搜索点。当解码和-accurate_seek被启用时（默认）,搜索点和位置之间的这个额外的分段将被解码和丢弃。当进行流式复制或使用-noaccurate_seek时，它将被保留。当用作输出选项（在输出url之前）时，解码单丢失输入，直接时间戳到达位置。 -frames [: stream_specifier] framecount (out,per-stream) 停止在帧计数之后写入流。 -filter [：stream_specifier] filtergraph …// todo","categories":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://zhousaito.top/categories/ffmpeg/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://zhousaito.top/tags/ffmpeg/"}],"author":"Zhousaito"},{"title":"ffmpeg二","slug":"2019-04-16-ffmpeg使用二","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:45.082Z","comments":true,"path":"2019/11/11/2019-04-16-ffmpeg使用二/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-16-ffmpeg%E4%BD%BF%E7%94%A8%E4%BA%8C/","excerpt":"","text":"[TOC] FFMPEG常用命令要掌握一些规律 基本信息查询命令 录制命令 分解/复用命令 处理原始数据命令 裁剪与合并命令 图片/视频转换命令 直播相关的命令 各种滤镜命令 可以加logo滤镜，删除滤镜 ffmpeg处理流程， 输入文件 - demuxer - 编码数据包 - decoder - 解码后数据帧-encoder-编码数据包-muxer-输出文件 纲举目张 muxer， demuxer封装，解封装。 bsfs处理bit流 pix_fmts rgb 帧内编码，帧间编码， 有损压缩，无损压缩 formats 录制命令 ffmpeg录制屏幕: ffmpeg -f avfoundation -i 1-r 30 out.yuv-f : avfoundation采集数据-i: 指定从哪里采集数据，它是一个文件索引号 1是屏幕，0是摄像头 -r：指定帧率 ffplay out.yuv 来输出 ffmpeg -f avfoundation -i 1 -r 30 out.yuv通过-f确定用什么来采集数据 可以通过查看ffmpeg -devices可以确定 123D avfoundation AVFoundation input deviceD lavfi Libavfilter virtual input device E sdl,sdl2 SDL2 output device -i 确定在哪里采集数据 1是屏幕 ，0是摄像头-r 指定帧率out.yuv是输出的文件名 ffplay -s 3360x2100 -pix_fmt uyvy422 out.yuv通过ffplay来进行播放-s 分辨率 activate frame-step mode-pix_fmt 显示像素格式 ffmpeg -f avfoundation -list_devices true -i “” 设备索引号通过这个命令查看 查看当前选择的设备支持的类型，是语音呢还是什么 ffmpeg -f avfoundation -i :0 out.wav :0表示是音频设备在 ： 前的是屏幕设备 ffmpeg -f avfoundation -i 1:0 out.yuv 音频和视频同时录制 分解与复用 ： 文件格式转换 输入文件 - 分解 - 编码数据包 - 复用 - 输出文件 ffmpeg - i out.mp4 -vcodec copy -acodec copy out.flv-i ：输入文件-vcodec :视频编码处理方式-acodec：音频编码处理方式 ffmpeg -i zhou_v.mp4 -an -vcodec copy out.h264 //直接抽取视频 ffmpeg -i zhou_v.mp4 -acodec -vn out.aac //抽取音频 处理原理数据命令原始数据：ffmpeg 解码的数据视频 ：yuv 数据音频：pcm 数据 提取 yuv数据//原始视频编码 指定像素格式 4:2:0 (常用) 4:4:4 4:2:2 ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv // 视频的原始数据 提取pcm 48k 38k 16k 单声道还是多声道 -f抽取音频pcm的数据存储格式 s16le 符号的 16位表示Ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm // 音频的原始数据ar 采样率 Ffplay -ar 44100 -ac 2 -f s16le out.pcm 原始数据，就可以操作一些反转，等一些视频处理 Ink 长刀 瘦金体 滤镜命令：视频倍速，等等 所有滤镜处理，都是对解码后的数据帧做处理 ​ 视频滤镜命令 -vf 滤镜类型是 原来的宽度-200，原来的高度 -200 crop = in_w-200:in_h-200 Ffmpeg -i in.mov -vf crop = in_w-200:in_h-200 -c:v libx264 -c:a copy out.mp4 crop格式 ： crop = out_w:out_h：x：y 加水印 ffmpeg -i zhou_v.mp4 -vf “drawtext=fontfile=simhei.ttf: text=’技术’:x=10:y=10:fontsize=24:fontcolor=white:shadowy=2” output.mp4 ffmpeg -i input.mp4 -i logo.png -filter_complex ‘overlay=main_w-overlay_w-10:main_h-overlay_h-10’ output.mp4 裁剪和合并命令 //从上面时间点开始裁剪 -t 是裁剪多次时间 以秒为单位 ffmpeg -i in.mp4 -ss 00:00:00 -t 10 out.ts ffmpeg -f contact -i inputs.txt out.flv 直播流 推流re和帧率同步 ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName 拉流 ffmpeg -i rtmp://server/live/streamName -c copy dump.flv m3u8 Njex推流 初级开发日志怎么进行打，怎么使用 介绍ffmpeg的基本概念 对复用/解复用及流操作的各种实战 Ffmpeg 的代码结构 libavcodec 提供了一些列的解码器 libavformat 实现在流协议，容器格式及io基本访问 libavfilter 提供了各种音视频过滤器 libavdevice 提供访问捕获设备和回访设备的接口 libswresample 实现混音和重采样 libswscale 实现色彩转换和缩放功能 ffmpeg日志系统 include&lt;libavutil/log.h&gt; av_log_set_level(AV_LOG_DEBUG)av_log(NULL, AV_LOG_INFO, “… %s\\n”, op) AV_LOG_ERROR WARNING LOG_INFO 1234567#include &lt;stdio.h&gt;#include &lt;libavutil/log.h&gt;int main() &#123; av_log_set_level(AV_LOG_DEBUG); av_log(NULL, AV_LOG_INFO, \"Hello world \\n\");&#125; 运行: clang -g -o ffmpeg_log ffmpeg_log.c -lavutil ffmpeg日志进行操作 文件的删除与重命名 avpriv_io_delete(“./mytestfile”) 12345678910#include &lt;libavformat/avformat.h&gt;int main(int argc,char* argv[]) &#123; //是个url串，符合url串都可以认的 int ret; ret = avpriv_io_delete(\"1.txt\"); if (ret &lt; 0) &#123; av_log(NULL, AV_LOG_ERROR, \"fail \\n\"); &#125;&#125; avpriv_io_move(“11.txt”, “222.txt”) pkg-config - - libs libavformat 能找到系统的 libavformat 的库的位置 //不是单引号是 ````` 1前面的那个符号 clang -g -o ffmpeg_del ffmpeg_f.c `pkg-config –libs libavformat` vim学习 命令模式 拷贝、删除、粘贴等、通过i/a等间来进行切换到编辑模式 编辑模式 编辑文字 创建文件：vim filename 保存文件： :w 关闭文件：:q 拷贝。粘贴、删除 yy/yw p Dd/dw 移动光标 h/j/k/l(这是小写的L) 文件头gg文件尾G 移动到行首 ^ 移动到行尾$ 按单词移动：向前w 2w 3w向后 b 2b 3b vim查找与替换：查找关键字： /关键字 命令模式下 n来进行向下查找 N向上查找 查找与替换：:%s/关键字/替换字/gc c 就是确定替换吗 ​ //关键字 可以写正则表达式set number 来进行显示行号 21,24s/关键字/替换字/gc 按照行号来进行替换 分窗口：:split/ vsplit 横/竖 用close来关闭 窗口间跳转： ww w(hjkl) 操作目录重要函数 avio_open_dir()avio_read_dir() 读取文件的信息avio_close_dir() 释放资源重要结构体AVIODirContext 操作目录的上下文 目录的信息存在这里，read的时候需要传这个 AVIODirContext进入当关闭的时候也要传，知道关闭那个文件AVIODirEntry：文件大小，文件信息实战：简单的ls命令 vim C语言环境 多媒体文件的基本概念（一） 多媒体文件其实是个容器；可以放音频数据，字幕数据 在容器里有很多流（stream/Track）；流 和 轨 ； 音频数据和视频数据，这个两条不会交叉 每种流式有不同的编码器编码的 ； aac，mp3 h264 h265 在一个包中包含着一个或者多个帧。包可能一帧压缩数据，多个包组成流，然后就多个多媒体文件 几个重要结构体 AVFormatContext 多个多媒体文件的桥梁，可以区分哪个多媒体 AVStream 可以读取流 AVPacket 多个包，可以通过解码器，解会原来的的数据 解复用（打开容器） -&gt; 获取流-&gt; 数据包 （读取流中的数据包，可以存一个或多个压缩帧） -&gt; 释放相关的资源 打印音/视频信息 视频帧数是多少等。 av_register_all() avformat_open_input()/avformat_close_input 这个会根据文件的格式进行读取 av_dump_format() //可以打印meta信息 SPS/PPS 是干啥的 帧与IDR帧的区别是啥？ Opengles 的知识估计是来不及了 抽取音频数据： av_init_packet() //初始化 av_find_best_stream() // av_read_frame/av_packet_unref() fOpen(dst,”wb”); 特征码 //视频转图片 ffmpeg -i in.flv -r 1 -f image2 image-3%d.jpeg //图片转视频 ffmpeg -i image-3%d.jpeg out.mp4 start Code Sps/pps 是干啥的， 普通文件有一个这个就好了，会产生新的 屏幕分辨率一样， 改变分辨率的时候，都要把 sps和pps切换对应的 codec -&gt; extradata , 在编码器的 extradata中获取 In-&gt;data + in-&gt;size 的是移动","categories":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://zhousaito.top/categories/ffmpeg/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://zhousaito.top/tags/ffmpeg/"}],"author":"Zhousaito"},{"title":"classload 热修复","slug":"2019-04-18-classload热修复","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:50.392Z","comments":true,"path":"2019/11/11/2019-04-18-classload热修复/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-18-classload%E7%83%AD%E4%BF%AE%E5%A4%8D/","excerpt":"","text":"[TOC] 1.android虚拟机Dalvik与ART 2.DexOpt和DexAot 3.Android中的classLoader与双亲委托机制 4.热修复 1.dvm dalvik； dvm不能直接运行class文件，是运行.dex文件。dex适合内存和处理器速度有限的系统。 jvm指令集，基于栈的 dalvik指令集，基于寄存器， ART在安装的时候编译字节码到机器语言，不在是解释运行安装速度变得很慢 cpu有arm或者x86的，所以在安装的时候才进行机器语言，而不是apk的时候打包成机器语言 Dalvik下 JIT just in time 即时编译dvm：解释运行，有些代码使用非常频繁时，让频繁运行的代码，热点代码，在运行的时候编译成机器码。 kt文件 art占用空间比dalvik大（字节码变为机器码），空间换时间，对dalvik的优化版art可以兼容dalvik 预编译也可以提升改善电池续航，应用程序不要每次运行的时候进行编译了，减少cpu的消耗 .dex编译后 -&gt; 变成 .oat 机器语言预编译的过程中aot .dex — 通过aot编译 - &gt;变成 .oat — 运行在art中 字节码变成了 .oat文件 dexopt与dexaot dx — 》 buildtools中的一个工具 ART执行AOT， dexopt 将.dex文件优化 为 odex’，然后执行 65535产生的原因？？？？？ dex2aot， dex文件-&gt; odex 然后AOT进行边 ELF格式，机器码文件.so ELF文件5.0以后就是ART模式了 3.classloader，转载查找类的 android中有几种和java有点区别的， android 运行dex ，java是字节码 jdk当中，secureload/url等是java中的 android 8.0中加入的 *inMemoryDexClassLoader *内存中的，不是磁盘上的 PathClassloader：dexClassloader: 读取外部dex可以把dex优化为odex，这个就是和PathClassloader的区别，PathClassloader不会优化dex dex指定odex的路径，path是默认的odex路径 这两个没什么区别， //dexclassload dex优化为odex目录，必须是私有的路径 MainActivity是pathClassloader加载出来的，pathClassloader加载自己写的类 BootClassloader，是android framework层的class文件。 双亲委托机制：先让父亲找，如果找不到，就自己找，啃老的感觉。这里的父亲是parent的一个成员属性，不是继承的那个父类。 为什么要双亲委托 java中是 Bootstrap类 防止串改系统类，然后使用双亲委托 能不能自己写个类叫java.lang.System？ 答案：通常不可以，但可以采取另类方法达到这个需求。解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。 但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。 c/c++加载的已经加载的,loadClass, findClass, aosp下载 androidos DexElements是什么 -&gt; 是一个element数组，element包含一个dexfileDexfile就带表一个dex文件，然后c++函数进行加载工作 Element的findclass如何实现的 DexPathList dexFile 类加载的时候，插入在dex前，就可以了，修复的时候，直接把修复的dex插入到前面就好了Tinker, andfix。 qq空间热修复 Native：流派 阿里热修复 java：流派 multidex：（classloader修改dexEelements） tinker ， qzone超级补丁 qfix bugly ​ instant-run：美团的 anfix为什么可以不重启也能生效instant-run模式可以及时生效 ART模式下也是可以加载dex的，所以还是可以进行热修复的。 父类的属性反射1.直接反射创建element创建 2.new dexpathclassloader 加载dex文件，在反射new出来的classlaoder中的dexelements 3.反射执行makePathElements 创建Element数组 // apk怎么更新？ 热修复 请求服务器，存在补丁包，下载-》修复(反射) 上传一个补丁号：然后进行修复 增量更新 服务器只会维护一定数量的版本，版本太低了。就下载新的版本 修复放到application： Tinker可以修复application，但是非常麻烦 打dex包，用dx命令来进行打dex包 也可以用 fix插件 当前app在后台不会anr 创建一个activity指定另一个进程中 写到splashActivity/WelcomeActivity中 Chrome github插件??? java - &gt; dex 1.先转jar包 javac -&gt; class 文件 jar -cvf bug.jar Bug.class 然后转成jar jar -cvf bug.jar com/zhousaito/fixdemo/Bug.class 这样打出来带包名 2.jar-&gt;dex 1dx --dex --output fix.dex bug.jar //dex 有问题 java.io.IOException: No original dex files found for dex location /data/user/0/com.zhousaito.fixdemo/code_cache/fix.dex dexopt 与 dex2oat 区别相关面试题解析 Qzone 超级补丁热修复方案原理 美团热修复 Robust 原理解析（二) 一些反常的技术，一直以为对的，现在发现是错误的 1。双锁的静态，2.这个dexClassloader和PathClassloader的一些问题理解","categories":[{"name":"classload","slug":"classload","permalink":"http://zhousaito.top/categories/classload/"}],"tags":[{"name":"classload","slug":"classload","permalink":"http://zhousaito.top/tags/classload/"}],"author":"Zhousaito"},{"title":"flutter","slug":"2019-04-21-flutter复习","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:54.904Z","comments":true,"path":"2019/11/11/2019-04-21-flutter复习/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-21-flutter%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"[TOC] 第一个页面1.在编写的时候遇到一个问题 A RenderFlex overflowed by 48 pixels on the right 出错的代码： 1234child: Text( articles['title'], style: TextStyle(fontSize: 15, color: Colors.black),), 通过在外面包裹一成Expanded去解决这个显示错误的问题： 123456Expanded( child: Text( articles['title'], style: TextStyle(fontSize: 15, color: Colors.black), ),), rxjava 观察者设计模式，操作符非常的多 rxjava有冷热之分 背压只是策略， 跟线程池差不多，任务多了就处理 为什么要学rxjava： &gt;1.代码逻辑清晰， 优雅 &gt;2.避免回调地狱 &gt;3.线程调度 &gt;利用操作符2.rxjava 我们应该学会什么东西。 观察者设计模式线程调度 架构和原理 应用 观察者模式在rxjava中的体现 观察者模式 vs 发布订阅模式（可以完全解耦） 观察者被观察者 Flowable&lt;T&gt; 可以背压Single&lt;T&gt; 只能发射单个数据Completable&lt;&gt; 不发射数据， 只有完成和错误，没有next和onSubscribe；MYabe 发射0或这个一个数据，要么成功，要么失败后面三个基本是 Observable 的简化版 Observable的冷和热 冷：观察者订阅了，才会执行发射数据流的代码 Observable 和 observer是一对一的关系 Cold observable 事件类型 冷：它们各自事件是独立的 当onError和onComplete后，其他事件将不会继续 热: 无论有没有观察者,事件始终会发生,当有多个观察者进行被订阅,信息是共享的, 有点像广播模式 通过publish冷的就边热的了 1.操作符 和 观察者设计模式 2.线程切换 schedulers的原理 3.发布订阅模式 4.观察者设计模式 vs 发布订阅模式 java8 Stream subjectAsyncSubject //热的observable，不管订阅不订阅都在发送 冷的，会从新执行一次代码，subscribe 有些情况下，需要用热的 如： Observer，被观察者：是重量级的操作，比较耗时的时候 数据库操作，dbManager，冷的，每次都用，就不合适。 热的使用场景？？？， RxBus是热的 热的容易内存泄漏，要记住关掉 subject，每次只会，发送最后一个数据 Subject.oncomplete（）前的一个数据 BehaviorSubject：只发送订阅之前的一个数据，和后面的数据 ReplaySubject，发送，所有接受的数据， ReplaySubject.createWitchSize(1) //就是发送前的最后一个数据和后面的数据， 相当于behavior？？？？ PublishSubject，发送订阅之后的全部数据 subject一定要谨慎，又是观察者，又是被观察者，针对特性来进行清楚了再使用 Processor 支持背压操作，和subject就没有什么不同的了 装饰器模式， activity 用了模板方法和装饰者模式 lift原理，装饰器模式的封装是Rxjava1使用的，到Rxjava2都是基于装饰者设计模式函数是，第一等公民 都是在subscribeActual操作的，继承 AbstractObserveableWithUpstream来进行的，Rxjava2的操作符的核心原理 沟通沟通 装饰者设计式，组合设计模式 多个数据源 自定义操作符，点击防抖，嵌套，获取缓存数据，数据合并 EV录制 Single newThread() 线程切换用的是lift操作 因为在rxjava1中，操作失误，然后写反了，报出了MissingBackpressureException，在百度搜索的时候，说是下游处理慢于上游处理就会出现这个问题，然后就没敢用了，怕上线出现问题，后面说Rxjava2中有Flowable可以通过背压策略来进行解决，出现了这个问题，就跟线程池的的处理策略一样 界面优化 ObservableCreate.java -&gt;ObservableSubscribeOn.java-&gt; ObservableMap.java -&gt; ObservableSubscribeOn -&gt; ObservableFlatMap-&gt; subscribeActual() ObservableFlatMap.obj.ObservableSubscribeOn. 开启了newThread线程 source.subscribe 此时的source是ObservableMap对象的source， 然后ObservableMap.subscribe 当执行emitter.onNext()发射方法在什么线程，应该就可以决定在什么地方吗，试试？？？ 似懂非懂 所有的对象都是操作观察者，所以注重观察者在什么线程就可以了 背压策略 自定义操作符？？？？？ Rxjava使用场景Rxjava + retrofit， 线程切换，方便，轮询，嵌套，出错重连功能防抖， 多级缓存获取数据（图片获取，三级缓存） 合并数据源（来源于多个网络请求） RxBind 和 Rxbus 1.自定义操作符？？？？ 2.subscribeOn/observerOn切换线程 3.观察者设计模式，和 发布订阅模式 4.TAG生成的快捷方式， ？参数用qurey网络请求嵌套功能防抖Rxbinding ，防抖操作throttleFirst，点击事件间隔，用aop处理了， flatMap多个子项，可以一个一个展示成一个子可观察者发射出来 Function MyRxView RxTextViewCombineLatest. //可观察数据，两个数据都发射完了，两个数据进行结合返回值给我们 debounce缓冲操作 concat 轮询操作，周期性的参数一种操作 有条件轮询， merge是两个线程是并行的吗 zip 出错重试，retry操作符 subject可以做共享， 用的是 FLowableProcessor 背压，热的 FLowableProcessor.create().toSerialized（）是个线程安全的 ofType（）粘性的 界面交互爆炸系列","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/tags/flutter/"}],"author":"Zhousaito"},{"title":"groovy学习","slug":"2019-04-22-groovy学习","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:12:59.292Z","comments":true,"path":"2019/11/11/2019-04-22-groovy学习/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-22-groovy%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"[TOC] Groovy基础1.1 def关键字 def value = 1;value = “zhangsan” //def 也可以用来定义方法，当方法指明返回值的时候，def关键字可以被省略。 1.2 StringGroovy的string分两种 String）（java.lang.String）和GString (groovy.lang.GString)： 1234567891011def value = '我是字符串'def value1 = \"我是字符串,$value,$&#123;1+1&#125;\"；def value2 = \"我是字符串\"；//支持三引号 java.lang.Stringdef value3 = \"\"\"afsasdfafdasfafdasf\"\"\" 1.3 List 定义 def value = [“a”, “b”, “c”]; value[0] = 4; 查： value[0] 默认是ArrayList，可以通过强类型来声明 LinkedList value = [1,2,3] 1.4 Map 定义：def value = [“a”:a, “b”:2] 增, 改：value.a =100 或者 value[“a”] = 100 查：value.a 或 value[“a”] 1.5 Range 定义：def value = 1..10 使用：if（1 in value） 1.6 metaClass在groovy中可以在运行期间使用metaClass添加方法和属性，以下代码可以被正确执行 1234567class A &#123; String name&#125;A.metaClass.getInfo =&#123; prinln \"getInfo\"&#125; 1.7闭包闭包是groovy中一个很重要的东西 闭包的定义： 12345678910111213def value = &#123; String name -&gt; println name&#125;//闭包的参数类型可以省略def value = &#123; name -&gt; println name&#125;//闭包只有一个参数，参数可以省略def value = &#123; println name&#125; 闭包的使用 1value.call(\"sfas\") 或 value(\"sfas\") 闭包的委托策略： 闭包有三个相关的对象： this: 闭包定义出最近的对象（不含闭包） owner：闭包定出最近的对象或闭包 delegate：闭包的代理对象，默认和owner一致，可以手动设置； 闭包的委托策略： Closure.OWNER_FIRST: 默认策略，首先从owner上寻找属性或方法，找不到 … 2：Gradle执行流程 初始化界面：解析settings.gradle来获取模块信息 配置阶段：配置每个模块，构建task树 执行阶段：执行任务 3：Project3.1： Project相关API getRootProject：获取根project getAllProjects：获取所有Project getSubprojects：获取所有字Project allprojects：遍历所有project subprojects：遍历所有子project 3.2：属性相关的API hasProperty：检测属性是否存在 findProperty：查找属性 自定义property： 通过命令行参数定义property：gradle build -P a=1 通过project.ext定义参数： 1234ext.a = 1ext &#123; a = 1&#125; 3.3: Task相关的API getTasks：获取当前project所有task task：创建一个task 3.4： 文件相关API file：获取文件 fileTree：获取文件夹 getBuildDir：获取build文件夹 3.5 Gradle生命周期API beforeEvaluate：配置阶段开始之前 afterEvaluate：配置阶段结束 这是一个比较重要的生命周期，当走到这里时，说明所有task’都已经配置完成了，我们可以进行操作加入我们的逻辑，也可以出入我们自定义的task gradle.buildFinished:执行阶段结束 3.6：其它API exec：执行外部命令，我们后面会用到这个方法 4：TaskTask是gradle另外一个很重要的东西： 4.1:Task定义 我们可以通过我们的Project中的Task方法来进行定义一个Task 1234task myTask&#123; println \"myTask\"&#125;最后一个参数是闭包，所以这里省略了圆括号 我们也可以使用Project中的TaskContainer来定义一个Task 123project.tasks.create(name: \"myTask\") &#123; println \"myTask\"&#125; 4.2:Task基本信息配置1234567891011121314task myTask ( group: \"wangzhi\" description: \"build\")&#123; println \"myTask\"&#125;或task myTask &#123; group \"wangzhi\" description \"build\" println \"myTask\"&#125; 4.3: Task依赖Task可以通过调用dependsOn方法配置他依赖的Task，可以是一个也可以是多个。 123456task A &#123; &#125;task B &#123; dependsOn A&#125; 我们执行Task B的时候会先执行Task A，应该Task b依赖Task A 4.4： Task执行写在我们Task闭包内的代码是执行在Gradle的配置阶段的，执行每一个任务时都会执行一遍，如果想执行在执行阶段，需要将代码写在doFirst或doLast中。 123456789task myTask &#123; println \"1\" doFirst &#123; println \"2\" &#125; doLast &#123; println \"3\" &#125;&#125; 实战 （自定义Plugin） 创建工程： androidstudio创建一个工程 src/main下新建两个文件夹，groovy、resources， 这个这里的名字叫什么都可以 修改 app文件夹下的build.gradle文件 1234567891011121314apply plugin: 'groovy' //使用groovy插件dependencies &#123; implementation gradleApi() //引入gradleApi&#125;sourceSets &#123; main &#123; groovy &#123; srcDir 'src/main/groovy' //指定groovy目录 &#125; resources &#123; srcDir 'src/main/resources' //指定resources目录 &#125; &#125;&#125; 在groovy目录新建PublishAppPlugin.groovy文件，实现Plugin接口 12345class PublishAppPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; //入口 println \"hello plugin\" &#125;&#125; 在resources/META-INF/gradle-plugins目录中新建com.wanzhi.plugin.publishApp.properties文件，这个文件名就是要是使用我们插件时要 apply的名字，这里叫com.wangzhi.plugin.publishApp,这个文件写入代码： 1implementation-class = com.wangzhi.plugin.publishAppPlugin 目录结构 接收必要的参数 根据我们的需求，我们需要以下参数。 360加固包的路径 签名文件的路径、密码信息 渠道文件的路径 文件输出路径 定义扩展形象，新建PublishAppINfoExtension.groovy文件，根据上面的信息，定义相关参数 123456789class PublishAppInfoExtension &#123; String qihuPath //360加固包(jiagu.jar)的文件路径 String keyStorePath String keyStorePass String keyStoreKeyAlias String keyStoreKeyAliasPass String channelPath String outputPath&#125; 为目标工程定义扩展： 12345class PublishAppPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; project.extensions.create(\"publishAppInfo\", PublishAppInfoExtension.class) &#125;&#125; 功能实现: 自定义Task 新建PublishAppTask继承DefaultTask 1234567891011class PublishAppTask extends DefaultTask &#123; PublisAppTask() &#123; group = \"zhousaito\" dependOn \"build\" &#125; @TaskAction void doAction() &#123; //打包已完成 &#125; &#125; 为目标工程定义我们的Task 1234567class PublishAppPlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; project.extensions.create(\"publishAppInfo\", PublishAppInfoExtension) project.tasks.create(\"publishApp\", PublishAppTask.class) &#125;&#125; 2. @TaskAction 是任务的执行的方法，会在执行阶段执行，因为我们的任务时依赖于build的，所以我们执行任务时，打包已经完成 加固我们的应用 这里参考360加固的命令行加固相关文档即可。 webVIew优化","categories":[{"name":"groovy","slug":"groovy","permalink":"http://zhousaito.top/categories/groovy/"}],"tags":[{"name":"groovy gradle","slug":"groovy-gradle","permalink":"http://zhousaito.top/tags/groovy-gradle/"}],"author":"Zhousaito"},{"title":"模块化","slug":"2019-04-28-模块化开发","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:13:12.426Z","comments":true,"path":"2019/11/11/2019-04-28-模块化开发/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-28-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/","excerpt":"","text":"[TOC] 模块化模块化的一些问题 模块间的页面跳转（路由） 模块间事件通信； 模块间服务调用； 模块的独立运行； 其他的注意事项 dagger2怎么去继承实现 产考我所理解的Android模块化","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android 模块化","slug":"android-模块化","permalink":"http://zhousaito.top/tags/android-%E6%A8%A1%E5%9D%97%E5%8C%96/"}],"author":"Zhousaito"},{"title":"notification channel","slug":"2019-04-26-notificationchannel","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:13:03.160Z","comments":true,"path":"2019/11/11/2019-04-26-notificationchannel/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-26-notificationchannel/","excerpt":"","text":"[TOC] 目的在开发过程中，现在的手机的版本8.0的越来越多了，决定去适配一些8.0的通知，前面的开发都是停留在25上面，也就是android7.1的设备，最近google在9.0的android设备上已经强制了 targetSdk的版本为当前手机的版本，所以适配还是很有必要的。 具体实现123456789101112String channelId = \"upgrade\"; //这个在发送通知的时候需要用到，不然通知无法显示String channelName = \"升级\";int importance = NotificationManager.IMPORTANCE_HIGH;createNotificationChannel(this, channelId, channelName, importance);private static void createNotificationChannel(Context context, String channelId, String channelName, int importance) &#123; NotificationChannel channel = new NotificationChannel(channelId, channelName, importance); NotificationManager notificationManager = (NotificationManager) context.getSystemService( NOTIFICATION_SERVICE); notificationManager.createNotificationChannel(channel); &#125; 得到通知消息后的显示： 1234567891011NotificationManager manager = (NotificationManager) context.getSystemService(NOTIFICATION_SERVICE);//这里使用在初始化的时候创建好的channelId 就是 upgrade 这个Notification notification = new NotificationCompat.Builder(context, \"upgrade\") .setContentTitle(\"加班\") .setContentText(\"程序员终于开始加班了。。\") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher)) .setAutoCancel(true) .build();manager.notify(101, notification); 产考：targetSdkVersion升级到28一些修改的地方(持续更新) NotificationChannel 适配填坑指南","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android notification","slug":"android-notification","permalink":"http://zhousaito.top/tags/android-notification/"}],"author":"Zhousaito"},{"title":"rxjava","slug":"2019-04-26-rxjava","date":"2019-11-11T05:40:29.456Z","updated":"2019-11-14T00:13:07.492Z","comments":true,"path":"2019/11/11/2019-04-26-rxjava/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-26-rxjava/","excerpt":"","text":"[TOC] 一、操作方法1、retry: Flowable retry() 默认构造方法是 integer 最多次数 Flowable retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate) 这个出错的时候可以打印一下 这两个方法没用过，回头看看，标志上先 Flowable retry(long count)Flowable retry(long times, Predicate&lt;? super Throwable&gt; predicate) 123456789101112131415161718192021// retry好几种写法Flowable&lt;ResponseBody&gt; data = RetrofitHelper.getService().getData1(); final Disposable subscribe = data.subscribeOn(Schedulers.io()) .retry(new BiPredicate&lt;Integer, Throwable&gt;() &#123; @Override public boolean test(Integer integer, Throwable throwable) throws Exception &#123; System.out.println(integer); return integer &lt; 3000; &#125; &#125;) .subscribe(new Consumer&lt;ResponseBody&gt;() &#123; @Override public void accept(ResponseBody body) throws Exception &#123; System.out.println(body.string()); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; System.out.println(throwable); &#125; &#125;); 2、retryWhen:网络请求重试次数，可以通过 flatMap -&gt; timer 来进行延迟重试 12Flowable&lt;T&gt; retryWhen( final Function&lt;? super Flowable&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt; handler) 注意： 12RxJava的retryWhen操作符会影响上游，而不会影响下游，比如下游发生了异常，不会重试，而上游发生了异常，会重试retryWhen指定的次数思考一下就能知道原因，因为订阅是从下到上订阅，而数据流是从上到下流动，所以retryWhen返回的Observable发现上流的数据有异常的时候会重试，没有异常了就流给下游，所以retryWhen只能控制它所在的上游 123456789101112//通过retryWhen可重试，当请求失败的时候public static void loadRetryWhen2() &#123; Flowable&lt;ResponseBody&gt; data = RetrofitHelper.getService().getData1(); Disposable subscribe = data.subscribeOn(Schedulers.io()) .retryWhen(new RetryFlowable()) .subscribe(new Consumer&lt;ResponseBody&gt;() &#123; @Override public void accept(ResponseBody body) throws Exception &#123; System.out.println(body.string()); &#125; &#125;); &#125; 12345678910111213141516171819202122232425262728293031323334//重试的一个类static class RetryFlowable implements Function&lt;Flowable&lt;Throwable&gt;, Publisher&lt;?&gt;&gt; &#123; private long tryCount; private long count; private long delay; private TimeUnit unit; public RetryFlowable() &#123; this(3, 3, TimeUnit.SECONDS); &#125; public RetryFlowable(int tryCount, long delay, TimeUnit unit) &#123; this.tryCount = tryCount; this.delay = delay; this.unit = unit; &#125; @Override public Publisher&lt;?&gt; apply(Flowable&lt;Throwable&gt; throwableFlowable) throws Exception &#123; return throwableFlowable.flatMap(new Function&lt;Throwable, Publisher&lt;?&gt;&gt;() &#123; @Override public Publisher&lt;?&gt; apply(Throwable throwable) throws Exception &#123; if (count &lt; tryCount) &#123; count++; System.out.println(\"get error, it will try after \" + \" millisecond, retry count \" + count); return Flowable.timer(delay, unit); &#125; return Flowable.error(throwable); &#125; &#125;); &#125; &#125; 3、maybe没有onNext(Object o)方法，有个onSuccess(Object o)方法 may be 只接受一次成功的值 成功的后面再掉成功也不会发射了 12345678910111213Maybe.create(new MaybeOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(MaybeEmitter&lt;String&gt; emitter) throws Exception &#123;// emitter.onComplete();//调取完成，后面的值也没有了 emitter.onSuccess(\"fsafadsf\"); emitter.onSuccess(\"aaaa\"); //在成功的后面再掉成功也不会发射了 &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 4、do操作1234567891011121314Observable.just(\"hello\") .doOnNext(s -&gt; System.out.println(\"doOnNext: \" + s)) .doAfterNext(s -&gt; System.out.println(\"doAfterNext: \" + s)) .doOnComplete(() -&gt; System.out.println(\"doOnComplete: \")) .doOnSubscribe(disposable -&gt; System.out.println(\"doOnSubscribe: \" + disposable)) .doAfterTerminate(() -&gt; System.out.println(\"doAfterTerminate: \")) .doFinally(() -&gt; System.out.println(\"doFinally: \")) .doOnEach((notify) -&gt; System.out.println(\"doOnEach: \" + (notify.isOnNext() ? \"onNext\" :notify.isOnComplete() ? \"onComplete\":\"onEror\"))) .doOnLifecycle(disposable -&gt; System.out.println(\"doOnLifecycle: \" + disposable.isDisposed()) ,() -&gt; System.out.println(\"doOnLifecycle run\")) .subscribe(s -&gt; System.out.println(\"收到消息: \" + s)); 5、Singlesingle只发送一次，没有完成方法，跟Maybe有点像 12345678910111213141516171819202122Single.create(new SingleOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(SingleEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onSuccess(\"safdsa\"); emitter.onSuccess(\"fffff\"); &#125; &#125;).subscribe(new SingleObserver&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onSuccess(String s) &#123; System.out.println(s); &#125; @Override public void onError(Throwable e) &#123; &#125; &#125;); 6、debouncedebounce操作符 优化app搜索功能 12//导入rxbindingimplementation 'com.jakewharton.rxbinding3:rxbinding:3.0.0-alpha2' 12345678910111213141516171819RxTextView.textChanges(searchEdit) //变化后的1s钟，然后再进行网络请求 .debounce(1, TimeUnit.SECONDS) .flatMap(new Function&lt;CharSequence, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(final CharSequence charSequence) throws Exception &#123; return new ObservableSource&lt;String&gt;() &#123; @Override public void subscribe(Observer&lt;? super String&gt; observer) &#123; observer.onNext(charSequence.toString()); &#125; &#125;; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 如果当用户刚刚在1s中的时候，又开始输入，而过了1s后请求还没回来，但是1s又开始了请求，这样就会乱数据 123456789101112131415161718RxTextView.textChanges(searchEdit) .debounce(1, TimeUnit.SECONDS) .switchMap(new Function&lt;CharSequence, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(final CharSequence charSequence) throws Exception &#123; return new ObservableSource&lt;String&gt;() &#123; @Override public void subscribe(Observer&lt;? super String&gt; observer) &#123; observer.onNext(charSequence.toString()); &#125; &#125;; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); switchMap操作符只会发射第二次(最近一次)请求的Observable 7、concatconcat操作处理多个数据源 可以处理三级缓存，后面可以进行真实数据来进行处理 1234567891011121314151617//内存缓存Flowable&lt;Integer&gt; just = Flowable.just(1);//磁盘缓存Flowable&lt;Integer&gt; just2 = Flowable.just(2);//网络缓存Flowable&lt;Integer&gt; just3 = Flowable.just(3);Flowable.concat(just, just2, just3).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; if (integer == 1) &#123; //内存缓存，假设没有的时候是2，那就不通过，所以就往下走了 &#125; System.out.println(integer); &#125;&#125;); concat 在第一个发送完成之后，才会去发送第二个，如果第一个没有complete，后面的就不会再发送了 12345678910111213141516171819202122232425262728293031323334Observable&lt;Integer&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(11); System.out.println(\"Integer\"); emitter.onNext(22); System.out.println(\"Integer\"); emitter.onNext(33); System.out.println(\"Integer\"); emitter.onComplete(); //需要写个完成,不写完成，后面就不会被发射 &#125; &#125;); Observable&lt;String&gt; stringObservable1 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"44\"); System.out.println(\"String\"); emitter.onNext(\"55\"); System.out.println(\"String\"); emitter.onNext(\"66\"); System.out.println(\"String\"); emitter.onComplete(); &#125; &#125;); Observable.concat(stringObservable, stringObservable1).subscribe(new Consumer&lt;Object&gt;() &#123; @Override public void accept(Object s) throws Exception &#123; if (s instanceof String) &#123; System.out.println(s); &#125; &#125; &#125;); 8、zip与contact不同的是，contact是同一类型的，一个一个发送的。 zip是把不同类型同时发送过来,其实也是一个一个的发过来，只不过，发送过来的时候中途两个数据可以进行计算,在计算过程中，以最少的数量来进行计算，多出来的都不会进行计算了 zip会以最后一个为标准，最后一个不满足就，观察者就不会收到，在就和 CombineLatest区别，CombineLatest每次都进行回调不管哪个变化都会进行比较，然后通知观察者，Rxbing中的表单提交就是用zip之后再最后的那个有效就有效，不然就不通知观察者 123456789101112131415161718192021222324252627282930313233343536Observable.zip(getCreateData1(), getCreateData2(), new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return s + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); public static Observable&lt;Integer&gt; getCreateData1() &#123; return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); //中断了所有的结果都不会打印了// emitter.onError(new NullPointerException());// emitter.onNext(3); //注释了，就长度为2了 &#125; &#125;); &#125; public static Observable&lt;String&gt; getCreateData2() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"我是数据1\"); emitter.onNext(\"我是数据2\"); emitter.onNext(\"我是数据3\"); &#125; &#125;); &#125; 9、mergemerge和concat差不多，也是一个一个的执行，只是不用调用 onComplete后面的被观察者也进行了执行 123456789101112131415161718192021222324252627Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"我是数据1\"); emitter.onNext(\"我是数据2\");// Thread.sleep(2000);// 如果事件中断了，后面的也不执行了// emitter.onError(new NullPointerException()); emitter.onNext(\"我是数据3\"); &#125; &#125;); Observable&lt;String&gt; stringObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"我是数据4\"); emitter.onNext(\"我是数据5\"); emitter.onNext(\"我是数据6\"); &#125; &#125;); Observable.merge(observable, stringObservable).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 10、startWith把startWith的可观察者对象数据 会放在前面执行，然后执行再执行调用startWith的可观察者执行 12345678910111213Observable&lt;String&gt; just = Observable.just(\"1\", \"2\", \"3\"); Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"111\"); &#125; &#125;).startWith(just).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 11、flatMap 、concatMap和switchMapflatMap是不会按照顺序发送过来的 concatMap会按照顺序发送，中间如果有耗时也会发送耗时完后的数据，不会跳着发送 switchMap发送最近的一次observable的数据，前一次observable，会没有效果，所以去重不错 12、timer，interval和intervalRangetimer，任务延迟请求一次，执行完就调用了onComplete的方法 ​ 正常使用，默认会在一个线程中的 RxComputationThreadPool 的线程中 123public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) &#123; return timer(delay, unit, Schedulers.computation());&#125; interval是默认无限发送的，可以通过take来截取一部分 timer相似，如果不额外指定的话，则会采取默认订阅的线程 与timer相似，无法指定起始值，也为默认的long类型的0 支持指定延时发送，所以不会自动发送onComplete intervalRange： 可以指定时间范围完成，可以完成倒计时 这样就可以实现验证码的逻辑了 timer 123456789101112131415161718192021222324 //take对timer来说是无效的，有没有take都是延迟3s，然后执行一次Observable.just(1,2,3,4).take(3).timer(3, TimeUnit.SECONDS) .subscribe(new Observer&lt;Long&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println(d); &#125; @Override public void onNext(Long aLong) &#123; System.out.println(\"onNext: \" + aLong); System.out.println(Thread.currentThread().getName()); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError\"); &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;); interval 1234567//第一个参数是延迟多少秒，第二个参数是，没多少秒后执行一次Observable.interval(1, 3, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; System.out.println(aLong); &#125;&#125;); intervalRange 12345678910111213141516171819//实现倒计时10s钟static int i = 10;Observable.intervalRange(0,10, 0, 1, TimeUnit.SECONDS).subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; i--; System.out.println(i); &#125;&#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; System.out.println(\"倒计时出现错误\"); &#125;&#125;, new Action() &#123; @Override public void run() throws Exception &#123; System.out.println(\"完成倒计时\"); &#125;&#125;); 13、repeat这个是不需要条件，就触发重试，和 retry类似，retry需要 exception 来进行触发重试 repeat是无条件的重试 14、switchIfEmpty做二级缓存的时候使用, 如果都不发射数据，直接完成了，就会走switchIfEmpty里面的数据，然后发送个 观察者 onNext传null，或者调用了 onError 不会走switchIfEmpty里面的可观察者 123456789101112131415161718192021 Flowable.create(new FlowableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;String&gt; emitter) throws Exception &#123;// emitter.onNext(\"发射数据1\");// emitter.onNext(\"发射数据2\"); //onNext传null，或者调用了 onError 不会走switchIfEmpty里面的可观察者// emitter.onNext(null);// emitter.onError(new NullPointerException()); emitter.onComplete();; &#125; &#125;, BackpressureStrategy.DROP).switchIfEmpty(new Publisher&lt;String&gt;() &#123; @Override public void subscribe(Subscriber&lt;? super String&gt; s) &#123; s.onNext(\"我是switchIfEmpty来的数据\"); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(s); &#125; &#125;); 二、自定义操作符1、细节：Rxjava中前面不管写了多少，只有设置观察者的时候才起效，所以要做单步调试的时候，需要设置观察者，才会执行这个单步的操作，判断是否有问题 12345public final void subscribe(Observer&lt;? super T&gt; observer) &#123; //..省略代码 subscribeActual(observer); //执行了这个前面所有的代码才会去走 //..省略代码&#125; Flowable.的使用，如果用subscribe 12345@Overridepublic void onSubscribe(Subscription s) &#123; s.request(1); //要加上这个，就可以进行请求，当时忘记加这个一直不能进行成功 System.out.println(s);&#125; okio的使用 无声音乐、前台服务、双进程守护、像素保活、jobs 兄弟萌,你们怎么查,内存泄漏 ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), mLayoutId, parent, false);CommonHolder myHolder = new CommonHolder(binding.getRoot());myHolder.setBinding(binding); 上传图片，可以看到正在上传第几张图片这个应该就不能进行retrofit去弄了，封装的太好，可能这个没上传一次成功了，没有回调，只有全部上传了才有回调 可能这样，一个一个上传到服务后，然后服务器给了每一个图片的链接，保存，然后整体上传 doOnNext 实战： 可以通过retryWhen重新去获取token，然后又继续请求，这里可能需要判断网络是否有什么问题，或者限制一次请求重新获取次数或者每次的时间，不然，万一是服务器宕机了，或者恶意返回token是失败验证，就会进入死循环，我们自己的程序也宕机了。 优雅的全局加载 Gloading Gradle命令使用。 产考：RxJava系列文章 友好 RxJava2.x 源码解析（三）zip 源码分析","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android rxjava","slug":"android-rxjava","permalink":"http://zhousaito.top/tags/android-rxjava/"}],"author":"Zhousaito"},{"title":"gradle","slug":"2019-04-01-gradle使用","date":"2019-11-11T05:40:29.455Z","updated":"2019-11-14T00:11:20.761Z","comments":true,"path":"2019/11/11/2019-04-01-gradle使用/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-01-gradle%E4%BD%BF%E7%94%A8/","excerpt":"","text":"[TOC] gradle1.gradle是一种自动构建化语言，目前是android的默认构建工具，是一个编程框架 RenderScript 是 C++的代码，通过 打包 资源文件，NDK java/kotlin xml RenderScript gradle是groovy语言来实现的. 坚持把简单事情弄好 ./gradlew assembleDebug 把问题的思路,写下来,然后再问问题,把想法说清楚,问问题要讲究技巧.先问一下,别人有没有空. 语言 groovy 语言 groovy,先将其编译成java类的字节码,然后通过jvm来执行这个java类 支持的环境 androidstudio和命令行,命令行方便调试 构建粒度 支持多个project和多个版本,多个构建类型 可扩展性 有丰富的api和插件框架 其他构建工具 ant,maven 开发 打包 上传 测试 发布理解 -&gt; 解决 -&gt; 应用 -&gt; 分享 哪个工具在哪里有很多star ,分享 可以获取很多 star Warpper 工具包, gradlew -&gt; gradle warpper 的缩写 ;是gradle的一个工具包 ./gradlew assembleDebuggradlew.bat 是批处理文件 gradlew是给liunx上面使用的在home目录下, 有个 .gradle,cd gradle open . 可以打开一个行的目录, gradle版本里面的api不兼容,所以gradle通过gradlewrapper去解决了这个问题 gradle的配置参数 gradle warpper 是什么, closure groovy的闭包, groovy的闭包(closure)groovy的闭包Buildscript({}) 就是一个函数调用,传入了一段代码,就是闭包的一段代码./gradlew assembelDebug BuildScript 配置需要哪些插件,以及这些插件在哪个仓库下载 gradle dsl 仓库,就是存储jar包的地方,放aar的地方settings.gradle 是一开始执行的文件, 多维度打包,多渠道打包 12345if(isGrade) &#123; include 'app','lib1','lib2'&#125; else &#123; include 'app'&#125; 自己去开发gradle 插件,complitionNamecompile 在android studio 3.0抛弃掉了compile = 现在的 api implementation 表示只给自己用,别人不需要, 可以一定程度提高编译速度 gradle = classapi = publicimplementation = private gradle打包慢 1https://maven.aliyun.com/nexus/content/groups/public/ gradle打包的终结解决方案 init 加入了个钩子 hookbuildersrc目录下面放gradle插件 通过extention来建立桥梁 def assert 语句括号是可选的 单引号,就是普通的字符串 “” 可以用${version} 变量 project上面有个方法叫 apply","categories":[{"name":"gradle","slug":"gradle","permalink":"http://zhousaito.top/categories/gradle/"}],"tags":[{"name":"android gradle","slug":"android-gradle","permalink":"http://zhousaito.top/tags/android-gradle/"}],"author":"Zhousaito"},{"title":"ButterKnife","slug":"2019-04-03-ButterKnife原理","date":"2019-11-11T05:40:29.455Z","updated":"2019-11-14T00:11:29.614Z","comments":true,"path":"2019/11/11/2019-04-03-ButterKnife原理/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-03-ButterKnife%E5%8E%9F%E7%90%86/","excerpt":"","text":"[TOC] 开始准备导入包 12implementation 'com.jakewharton:butterknife:10.1.0'annotationProcessor 'com.jakewharton:butterknife-compiler:10.1.0' 通过编写代码,在MainActivity布局中写一个textview, id叫tv 123456789101112public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.tv) TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); mTextView.setText(\"你好\"); &#125;&#125; 在最后反编译apk的时候的图片 代码多出来个一个MainActivity_ViewBinding, 最关键的是这个类是怎么生成的了 查询了网上的资料通过 ButterKnifeProcessor 这个类来进行实现的这个类继承至 AbstractProcessorAbstractProcessor: 可以通过自定义自己的annotation，使得在编译源码代码阶段进行额外操作 最后butterKnife 通过com.squareup.javapoet.JavaFile 写成一个java文件，那就是MainActivity_ViewBinding.java等等一些类 用过顶顶大名的Dagger，Butterknife等依赖注入的童鞋可能知道，他们就通过运行时annotation预处理技术实现动态的生成代码 apk瘦身三部曲, 图片,删除 ​ 手动删除一些无用的代码 ​ 通过lint工具检测,然后删除一些无用的资源文件 ​ gradle配置 压缩 ​ png图片压缩​ webp的使用 混淆 ​ 代码混淆​ 资源混淆 其他方法: 资源动态加载（如表情包动态下载） 插件化（动态加载） 手动删除无用代码 Lint工具检测 gradle 配置 123456789android &#123; buildTypes &#123; release &#123; minifyEnabled true //是否开启混淆 shrinkResources true //压缩 zipAlignEnabled true ////去掉无用的resourse文件 &#125; &#125; &#125; 动态代理 threadLocal 保证了 每个线程的looper一一对应使变量的作用域可以是整个线程 Handler与ThreadLocal在Android中，一个典型的ThreadLocal的使用场景就是Handler类的实现源码里，ThreadLocal用于存储当前线程的Looper对象，从而把线程和Looper对象实现一一对应的关系 threadLocal的理解 asyncTask 源码解析 高效拼接一个字符串 使用 StringBuilder()1txt_msg.setText(new StringBuilder().append(\"\\n\").append(msg).append(\"\\n\")); 高效拼接字符串 经典的自定义view的计算(计算weight下，左右需要padding，然后进行计算) 123456WindowManager windowManager = (WindowManager) this.getContext().getSystemService(Context.WINDOW_SERVICE);Display display = windowManager.getDefaultDisplay();int width = display.getWidth() / 8 - UIUtils.dip2px(8);RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(llContainorTemp.getLayoutParams());lp.setMargins(width, 0, width, 0);llContainorTemp.setLayoutParams(lp);","categories":[{"name":"ButterKnife","slug":"ButterKnife","permalink":"http://zhousaito.top/categories/ButterKnife/"}],"tags":[{"name":"android gradle","slug":"android-gradle","permalink":"http://zhousaito.top/tags/android-gradle/"}],"author":"Zhousaito"},{"title":"jvm原理","slug":"2019-04-08-jvm","date":"2019-11-11T05:40:29.455Z","updated":"2019-11-14T00:11:35.343Z","comments":true,"path":"2019/11/11/2019-04-08-jvm/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-08-jvm/","excerpt":"","text":"[TOC] java虚拟机 内存分配 运行时数据区 线程私有的：程序计数器：指向当前线程正在执行的字节码指令的地址（行号） java是多线程的，意味着线程切换 确保多线程情况下的程序正常执行 运行时数据区 栈，是一个数据结构， FILO first in last out 虚拟机栈（深度 -Xss ） 存储当前线程运行的方法所需的数据，指令，返回地址 栈帧：有一个局部变量表，操作树栈，动态连接，返回地址javap -v JavaStack.classs 反编译java字节码指令大全 局部变量表： 操作数栈 动态连接动态代码， js 运行时编译java多态 程序计数器，会不会报内存溢出？ 答：不会，只是简简单单计个数虚拟机栈溢出 始终调用不到return，就会出现这个错误StackOverflowError执行的虚拟机栈深度大于虚拟机栈运行最多的栈的深度如何处理？ 方法区 类信息， 常量池（常量） ，静态变量，即时编译期编译后的代码（动态运行时编译） java堆对象实例， 数组 深入理解JMM(jvm的内存模型) 对象是有什么周期的 jvm中的垃圾回收机制 垃圾回收的依据 可达性分析算法在java中，可作为GC Roots的对象包括： 虚拟栈（本地变量表） 方法区：类静态属性引用的对象 方法区：常量引用的对象 jvm内存分配规律 jmm内存模型的话，堆 ： 新生代，老年代方法区：永久代（元空间） 大对象直接进入老年代 对象优先进入eden 长期存活的对象将进入老年代 age=15 （一次gc，新生代中发生） 动态年龄对象判断， 空间分配担保 ；老年代有足够的空间可以存放 新生代：minor GC 复制回收算法 （新时代（8：1：1） 90%的对象不需要回收，10%的对象需要回收，所以用了2个10%） 存活概率低，所以使用这个方法 复制回收算法：可用内存，看回收内存，存活对象 保留对象复制算法：一般只用一半 老年代： Full GC （性能比较消耗，回收效率比较低） 标记-清除算法，标志整理算法 标记-清除算法：然后会出现内存碎片所以当内存碎片多的时候，出现 标记-整理算法 标记-整理算法：整理后就没有内存碎片 永久代：会不会进行垃圾回收？也会，回收率非常低 交换区间里面就是赋值回收算法 虚拟机栈为什么没有回收 栈跟线程生命周期相关的 堆是垃圾回收的重点区域 GC的发展趋势 jdk 11中的ZGC - 一种可扩展的低延迟垃圾收集器 处理TB量级的堆（8g g1垃圾收集器） gc时间不超过10ms （Full gc JVM会全部停止） 与使用gc的应用吞吐量降低不超过15% gc 也消耗程序的吞吐量 jvm常用问题解决 ​ 1.内存泄漏， 始终有个gc roots的应用，而程序业务上没有使用 应用计数法 solid 最小知识原则 垃圾回收 PermGen: 永久代 jvm内存模型：虚拟机栈和本地方法栈","categories":[{"name":"JVM","slug":"JVM","permalink":"http://zhousaito.top/categories/JVM/"}],"tags":[{"name":"android java jvm","slug":"android-java-jvm","permalink":"http://zhousaito.top/tags/android-java-jvm/"}],"author":"Zhousaito"},{"title":"一个长期的整理笔记(目录)","slug":"2019-04-08-长期整理的笔记","date":"2019-11-11T05:40:29.455Z","updated":"2019-11-14T00:11:40.486Z","comments":true,"path":"2019/11/11/2019-04-08-长期整理的笔记/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-08-%E9%95%BF%E6%9C%9F%E6%95%B4%E7%90%86%E7%9A%84%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[TOC] 原因： 每次都忘记整理的一些东西，知识应该反复的阅读，然后进行消化，如果长期不用，没有这个目录，很难找到自己想要的，或者在复习的时候，看到了，觉得陌生了，可以快速定位到这个位置 如果一个模块比较大的话，就进行重新开一个 页面，进行分离，这样就跟写代码一样，进行分层，进行隔离，有利于后期的阅读 打算分一些栏目：android，java等业余的 凡只要是个事情，都应该慢慢来，不能急功近利 励志语句 天生我才必有用 两年学说话,一生学闭嘴 工欲善其事，必先利其器 窍门有三点： 不要晕着头工作，要抽空多思考思考，多看看书；看书要看好书，问人要问强人。烂书和烂人都会给你一个错误的概念，误导你；勤能补拙是良训，一分辛苦一分才； 由点即面的想法，一个简简单单的问题，应该多思考，就是一个简单的通信问题，然后去看到它的实现是什么，做的那些通信的额外设置，这才是难点。 自定义view相关1.计算经典的自定义view的计算(计算weight下，左右需要padding，然后进行计算)123456WindowManager windowManager = (WindowManager) this.getContext().getSystemService(Context.WINDOW_SERVICE);Display display = windowManager.getDefaultDisplay();int width = display.getWidth() / 8 - UIUtils.dip2px(8);RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(llContainorTemp.getLayoutParams());lp.setMargins(width, 0, width, 0);llContainorTemp.setLayoutParams(lp); ####源码系列 1.ButterKnife源码2.handler原理​ solid 最小知识原则​​ volley库​ okhttp​ eventbus 怎么跨进程调用的呢​ AMS 怎么启动的，生命周期怎么维持的呢​ image 缓存 &gt;静态函数，要非常小心，在其他线程调用， 细节编程 &gt;For(;;) {} while(true){} 有什么区别，字节数吗 &gt;答： 根本没什么区别，只是在: &gt; &gt;1234&gt;boolean first = true;&gt;while(first) &#123; //可以用变量来控制 &gt;&#125; &gt; &gt; &gt; &gt; &gt;messageQueue 把消息进行了时间排序 &gt; &gt;生产者和消费者模式 &gt;所有的等待唤醒放在了 C++层 &gt;内存共享 &gt;子线程handler 然后 主线程去获取handler &gt; &gt;主内存共享，工作内存独立 &gt; &gt;messge使用了享元设计模式 减少内存 &gt; &gt;图片上传应该怎么做？ &gt;明白什么是http， 从而做到http如何上传图片 &gt;使用okhttp和retorfit实现的过程 &gt; &gt;actvity main线程， 和 main是一个线程吗 &gt; &gt;Command+Shift+ . 显示隐藏文件 &gt; &gt;android的activity的生命周期都是handle发消息来进行决定的释放内存经典的案例， 刚刚我发现怎么一直回调，然后发现是回调里面异常了12345678if (locationCompanyListener != null) &#123; try&#123; //防止onAddress出现异常了，仍然可以释放locationCompanyListener locationCompanyListener.onAddress(amapLocation); &#125;finally &#123; removeLocationCompanyListener(); &#125;&#125; glide获取bitmap 和 bitmap压缩 3.java多线程 OkHttp3（常用API，Martipart文件上传，缓存原理,架构改造) 网络请求（同步，异步，配置，重试，取消） 数据转换（Gson，Rxjava，泛型） 注解处理（注解讲解，泛型，注解处理，架构改造） 多线程下载（原理，遇到的问题，线程池，队列机制，架构改造） 数据库存取(GreenDao，数据库操作，架构改造) 重连与错误处理（注解处理重新连接，处理错误的几种方式） Dns(原理,劫持案例,遇到的问题,实现方案,架构改造) Http（原理，协议流程，请求头，响应头） Https（原理，证书制作，keytool，架构改造） Rxjava（原理，案例，架构改造） 设计模式（动态代理模式，单例模式，工厂模式，构建者模式，策略模式） 网络客户端（httpRequest,httpHeader,httpResponse,架构改造 ) 4.自定义retrofit,封装网络请求一些反常的技术，一直以为对的，现在发现是错误的1。双锁的单例，2.这个dexClassloader和PathClassloader的一些问题理解","categories":[{"name":"笔记","slug":"笔记","permalink":"http://zhousaito.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"android java 笔记","slug":"android-java-笔记","permalink":"http://zhousaito.top/tags/android-java-%E7%AC%94%E8%AE%B0/"}],"author":"Zhousaito"},{"title":"kotlin","slug":"2019-04-10-kotlin1","date":"2019-11-11T05:40:29.455Z","updated":"2019-11-14T00:12:25.112Z","comments":true,"path":"2019/11/11/2019-04-10-kotlin1/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-10-kotlin1/","excerpt":"","text":"","categories":[{"name":"kotlin","slug":"kotlin","permalink":"http://zhousaito.top/categories/kotlin/"}],"tags":[{"name":"android kotlin","slug":"android-kotlin","permalink":"http://zhousaito.top/tags/android-kotlin/"}],"author":"Zhousaito"},{"title":"java多线程","slug":"2019-04-09-java多线程","date":"2019-11-11T05:40:29.455Z","updated":"2019-11-14T00:12:19.868Z","comments":true,"path":"2019/11/11/2019-04-09-java多线程/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-04-09-java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"[TOC] 问题： 并发编程不可不知道的基础概念 天使就是多线程的java程序 线程的一生 线程间的共享 线程间的协作 线程隔离的threadLocal java里的显示锁 多线程并发编程不可不知道的基础概念 线程：cpu的核心数和线程数的关系 核心数和线程数： 是1：1的关系，如果cpu是4核的话，就可以同时4个线程工作 如果是inter的超线程技术：一个核对应了2个逻辑cpu，所以有了4核8线程 cpu时间片轮转机制 RR调度 Round-Robin，轮询调度，通信中信道调度的一种策略，该调度策略使用户轮流使用共享资源，不会考虑瞬时信道条件。 进程和线程 进程和线程: 进程：操作系统在运行的时候，资源分配的最小单位；分配磁盘io，cpu等； ​ 进程和cpu无关 线程：线程必须依赖一个进程，启动一个进程，至少有一个线程。 linux和windows的进程数量有所不同，但是可以进行认为的修改。 并发和并行 并行：同时进行，四个轮子的车。 并发：关键字：单位时间内；在单位时间内运行的线程数量。 java是不怎么关注虚拟机的内核，java无法调度一个线程在指定cpu核上运行。 并发会来带一下问题： 1.线程安全问题 2.死锁问题 3.线程数量，会消耗内存，有单独的栈空间，每个栈空间需要1m的空间的大小 一个线程，在运行的时候，会消耗，运行的数据也要保持起来，另一个线程，也要去读，存好的数据，去取，取的时候也需要时间 通过上下文切换来进行切换线程的使用。一般消耗20000个cpu时间周期，时间周期：把于1+1的时间看作成一个时间周期。 finalize() 关于对象，释放用finalize线程来进行，但是这个方法不一定执行 finalize线程是个守护线程，守护线程跟主线程是同生共死的，当主线程销毁了，finalize线程也进行了销毁，所以finalize()方法就不会被调用了 问题：gc线程是什么时候启动的? 答：gc线程，要有资源回收的时候才启动 答：gc是个守护线程，和主线程同生共死的 Thread 开启一个线程 总共3种启动方式分别是：thread然后两种任务的形式：runnable，callable (callable这种方式不经常使用，在android asyncTask中使用了这个种方式，然后进行的) 1234567891011121314151617 &gt;Runnable runnable = () -&gt; &#123; System.out.println(\"我是runnable的方式启动的\");&#125;;Thread thread = new Thread() &#123; @Override public void run() &#123; super.run(); &#125;&#125;; &gt;static Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; System.out.println(\"我是callable的\"); Thread.sleep(2000); return \"aaaa\"; &#125; &gt;&#125;; 停止一个线程 抛弃的方法 Suspend 会拿着锁去挂起，容易造成死锁 stop， 会直接停止线程，会有些文件句柄等一些都没有进行释放 jdk 1.5后建议使用 Interrupted -&gt; 是一个静态方法；判断线程是否被中断，这个会把状态true改为false isInterrupted -&gt; thread的成员方法；是否中断了， 而这个中断状态是true，不会改成false 静态方法 方法那个在使用过程中，通过这个状态来进行判断处理 1234567891011121314//1.静态方法//这个情况下，就可能有不一样的效果了while (Thread.interrupted()) &#123; //执行的内容&#125; //2.成员方法, while (Thread.interrupted()) &#123; //执行的内容&#125;// runnable，或者callable的情况下获取当前线程进行 interrupt while (Thread.currentThread().isInterrupted()) &#123; //执行的内容&#125; 123456789101112131415161718192021222324252627//如果是在注释的这个打印，最后结果会是true，while (!Thread.currentThread().isInterrupted()) &#123; System.out.println(\"TestRunnable enter isInterrupted: \" + Thread.currentThread().isInterrupted()); &#125;//这样打印，最后一行输出会是falsepublic class TestRunnable implements Runnable &#123; @Override public void run() &#123;// while (!Thread.currentThread().isInterrupted()) &#123;// System.out.println(\"TestRunnable enter isInterrupted: \" + Thread.currentThread().isInterrupted());// &#125; while (!Thread.interrupted()) &#123; System.out.println(\"TestRunnable enter isInterrupted: \" + Thread.currentThread().isInterrupted()); &#125; System.out.println(\"TestRunnable end isInterrupted: \" + Thread.currentThread().isInterrupted()); &#125; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = new TestRunnable(); Thread thread = new Thread(runnable); thread.start(); Thread.sleep(1000); thread.interrupt(); &#125;&#125; 所以，Thread.interrupted() 是会把状态重新修改一次 资料说明： interrupted()是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态 isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态 其实看源码就知道了： Tests if some Thread has been interrupted. The interrupted state is reset or not based on the value of ClearInterrupted that is passed这句话的翻译测试某个线程是否被中断。中断状态是重置还是不重置取决于clearinterrupt的值通过。 123456789101112 &gt;public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &gt;&#125; &gt;public boolean isInterrupted() &#123; return isInterrupted(false); &gt;&#125; &gt;/*** Tests if some Thread has been interrupted. The interrupted state* is reset or not based on the value of ClearInterrupted that is* passed.*/ &gt;private native boolean isInterrupted(boolean ClearInterrupted); 线程的共享和协作 线程之间的共享：数据是共享的；线程共享进程的所拥有的全部资源。 线程基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器，栈），但是它可与同属一个进程的其他线程共享进程的所拥有的全部资源 有共享就会出现，线程安全问题，从而出现了锁的这个概念 synchronized 内置锁 : synchronized锁的都是对象 对象锁，在静态方法上面的锁，是class对象锁在普通方法上面的锁，是this 这个对象的锁 Lock 显示锁 可重入锁解释 1234567891011/** * 什么叫可重入锁: * 自己把自己锁上了 * synchronized 支持，多次拿自己的，jdk设计的时候，考虑了这一点，所以也是可重入锁 * 递归调用的时候，防止自己把自己锁死 */private int count;public synchronized void incr() &#123; count ++; incr();&#125; 生产者与消费者标准范式 1234567891011121314//消费者sync(对象) &#123; while(条件不满足) &#123; 对象.wait() &#125; 执行业务代码&#125;//生产者sync(对象) &#123; 执行业务代码 修改条件 对象.notify/notifyAll&#125; 非公平锁和公平锁 疑问：threadpoolexecutor 是怎么保留线程数量的，线程池的原理通过死循环 扩展：final类型的应该不能反射修改吧？？？ 回答是分两种情况的。 当final修饰的成员变量在定义的时候就初始化了值，那么java反射机制就已经不能动态修改它的值了。 当final修饰的成员变量在定义的时候并没有初始化值的话，那么就还能通过java反射机制来动态修改它的值。 12345678910111213141516171819202122232425262728public class People &#123; public final String name = \"aa.bb\"; public People() &#123; &#125; public String getName() &#123; return name; &#125; public static void main(String[] args) &#123; People people = new People(); System.out.println(\"name 修改前：\" + people.name); reflect(people); System.out.println(\"name 修改后：\" + people.name); &#125; private static void reflect(People people) &#123; Class&lt;? extends People&gt; aClass = people.getClass(); try &#123; Field name = aClass.getDeclaredField(\"name\"); name.setAccessible(true); name.set(people, \"bb.sdfafasdf\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 把people改成这样就可以进行修改了 12345678910 public final String name ; public People() &#123; name = \"aa.bb\"; &#125; public String getName() &#123; return name; &#125;&#125; 2019-04-11整理 复习了synchronized 关键字的复习ThreadLocal线程隔离synchronized同步中使用 wait来等待， notify notifyAll来进行唤醒 读写锁，来进行单一写，多读的情况下，可以提高效率 可重入锁概念：自己可以调取自己不会因为锁来卡死自己 正式进入话题 1. Condition lock的这个锁中有个 newCondition的这个方法，返回一个condition对象Condition 里面有几个方法主要有： await() 相当于wait() ​ signal()/signalAll() 相当于notify、notifyAll，但是不同的是，当signal()之后，只会唤醒对应的Condition对象，所以当一对一唤醒的时候，比notify要好用，notify可能会唤醒不该唤醒的线程。 // todo 明天补上代码 2.线程池 为什么要使用线程池 线程池可以复用线程，降低反复创建线程的消耗 提高响应速度 （来回创建肯定消耗时间和资源） 提高线程的可管理性 runtime 可以获取到 jdk运行时的一些信息 1Runtime.getRuntime().availableProcessors(); //获取 cpu 逻辑核心数 在看线程池的源码过程中，犯了一个错误，看到 runnable.run()误认为是普通方法，并没有开启线程，实际上是在封装好的 Thread内里面的run方法调用的，所以通过普通方法调用，这种方式是合理的 还是没找到循环在哪里，还没搞懂，有问题？？？？todo 线程池 worker 线程 中 run 方法 runWorker(this) 里面进行了调取 getTask()线程池中通过线程自己里面在 getTask的时候 workQueue.take(); 进行堵塞，然后让线程存活了起来 线程池的使用 BlockingQueue对应的几个常用的方法 add() 增加 会抛异常remove() 删除 会抛异常 offer() 插入成功返回true 失败返回 false poll() 移除队列的元素 put() 数据满，插入堵塞tack() 为空时，取出堵塞 线程池的一些参数含义 12345678public ThreadPoolExecutor(int corePoolSize, //线程池的核心线程数 int maximumPoolSize, //线程池最大线程数 10 就有5个非核心线程数 long keepAliveTime, //线程池当达到最大线程数的时候，非核心线程数的线程存活的时间 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //排队的任务队列 ThreadFactory threadFactory, //线程的命名？？ RejectedExecutionHandler handler //队列+最大线程数已经极限了，然后做出的处理 ) jdk的4种拒绝策略（TODO） 启动线程池的两种方式 execute() submit() —AbstractExecutorService实现的 线程池核心数量的确定 &gt;123456&gt;* 任务的特性相关：&gt;* cpu密集型： 当前计算任务需要cpu 不超过机器上的同时运行的线程个数 cpu逻辑核心数&gt;* IO密集型： 读写操作时，网络的时候 一般来讲配置多点线程数 2*cpu逻辑核心数&gt;* 混合型 --&gt; 拆分 为 cpu密集型和io密集型&gt;* io 和 cpu消耗的差不多的时候 拆分&gt;* io 10s cpu 10ms 相当于 cpu密集型 就不需要拆分了 所有的ui控件都是线程不安全的 AsyncTask的原理 //todo Volatile 可变的 //todo都会到主内存去取，但是写回到主内存的时候并不安全适用于：当一个写，多个读的时候，非常适用 悲观锁 synchronized和lock都是悲观锁乐观锁 cas写回操作，知道相等为止典型的悲观锁AtomicBoolean , AtomicInteger 123456789在unsafe.class里面有public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; //这些细节决定了这些 1StickyRecyclerHeadersAdapter //将一个item回到顶部 1((LinearLayoutManager) mRecyclerView.getLayoutManager()).scrollToPositionWithOffset(posi, 0);","categories":[{"name":"java多线程","slug":"java多线程","permalink":"http://zhousaito.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"android java 多线程 并发","slug":"android-java-多线程-并发","permalink":"http://zhousaito.top/tags/android-java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/"}],"author":"Zhousaito"},{"title":"设计模式(一) 策略设计模式","slug":"2019-03-11-设计模式(一)","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-11T05:40:29.455Z","comments":true,"path":"2019/11/11/2019-03-11-设计模式(一)/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)/","excerpt":"","text":"content{:toc}一、前言 我是做android的，以我现在的角度和遇到的设计模式有： 策略设计模式 代理设计模式 工厂设计模式 责任链设计模式（事件分发） 适配器设计模式 单例设计模式 等一些模式 二、策略设计模式策略设计模式，据我所知是用于游戏方面的，比如 梦幻西游的召唤兽，游戏里面接近100种召唤兽，根据一些当前的判断，可以抽象出 攻击行为（释放法术和物理攻击）、被攻击行为、身上的状态、死亡的状态；基本差不多就这些内容，如果每次都去写这些内容，那就看你要写100次，我感觉上比较痛苦。 如果采用策略模式，问题可能就比较简单了。可以把 攻击行为（释放法术和物理攻击）、被攻击行为、身上的状态、死亡的状态，通通抽象成一个接口，然后去把所有用到的行为，都去实现，这样至少可以不用去写100次的不同的行为，可以直接注入，已经实现好的行为，从而达到代码重用的目的 策略模式的好处：可以进行代码重用；减少if else； 怎么学会策略模式：把具有相同行为的一类，区分不变的和变的，把变化的抽象成接口，进行实现注入。 三、设计模式的—五大基本原则单一职责（srp）： 里氏替换： 依赖倒置： 开闭原则： 接口隔离： 迪米特原则（最小知识原则）： 最后设计模式之策略设计","categories":[{"name":"markdown","slug":"markdown","permalink":"http://zhousaito.top/categories/markdown/"}],"tags":[{"name":"java android 设计模式","slug":"java-android-设计模式","permalink":"http://zhousaito.top/tags/java-android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Zhousaito"},{"title":"dart基础","slug":"2019-03-28-flutter3","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-14T00:10:46.469Z","comments":true,"path":"2019/11/11/2019-03-28-flutter3/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-28-flutter3/","excerpt":"","text":"[TOC] 1.异步编程​ 1.floc框架 fish咸鱼开源的 内存隔离的:想进程一样的线程 future 123Future.delayed(Duration(seconds: 2), () &#123; print('111'); &#125;); 12345678910//大于等于3s后执行, 微任务或者main()里面的sleep都印象这个的执行 Future f = Future.delayed(Duration(seconds: 3)); //future的执行， 可以通过then可以获取 f.then((t) &#123; print('11'); &#125;); Future.microtask(()&#123; &#125;); then() 方法,可以得到future的结果并且能够返回一个新的future 1234567891011121314151617181920212223242526File f = File(r\"/Users/zhousaito/java_error_in_studio_25830.log\"); // FutureOr : 返回 void 或者 future //then()方法,可以得到future的结果并且能够返回一个新的future f.readAsString() .then((String s) &#123; print(s); //返回值,是什么类型, 下一个then里面的传值就是什么类型 return 1000; &#125;) .catchError(() &#123;&#125;) .then((int i) &#123; print(i); &#125;) .whenComplete(() &#123;&#125;); f.readAsString() .then((String s) &#123; print(s); //返回值,是什么类型, 下一个then里面的传值就是什么类型 return '1000'; &#125;) .catchError(() &#123;&#125;) .then((String i) &#123; print(i); &#125;) .whenComplete(() &#123;&#125;); 感兴趣flutter https://flutter.cn/ http://dart.goodev.org/ 可以入门。 有app跨端开发经验的欢迎分享或者推荐知识文章。有开发疑惑的欢迎随时扫下面二维码进群交流。 Flutter目前推荐闲鱼语雀。 https://www.yuque.com/xytech/flutter 目前有比较多朋友和hr伙伴有JD（Java，Android，跨端优先），欢迎优秀的朋友有考虑换工作的可以m。 欢迎分享你推荐或者创作技术文章，博客分享，github项目交流，水水群吐吐槽，禁止发广告！","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"android flutter dart","slug":"android-flutter-dart","permalink":"http://zhousaito.top/tags/android-flutter-dart/"}],"author":"Zhousaito"},{"title":"设计模式","slug":"2019-03-29-设计及模式实战","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-14T00:10:58.348Z","comments":true,"path":"2019/11/11/2019-03-29-设计及模式实战/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-29-%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/","excerpt":"","text":"[TOC] 设计模式 走进app框架 bat面试题： 手写一个单例设计模式？分析一下它是怎么工作的熟练运用常用的设计模式理解设计模式 熟悉设计模式的思想和设计模式 工厂设计模式 门面模式： 单一职责， 一个类或者一个接口只负责位唯一 定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，们面膜模式提供一个高层次的接口，是的子系统更易于使用； 目的：门面对象是通往外界子系统内部的唯一通道；通过门面对象降低程序耦合； 一步一步建成的， view层和sdk层进行隔离，这样达到结构 volley的思想 get post put upload down volley 的缺点 不支持大图片的加载 不符合开闭原则：对修改关闭，对扩展开放 代理模式： 通过代理来间接访问目标对象，防止直接访问目标对系统代理不必要的复杂性；通过代理对象对原有的业务进行增强 接口是行为规范，能够干什么事情，接口进行来规定 策略设计模式，是已经知道有什么策略了 而代理模式，并不需要知道代理者是谁 架构师，就是让代码越写越简单 易拓展，易维护了 专业人士之间交流方便；易维护；设计模式是编程经验的总结 FFmpeg 请教， volley源码解析 产考: volley源码解析 一 前言1.为了巩固android网络框架中常见的多线程,io,设计模式,sdk开发等方面 在标准的网络协议中,当人把网络分不同层次进行开发,每一层分别负责不同的通信功能,同事每层之间能简单交互,业内比较规范的说法”高内聚,低耦合”.比如TCP/IP,是一组不能层次协议的多个组合: 应用层 Telnet,FTP和e-mail等 运输层 Tcp和UDP 网络层 IP,ICMP和IGMP 链路层 设备驱动程序及接口卡 volley网络框架分层: 应用层: StringRequest Request Volley 控制器：RequestQueue CacheDispatch NetworkDispatch ResponseDelivery 网络层：HttpStack Request Response NetWork NetworkResponse 基础层：Cache VolleyLog VolleyError RetryPolicy 二、基础层我们先看基础层，它上层都会需要依赖它这一层，保存代码的健壮性。 在基础层，我们能学习到： 缓存数据模块：通用的缓存策略。 日志模块：灵活的对时间打点。 异常模块：统一的异常处理。 重试机制：网络条件差情况下能够提供重新请求的功能。 2.1 缓存模块######2.1.1 Velloy的缓存机制 遵循http缓存协议 概括的说http缓存协议利用http请求头中的cache-control和eTag字段进行是否缓存，缓存时间的判断。主要过程如下：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhousaito.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android 设计模式","slug":"android-设计模式","permalink":"http://zhousaito.top/tags/android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Zhousaito"},{"title":"2019-03-30-http","slug":"2019-03-30-http","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-14T00:11:06.881Z","comments":true,"path":"2019/11/11/2019-03-30-http/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-30-http/","excerpt":"","text":"12345layout: posttitle: &quot;websocket&quot;categories: fluttertags: android flutterauthor: Zhousaito [TOC] websocketwss websocke, 安全的websocket http2.0貌似可以主动推了 社交订阅 多玩家游戏 协同编辑/编程 点击流数据 股票基金报价 体育实况更新 给予位置的应用 MQTT broker mqtt物联网行业用的比较多 串口通信 xmpp长连接和短连接 https 只根据 http 加了一层 ssl协议 postmain这个软件 data-part post的参数放在 http的body里面part的分界线 application/x-www-form-urlencodedpart没有分界线 raw方法传json串 所以上传多个文件用MultipartBody multiple connections DNS污染怎么办, httpbin.org www.wh.hb.cn 先查 cn, hb , wh, 最后www okhttp自己去解析自己的dns http 是五加密的通信 https 非对称加密, 公钥公开, 私钥在自己手上的欧拉定理 信任所有证书 中间人,先是服务器,然后变成客户端 charles中间人攻击 客户端, 校验证书证书通过一种方式生成的 学东西一定要解决异常的问题 allen 老师, 我们公司用ip直接访问就报错,这种方式 公钥的ping sha-256 那个值怎么来的","categories":[],"tags":[]},{"title":"flutter","slug":"2019-03-31-flutter6","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-14T00:11:11.638Z","comments":true,"path":"2019/11/11/2019-03-31-flutter6/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-31-flutter6/","excerpt":"","text":"[TOC] 作业：EventBus 实现 路由Navigator 路由管理器, 本身也是个widget 展示到手机是 Element的 树形结构 最外面是root -&gt; MainPage 不会创建Navigator -&gt; MaterialApp 里面有很多widget, 其中就包含了Navigator , scaffold 阿里巴巴， 美团等一些路由框架 抽离widget","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"android flutter","slug":"android-flutter","permalink":"http://zhousaito.top/tags/android-flutter/"}],"author":"Zhousaito"},{"title":"flutter","slug":"2019-03-30-flutter5","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-14T00:11:02.917Z","comments":true,"path":"2019/11/11/2019-03-30-flutter5/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-30-flutter5/","excerpt":"","text":"[TOC] 在flutter几乎所有的对象都是一个widget 轻量版 WidgetStateLessWidget 和 StatefulWidget (更新ui的时候使用)是flutter的基础控件, 整体就是一个widget 12initState 初始化数据dispose 释放数据 processon 制作图的完整 网络请求 http , dio 库data pub //Stack 相当于帧布局 Offstage 是否隐藏 View.GONE offstage : !is_loading CircularProgressIndicator Widget 只是个配置信息，不是最终显示的view，不能以android角度去思考widgetRefreshIndicator 相当于refreshIndicator ListView.build Container list.map； 迭代器身上有个list的方法 boxfit.fillSmarttorefresh ![image-20190420180346150](/Users/zhousaito/Library/Application Support/typora-user-images/image-20190420180346150.png) Deactivate 在剔除后执行，然后再是dispose","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"android flutter","slug":"android-flutter","permalink":"http://zhousaito.top/tags/android-flutter/"}],"author":"Zhousaito"},{"title":"java泛型","slug":"2019-03-31-java泛型","date":"2019-11-11T05:40:29.454Z","updated":"2019-11-14T00:11:16.418Z","comments":true,"path":"2019/11/11/2019-03-31-java泛型/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-31-java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"[TOC] 泛型","categories":[{"name":"java","slug":"java","permalink":"http://zhousaito.top/categories/java/"}],"tags":[{"name":"android java","slug":"android-java","permalink":"http://zhousaito.top/tags/android-java/"}],"author":"Zhousaito"},{"title":"GuardianApp遇到的一些问题","slug":"2019-03-18-GuardianApp遇到的问题","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-11T05:40:29.453Z","comments":true,"path":"2019/11/11/2019-03-18-GuardianApp遇到的问题/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-18-GuardianApp%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"content{:toc}问题 1.当fullscreen的时候,还需要status的时候,我们使用普通的activity主题,然后使用如下方法: 123456// https://blog.csdn.net/a872822645/article/details/74482323private void showStatusBar() &#123; WindowManager.LayoutParams attrs = getWindow().getAttributes(); attrs.flags &amp;= ~WindowManager.LayoutParams.FLAG_FULLSCREEN; getWindow().setAttributes(attrs);&#125; 2.高德地图,缩放级别设置: 12//在初始化的时候设置这个aMap.moveCamera(CameraUpdateFactory.zoomTo(15)); 3.遇到8.0的透明主题崩溃问题: 1Only fullscreen activities can request orientation终极解决方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; if (Build.VERSION.SDK_INT == Build.VERSION_CODES.O &amp;&amp; isTranslucentOrFloating()) &#123; boolean result = fixOrientation(); &#125; super.onCreate(savedInstanceState);&#125;private boolean fixOrientation()&#123; try &#123; Field field = Activity.class.getDeclaredField(\"mActivityInfo\"); field.setAccessible(true); ActivityInfo o = (ActivityInfo)field.get(this); o.screenOrientation = -1; field.setAccessible(false); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false;&#125;private boolean isTranslucentOrFloating()&#123; boolean isTranslucentOrFloating = false; try &#123; int [] styleableRes = (int[]) Class.forName(\"com.android.internal.R$styleable\").getField(\"Window\").get(null); final TypedArray ta = obtainStyledAttributes(styleableRes); Method m = ActivityInfo.class.getMethod(\"isTranslucentOrFloating\", TypedArray.class); m.setAccessible(true); isTranslucentOrFloating = (boolean)m.invoke(null, ta); m.setAccessible(false); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return isTranslucentOrFloating;&#125;@Overridepublic void setRequestedOrientation(int requestedOrientation) &#123; if (Build.VERSION.SDK_INT == Build.VERSION_CODES.O &amp;&amp; isTranslucentOrFloating()) &#123; return; &#125; super.setRequestedOrientation(requestedOrientation);&#125; 参考Android 全屏 但是有状态栏(任务栏) Only fullscreen activities can request orientation终极解决方法","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android android开发遇到的问题","slug":"android-android开发遇到的问题","permalink":"http://zhousaito.top/tags/android-android%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"}],"author":"Zhousaito"},{"title":"编写规范","slug":"2019-03-18-编写规范","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-11T05:40:29.454Z","comments":true,"path":"2019/11/11/2019-03-18-编写规范/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-18-%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/","excerpt":"","text":"content{:toc}规范 代码需要格式化 如果在项目比较忙的时候,下班前提交代码 字符串比较尽量使用TextUtils来进行判断 版本号 10101 -》 1.1.1 命名规范: recyclerview : item * recyclerInclude : include_* Netutils appkey 的动态修改 as使用alibaba的标准代码 Glide.with(this).load(img).into(civHeader); glide框架封装 FileProvider 的包名是否统一 （常常犯得错误） 弄半天，还是需要查阅文档 草稿:1.网络请求加密的文档2.git使用说明, git链接的的权限开通问题","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android android编写规范","slug":"android-android编写规范","permalink":"http://zhousaito.top/tags/android-android%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"}],"author":"Zhousaito"},{"title":"mvvp mvp mvc","slug":"2019-03-25-mvvm_mvp_mvc","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-11T05:40:29.454Z","comments":true,"path":"2019/11/11/2019-03-25-mvvm_mvp_mvc/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-25-mvvm_mvp_mvc/","excerpt":"","text":"content{:toc} 三种设计模式的使用以及区别mvc -&gt; mvp -&gt; mvvm 123aac框架，mvvm的框架(需要梯子)https://developer.android.google.cn/jetpack/docs/guidehttps://developer.android.google.cn/topic/libraries/architecture/index.html 一. mvvmmvvm主要是要通过databinding来进行xml布局中进行绑定 databinding的赋值: 12345678910111213&lt;data&gt; &lt;import type=\"com.zhousaito.mvvmdemo.entity.User\" /&gt; &lt;import type=\"com.zhousaito.mvvmdemo.viewmodel.UserViewModel\"/&gt; &lt;variable name=\"user\" type=\"User\" /&gt; &lt;variable name=\"viewModel\" type=\"UserViewModel\" /&gt; &lt;/data&gt; 123456789101112&lt;!--也可以这么写--&gt;&lt;data&gt; &lt;variable name=\"user\" type=\"com.zhousaito.mvvmreview.entry.User\" /&gt; &lt;variable name=\"mainViewModel\" type=\"com.zhousaito.mvvmreview.viewmodel.MainViewModel\" /&gt; &lt;/data&gt; 通过@{user.name} 来进行使用 1234&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;user.name&#125;\"/&gt; 1234error： Bindable must be on a member in an Observable class//需要user去继承BaseObservableclass User extends BaseObservable databinding的点击事件的写法: 12345678&lt;!--这个是任意参数的,如果没有参数,可以不写,就写个空括号就好了--&gt;android:onClick=\"@&#123;() -&gt; viewModel.onClickView()&#125;\"&lt;!--这个是带有view参数的--&gt;android:onClick=\"@&#123;viewModel::onClickView&#125;\" &lt;!--第一种写法的相当于第二种的写法--&gt;&lt;!--这种是低一种的写法的写出--&gt;android:onClick=\"@&#123;(v) -&gt; viewModel.onClickView(v)&#125;\" 123456789101112131415 //这个是有view参数的 public void onClickView(View view) &#123; User user = new User(); user.setAge(10); user.setName(\"zhousaito\"); getMutableLiveData().setValue(user); &#125;//这个是没有view参数的 public void onClickView() &#123; User user = new User(); user.setAge(10); user.setName(\"zhousaito\"); getMutableLiveData().setValue(user); &#125; 如果user类不实现 如果你的Entity不想继承BaseObservable 以及做上述的那些操作，你也可以使用ObservableFields。android.databinding.ObservableFieldandroid.databinding.ObservableBoolean,android.databinding.ObservableByte,android.databinding.ObservableChar,android.databinding.ObservableShort,android.databinding.ObservableInt,android.databinding.ObservableLong,android.databinding.ObservableFloat,android.databinding.ObservableDouble,android.databinding.ObservableParcelable. ObservableFields 链接：https://www.jianshu.com/p/e7628d6e6f61/ 123456789public class User &#123; public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public ObservableField&lt;Integer&gt; age = new ObservableField&lt;&gt;();&#125;//使用的时候mUser.age.set(10);mUser.name.set(\"zhousaito\"); 1234567891011121314/** * BindingAdapter * 变成非静态就报错 * 使用BindingAdapter注解的静态绑定适配器方法允许我们自定义如何调用属性的setter。 * https://blog.csdn.net/guiying712/article/details/80411597 * * @param imageView * @param url */ @BindingAdapter(\"setUrl\") public static void setUrl(ImageView imageView, String url) &#123; Log.e(TAG, \"setUrl: \" + url); &#125; 1android:background=\"@&#123;dataViewModel.error? @color/colorAccent: @color/colorPrimary&#125;\" 1.布局是databinding的吗, View 的复用 请问做过智能推荐相关吗？ 草稿： 王自建羽良渠道为王为了商业职责阶段匹配问题, 懂产品的老板,其实一样成功只要有一个长相不要去刻意去补自己不擅长的东西, 不擅长的东西找别人去做招人找钱和定战略方向降维攻击考虑产品的实用性， 设计师，所有的机器都没孔","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android android设计模式","slug":"android-android设计模式","permalink":"http://zhousaito.top/tags/android-android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"Zhousaito"},{"title":"二叉搜索树","slug":"2019-03-20-二叉搜索树","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-11T05:40:29.454Z","comments":true,"path":"2019/11/11/2019-03-20-二叉搜索树/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-20-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"content{:toc}1.介绍 2.为什么使用树形结构为什么使用树形结构。因为高效 二分搜索树 平衡二叉树：avl；红黑树 堆；并查集 线段树；trie （字典树， 前端树） 3.二分搜索树 二叉树 和链表一样，动态数据结构 class Node { E e; Node left; //左孩子 Node right; //右孩子 } &lt;!--￼0--&gt; 另一种写法: &lt;!--￼1--&gt; **思考: 链表递归实现** - 二叉树查询 &lt;!--￼2--&gt; - 数据结构遍历 遍历:把所有节点都访问一遍 访问的原因和业务有关 在线下结构下,遍历及其容易 树形结构遍历 前序遍历: 先访问节点,再访问左右子树;最自然的遍历方式;最常用的遍历方式 中序遍历: 打印出来,就是一个排序好的顺序,自左到右 后序遍历: 在哪里打印 非递归的实现,用了个 栈 去实现, ​ 深度优先遍历 : 用栈 ​ 广度优先遍历: 用队列 广度优先遍历:使用在查询身上,使用在获取解的身上 ​ 更快找到问题的解 ​ 常用于算法设计中-最短路径 深度优先遍历:一下子就进入到了,深度很深的地方,可能解在比较浅的地方草稿： 二分搜索树是二叉树怎么 赋值呢,怎么产生二叉树的值","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://zhousaito.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构 算法","slug":"数据结构-算法","permalink":"http://zhousaito.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"}],"author":"Zhousaito"},{"title":"dart基础","slug":"2019-03-28-flutter0328","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-14T00:10:52.153Z","comments":true,"path":"2019/11/11/2019-03-28-flutter0328/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-28-flutter0328/","excerpt":"","text":"[TOC]","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"android flutter dart","slug":"android-flutter-dart","permalink":"http://zhousaito.top/tags/android-flutter-dart/"}],"author":"Zhousaito"},{"title":"flutter","slug":"2019-03-28-flutter1","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-14T00:10:33.541Z","comments":true,"path":"2019/11/11/2019-03-28-flutter1/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-28-flutter1/","excerpt":"","text":"[TOC] flutter WebView 第三阶段：跨平台，h5作为二阶段的性能瓶颈，RN通过桥梁完成原生的绘制，以达到更优的性能。JavaScript通过bridge传递到native完成原生绘制，bridge的成本高，因为需要频繁的跨桥调用，导致卡顿等性能问题。 跨平台的移动ui框架，可以快速在ios和android上构建高质量的原生用户界面。flutter可以与现状的代码工作。在全世界，flutter正在被越来越多的开发者和组织使用，并且flutter是完全免费，开源的。 与现有代码一起工作 （支持混合开发） 免费开源 跨平台移动ui框架 fuchsia Android IOS利用dart虚拟机减少了桥的交互编译型语言，没办法夸平台，但是执行效率很高：在android过程中编译成android平台的识别的编译语言在ios过程中编译成ios平台可以识别的编译语言 framework（dart）engine（c++） skia渲染引擎、dart VM等 15年的时候flutter的前身 ‘sky’ ，运行在android操作系统上。 一开始是通过浏览器出现的，随着nodejs出现，js又火了起来flutter beta1版本于2018年2月27日flutter live 2018年12月5日 正式版出现了12月27日出来了1.2.2的版本腾讯，京东，百度，美团腾讯now直播apk，京东金融apk，咸鱼apk(经常发布flutter文章) 都含有 libflutter.so文件 flutter特点快速开发 富有表现力，漂亮的用户界面 内置很多控件，可以在ios和android上面达到相同的效果本地性能： 不能避开 dart的引擎层，已经接近原生 热重载：ctrl + s 就加载布局上来了 debug模式和release模式完全不一样 debug模式：利用websocket来进行更新的text文本 showcase美团 爱奇艺 携程编译型语音,运行时语言 dart 于其他跨平台框架使用JavaScript作为其他开发语言不同的是,flutter使用是dart.特点: ​ (jit aot 混合编译的 ) 给予JIT的快速开发周期 (运行期间,编写出来的, jit在运行)flutter在开发阶段采用jit模式,这样就避免了每次改动都要进行编译,极大的节省时间; 给予aot的发布包(代码提前编译成机器码 java9 也加入了aot)flutter在发布时可以通过aot生成高效的ARM代码以保证应用性能. 为了快速流程的用户体验需要能够在每个动画帧运行大量的代码,不能有周期性的停顿,否则会造成掉帧. fps 30fps 1s钟切换30次图片​ 单线程: dart是个单线程的语言, isolate机制不需要锁,不存在数据竞争和变量状态同步,也没有线程 垃圾回收 : 新生代,老生代 实现是cms的垃圾回收器多生代无锁垃圾回收器,专门为UI框架中常见的大量widgets对象创建和销毁优化 flutter的前景怎么样?为什么你会选择使用flutter? 一开始h5和webview这些效率比较低,看起来界面比较卡顿 性能比RN好, 因为RN中间以js为桥梁,flutter效率比较高 pubspec.yaml 进行导入依赖 flutter中文网 可以看一些demo flutter解决白屏问题","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"android flutter","slug":"android-flutter","permalink":"http://zhousaito.top/tags/android-flutter/"}],"author":"Zhousaito"},{"title":"dart基础","slug":"2019-03-28-flutter2","date":"2019-11-11T05:40:29.453Z","updated":"2019-11-14T00:10:40.782Z","comments":true,"path":"2019/11/11/2019-03-28-flutter2/","link":"","permalink":"http://zhousaito.top/2019/11/11/2019-03-28-flutter2/","excerpt":"","text":"[TOC] dart 变量 dart所有类型都是对象 int i； 不给i赋值，输出的时候就是null var关键字： 在声明的变量赋值那一刻，就决定了它是什么类型。 123456789//这样的var是可以重新赋值不同的值//var 在声明变量赋值的那一刻，就决定了它是什么类型 var a; a = 10; a = \"sfasdf\"; //这样会出现错误 var b = 0; b = \"\"; dynamic关键字: 在运行的时候决定类型 12dynamic z = \"laaa\";z = 10; Object关键字： 12Object s = 0;s = \"afafs\"; final和const关键字： final 关键字根java 差不多 运行时常量 const 和final差不都 编译器常量：const效率比较高，确定的值 12//编译完成之后，所有用到i的地方都变成1了const i = 1; 1final 类型可以被const赋值 内置类型 int: 123456//int 在java占4个字 dart也认为是4位//当成java的short int long类型来使用//如果 我们写的dart超过了4个字节,那么dart会将其编译成类似的java 当中的long//否则编程java当中的short或者intint i = 0xffffffffffffff;print(i.bitLength); String 1234567891011121314 //2.1 格式化 String str = \"发达\"; int num = 10; //$符号去拼接字符串 //建议使用 &#123;&#125; 包起来 String a = \"$&#123;str&#125;我要找$num号技师\";//2.2 单引号,和双引号 都可以声明 String s = ''; String s1 = '\"test\"'; String s2 = \"'sfasf'\"; print(s2); bool List数组 1234567List&lt;String&gt; list = new List();List&lt;String&gt; list = List();list.add(\"asfdsaf\");//像数组一样取值String value = list[0];print(value); 操作符 方法 dart 可以不在类里面写方法,这个就叫顶层方法 一等方法对象 typedef关键字 1234567typedef void OnClick();class Button &#123; void setOnClick(OnClick onclick) &#123; onclick(); &#125;&#125; 可选参数位置 123456//可选位置参数 可以使用[] 来进行// j = 2 是个默认值void fun([int i, int j = 2]) &#123;&#125;fun(1, 0) 可选命名参数 1234567//可选命名参数void funasdfa(&#123;int i, int j = 2&#125;) &#123;&#125;fun(j:10);fun(j:10,i:11); 可选参数位置; 可选命名参数不需要想java一样写大量的构造函数了 异常 12345678910111213141516171819202122232425262728293031323334void test() &#123;// throw new Exception(\"sfasfas\"); //万物皆对象 111 throw 111;&#125;void main() &#123; //介绍cast的参数,可以填写两个参数 try &#123; test(); &#125; catch (e, s) &#123; //就是抛出异常对象 print(e.runtimeType); //调用栈信息 print(s.runtimeType); print(s); &#125; finally &#123; print(\"aaaaaa\"); &#125; //根据不同的异常类型,进行不同的处理 // on TYPE catch // dart 可以抛出对象 try &#123; test(); &#125; on Exception catch (e) &#123; print(e); &#125; on Error catch (e) &#123; print(e); &#125; on int catch (e) &#123; print(e); &#125;&#125; 类 12///类 dart 命名规则 小写_小写_小写,风格来命名库和文件名名字///类名使用 UpperCamelCast 构造函数语法糖 12//构造函数语法Preson(this.x,this.y); 命名构造函数 1234//命名构造方法 要一个this //一看就知道这个 Point.Xafdasf(this.y); Point.Xa(y); 参数初始化列表 1 复习：一 变量 final和const const 是编译时就确定的 ​ 一个数组被定义了，就无法再改变了，即使是数组内的数据 ​ 而final仍然可以进行改变内部的值 根据const的修饰位置不一样导致表现不一样 const可以这样修饰 List list = const [] 表示[]这个在编译时已经确定了，而list还是个指向另一个数组对象 List list = []； //这样是没有问题的 修饰在变量的前面,这个list不能被改变,重新赋值的时候回报错添加的数据也是会报错 1Unsupported operation: Cannot add to an unmodifiable list const List list = []; const还可以修饰构造方法, final不能 final 是运行时确定的 ​ final修饰是变量的指向的对象已经确定了, 不能直接修饰对象身上而const是可以修饰在对象上面的. ​ final List list = []​ list.add(1); //值是可以加入进去的,可以进行增删改查 12final List&lt;int&gt; list2 = [];list2..add(1)..add(2)..add(3); //.. 是级联操作 1List&lt;int&gt; list =final [] //这样修饰会报错，这个const的用法就不一样 名字 区别 相同点 const 1. const是编译时的2. const可以修饰在对象上，表示对象在编译时就已经确定了3. const可以修饰在构造方法上面，表示构造方法编译时已经确定了，前提是已经确定的值；必须依靠编译期间就能够计算出来的数据进行创建 都是修饰后，不能进行修改。 final 1.final是运行时的2.不能修饰构造方法3.不能修饰对象上面 ；如：final [] 是错误的 var object dynamic 三者的区别 var 是个关键字: 声明变量的那一刻就已经确定了类型 12var p = Person();p = 10; //这个值就不能进行赋值了，编译器会在这行报错 1234//这种方式是可以的，以最后个p的赋值为准var p;p = Person();p = 10; Object ：万物之主 123//object可以这样使用Object p = Person();p = 10; 1234//这样也是对的Object p;p = Person();p = 10; dynamic : 运行时确定类型 12345678dynamic p = Person();p = 10;p = 'asfasdf';dynamic p ;p = Person();p = 10;p = 'asfasdf'; 二 7大内置类型 num: int , double 万物皆对象: 在int 和 double 值如果没赋值就是null String : 注意一个三引号 1234567891011121314151617181920212223242526272829303132 /** * 字符串 * 不推荐使用 + 来进行字符串拼接, 会创建很多string对象 * */ //2.1 格式化 String str = \"发达\"; int num = 10; String a = \"$&#123;str&#125;我要找$num号技师\"; //2.2 单引号,和双引号 都可以声明 String s = ''; String s1 = '\"test\"'; String s2 = \"'sfasf'\"; print(s2); String s3 = \"沙发斯蒂芬\\n沙发斯蒂芬\"; //r前缀 row：原始 String s5 = r\"\\n\"; print(s5); print(s3); // 三引号 多行字符串声明 // 大厂思维, 不要用小厂思维 String s6 = \"\"\"sssss sfasfas sfasfas sfasfasdfs\"\"\"; print(s6); list : 数组,跟java 的list不一样,和java数组差不多 12345 List&lt;String&gt; list = new List();// List&lt;String&gt; list = List(); list.add(\"asfdsaf\"); String value = list[0]; print(value); map 123456789101112131415 /** * 映射集合 * */ Map&lt;int, int&gt; map = &#123;1: 1, 2: 2, 10: 4&#125;; print(map[10]); //Unhandled exception: //Unsupported operation: Cannot set value in unmodifiable Map// var map1 = const &#123;1: 1, 2: 2&#125;;// map1[3] = 10; for (var o in map.keys) &#123; print(o); &#125; bool Runes 1234567891011121314/** * Runes : 特殊字符表示类: Unicode32 * */ Runes ss = Runes(\"sfasdf\"); print(ss); // java String 本身是16位 //超过4位就要用 &#123;&#125; 这个括起来 // String 代码点，代码单元 String.length() 表现的跟字符长度一样的 // 后面增加到32位 一开始java设计string类的时候只有16位，认为这么多就可以了 // String.length() utf-8个个数 var clapping = '\\u&#123;1f44f&#125;'; print(clapping); Symbols 1234567891011/** * symbols 标识符 * */ var aaa = #sfaf; switch (aaa) &#123; case #afa: break; &#125; 三 操作符 类型转换和类型判断操作符 (as 和 is is! ) as 相当于 java中的强制转换 is 相当于 instanceof 这个关键字 is! 表示不是这个类的类型 赋值操作符 //这个叫安全赋值 objec x = A ??= B : 如果A是null的情况下选择B，否则选择A 条件表达式 123 * A ?? B 如果A 为null， 就返回B * 如果A不为null，就返回AA ?? A 级联操作 final List list2 = [];list2..add(1)..add(2)..add(3); //.. 是级联操作 安全操作符 kotlin里面貌似也常用这个操作符?. 123456/** * ?. 安全操作符 * */ String str; print(str?.length); 三 方法 一等方法对象 123456789101112typedef Function My(int x, int y);void fun(My f) &#123; f(10, 21);&#125;void main() &#123; Function f = (int i, int j) &#123; print(\"11111\" + i.toString()); &#125;; fun(f);&#125; 可选位置参数 [] 123void fun2([int x, int y]) &#123; print(x);&#125; 可选命名参数 123void fun3(&#123;int x, int y&#125;) &#123; print(x);&#125; 默认参数值 123void fun4(&#123;int x, int y = 10&#125;) &#123; print(x);&#125; 匿名方法 相当于lambda表达式 (v) { } 123var func = () &#123; print(\"Hello\"); &#125;; 四 异常 dart中的异常和java差不多 1","categories":[{"name":"flutter","slug":"flutter","permalink":"http://zhousaito.top/categories/flutter/"}],"tags":[{"name":"android flutter dart","slug":"android-flutter-dart","permalink":"http://zhousaito.top/tags/android-flutter-dart/"}],"author":"Zhousaito"},{"title":"android动画(转)","slug":"2019-06-30-动画","date":"2019-07-01T00:24:38.857Z","updated":"2019-11-14T00:14:35.462Z","comments":true,"path":"2019/07/01/2019-06-30-动画/","link":"","permalink":"http://zhousaito.top/2019/07/01/2019-06-30-%E5%8A%A8%E7%94%BB/","excerpt":"","text":"content{:toc} Android 动画View Animation（视图动画）概述:视图动画，也叫 Tween （补间）动画可以在一个视图容器内执行一系列简单变换（位置、大小、旋转、透明度）。 譬如，如果你有一个 TextView 对象，您可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。 补间动画通过 XML 或 Android 代码定义，建议使用 XML 文件定义，因为它更具可读性、可重用性 如下是视图动画相关的类继承关系： java 类名 xml 关键字 描述信息 AlphaAnimation &lt;alpha&gt; 放置在 res/anim/ 目录下 渐变透明度动画效果 RotateAnimation &lt;rotate&gt; 放置在 res/anim/ 目录下 画面转移旋转动画效果 ScaleAnimation &lt;scale&gt; 放置在 res/anim/ 目录下 渐变尺寸伸缩动画效果 TranslateAnimation &lt;translate&gt; 放置在 res/anim/ 目录下 画面转换位置移动动画效果 AnimationSet &lt;set&gt; 放置在 res/anim/ 目录下 一个持有其它动画元素 alpha、scale、translate、rotate 或者其它 set 元素的容器 通过上图和上表可以直观的看出来补间动画的关系及种类了，接下来我们就详细一个一个的介绍一下各种补间动画。 2. 视图动画详细说明可以看出来 Animation 抽象类是所有补间动画类的基类，所以基类会提供一些通用的动画属性方法，如下我们就来详细看看这些属性，。 2-1. Animation 属性详解 xml 属性 java 方法 解释 android:detachWallpaper setDetachWallpaper(boolean) 是否在壁纸上运行 android:duration setDuration(long) 动画持续时间，毫秒为单位 android:fillAfter setFillAfter(boolean) 控件动画结束时是否保持动画最后的状态 android:fillBefore setFillBefore(boolean) 控件动画结束时是否还原到开始动画前的状态 android:fillEnabled setFillEnabled(boolean) 与android:fillBefore效果相同 android:interpolator setInterpolator(Interpolator) 设定插值器（指定的动画效果，譬如回弹等） android:repeatCount setRepeatCount(int) 重复次数 android:repeatMode setRepeatMode(int) 重复类型有两个值，reverse表示倒序回放，restart表示从头播放 android:startOffset setStartOffset(long) 调用start函数之后等待开始运行的时间，单位为毫秒 android:zAdjustment setZAdjustment(int) 表示被设置动画的内容运行时在Z轴上的位置（top/bottom/normal），默认为normal 也就是说，无论我们补间动画的哪一种都已经具备了这种属性，也都可以设置使用这些属性中的一个或多个。 那接下来我们就看看每种补间动画特有的一些属性说明吧。 2-2. Alpha 属性详解 xml 属性 java方法 解释 android:fromAlpha AlphaAnimation(float fromAlpha, …) 动画开始的透明度（0.0到1.0，0.0是全透明，1.0是不透明） android:toAlpha AlphaAnimation(…, float toAlpha) 动画结束的透明度，同上 2-3. Rotate 属性详解 xml 属性 java方法 解释 android:fromDegrees RotateAnimation(float fromDegrees, …) 旋转开始角度，正代表顺时针度数，负代表逆时针度数 android:toDegrees RotateAnimation(…, float toDegrees, …) 旋转结束角度，正代表顺时针度数，负代表逆时针度数 android:pivotX RotateAnimation(…, float pivotX, …) 缩放起点X坐标（数值、百分数、百分数p，譬如50表示以当前View左上角坐标加50px为初始点、50%表示以当前View的左上角加上当前View宽高的50%做为初始点、50%p表示以当前View的左上角加上父控件宽高的50%做为初始点） android:pivotY RotateAnimation(…, float pivotY) 缩放起点Y坐标，同上规律 2-4. Scale 属性详解 xml 属性 java方法 解释 android:fromXScale ScaleAnimation(float fromX, …) 初始X轴缩放比例，1.0表示无变化 android:toXScale ScaleAnimation(…, float toX, …) 结束X轴缩放比例 android:fromYScale ScaleAnimation(…, float fromY, …) 初始Y轴缩放比例 android:toYScale ScaleAnimation(…, float toY, …) 结束Y轴缩放比例 android:pivotX ScaleAnimation(…, float pivotX, …) 缩放起点X轴坐标（数值、百分数、百分数p，譬如50表示以当前View左上角坐标加50px为初始点、50%表示以当前View的左上角加上当前View宽高的50%做为初始点、50%p表示以当前View的左上角加上父控件宽高的50%做为初始点） android:pivotY ScaleAnimation(…, float pivotY) 缩放起点Y轴坐标，同上规律 2-5. Translate 属性详解 xml 属性 java方法 解释 android:fromXDelta TranslateAnimation(float fromXDelta, …) 起始点X轴坐标（数值、百分数、百分数p，譬如50表示以当前View左上角坐标加50px为初始点、50%表示以当前View的左上角加上当前View宽高的50%做为初始点、50%p表示以当前View的左上角加上父控件宽高的50%做为初始点） android:fromYDelta TranslateAnimation(…, float fromYDelta, …) 起始点Y轴从标，同上规律 android:toXDelta TranslateAnimation(…, float toXDelta, …) 结束点X轴坐标，同上规律 android:toYDelta TranslateAnimation(…, float toYDelta) 结束点Y轴坐标，同上规律 2-6. AnimationSet 详解AnimationSet 继承自 Animation，是上面四种的组合容器管理类，没有自己特有的属性，他的属性继承自 Animation，所以特别注意， 当我们对 set 标签使用 Animation 的属性时会对该标签下的所有子控件都产生影响。 3. 视图动画使用方法通过上面对于动画的属性介绍之后我们来看看在 Android 中这些动画如何使用（PS：这里直接演示 xml 方式，至于 java 方式太简单了就不说了），如下： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:interpolator=\"@[package:]anim/interpolator_resource\" android:shareInterpolator=[\"true\" | \"false\"] &gt; &lt;alpha android:fromAlpha=\"float\" android:toAlpha=\"float\" /&gt; &lt;scale android:fromXScale=\"float\" android:toXScale=\"float\" android:fromYScale=\"float\" android:toYScale=\"float\" android:pivotX=\"float\" android:pivotY=\"float\" /&gt; &lt;translate android:fromXDelta=\"float\" android:toXDelta=\"float\" android:fromYDelta=\"float\" android:toYDelta=\"float\" /&gt; &lt;rotate android:fromDegrees=\"float\" android:toDegrees=\"float\" android:pivotX=\"float\" android:pivotY=\"float\" /&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 使用： 123ImageView spaceshipImage = (ImageView) findViewById(R.id.spaceshipImage);Animation hyperspaceJumpAnimation = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);spaceshipImage.startAnimation(hyperspaceJumpAnimation); 上面就是一个标准的使用我们定义的补间动画的模板。至于补间动画的使用，Animation 还有如下一些比较实用的方法介绍： Animation 类的方法 解释 reset() 重置 Animation 的初始化 cancel() 取消 Animation 动画 start() 开始 Animation 动画 setAnimationListener(AnimationListener listener) 给当前 Animation 设置动画监听 hasStarted() 判断当前 Animation 是否开始 hasEnded() 判断当前 Animation 是否结束 既然补间动画只能给 View 使用，那就来看看 View 中和动画相关的几个常用方法吧，如下： View类的常用动画操作方法 解释 startAnimation(Animation animation) 对当前 View 开始设置的 Animation 动画 clearAnimation() 取消当 View 在执行的 Animation 动画 到此整个 Android 的补间动画常用详细属性及方法全部介绍完毕，如有特殊的属性需求可以访问 Android Developer 查阅即可。如下我们就来个综合大演练。 4. 视图动画注意事项关于视图动画（补间动画）的例子我就不介绍了，网上简直多的都泛滥了。只是强调在使用补间动画时注意如下一点即可： 特别特别注意：补间动画执行之后并未改变 View 的真实布局属性值。切记这一点，譬如我们在 Activity 中有一个 Button 在屏幕上方， 我们设置了平移动画移动到屏幕下方然后保持动画最后执行状态呆在屏幕下方，这时如果点击屏幕下方动画执行之后的 Button 是没有任何反应的， 而点击原来屏幕上方没有 Button 的地方却响应的是点击Button的事件。 5. 视图动画 Interpolator 插值器详解 可以看见其实各种插值器都是实现了 Interpolator 接口而已，同时可以看见系统提供了许多已经实现 OK 的插值器，具体如下： java 类 xml id值 描述 AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator 动画始末速率较慢，中间加速 AccelerateInterpolator @android:anim/accelerate_interpolator 动画开始速率较慢，之后慢慢加速 AnticipateInterpolator @android:anim/anticipate_interpolator 开始的时候从后向前甩 AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator 类似上面 AnticipateInterpolator BounceInterpolator @android:anim/bounce_interpolator 动画结束时弹起 CycleInterpolator @android:anim/cycle_interpolator 循环播放速率改变为正弦曲线 DecelerateInterpolator @android:anim/decelerate_interpolator 动画开始快然后慢 LinearInterpolator @android:anim/linear_interpolator 动画匀速改变 OvershootInterpolator @android:anim/overshoot_interpolator 向前弹出一定值之后回到原来位置 PathInterpolator 新增，定义路径坐标后按照路径坐标来跑。 如上就是系统提供的一些插值器，下面我们来看看怎么使用他们。 5-2 插值器使用方法插值器的使用比较简答，如下： 123&lt;set android:interpolator=\"@android:anim/accelerate_interpolator\"&gt; ...&lt;/set&gt; 5-3 插值器的自定义有时候你会发现系统提供的插值器不够用，可能就像 View 一样需要自定义。所以接下来我们来看看插值器的自定义， 关于插值器的自定义分为两种实现方式，xml 自定义实现（其实就是对现有的插值器的一些属性修改）或者 java 代码实现方式。如下我们来说说。 先看看 XML 自定义插值器的步骤： 在 res/anim/ 目录下创建 filename.xml 文件。 修改你准备自定义的插值器如下： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;InterpolatorName xmlns:android=\"http://schemas.android.com/apk/res/android\" android:attribute_name=\"value\" /&gt; 在你的补间动画文件中引用该文件即可。 可以看见上面第二步修改的是现有插值器的一些属性，但是有些插值器却不具备修改属性，具体如下： 无可自定义的 attribute。 android:factor 浮点值，加速速率（默认值为1）。 android:tension 浮点值，起始点后拉的张力数（默认值为2）。 android:tension 浮点值，起始点后拉的张力数（默认值为2）。 android:extraTension 浮点值，拉力的倍数（默认值为1.5）。 无可自定义的 attribute。 android:cycles 整形，循环的个数（默认为1）。 android:factor 浮点值，减速的速率（默认为1）。 无可自定义的 attribute。 android:tension 浮点值，超出终点后的张力（默认为2）。 再来看看 Java 自定义插值器的（Java 自定义插值器其实是 xml 自定义的升级，也就是说如果我们修改 xml 的属性还不能满足需求，那就可以选择通过 Java 来实现）方式。 可以看见上面所有的 Interpolator 都实现了 Interpolator 接口，而 Interpolator 接口又继承自 TimeInterpolator， TimeInterpolator 接口定义了一个 float getInterpolation(float input);方法，这个方法是由系统调用的， 其中的参数 input 代表动画的时间，在 0 和 1 之间，也就是开始和结束之间。 如下就是一个动画始末速率较慢、中间加速的 AccelerateDecelerateInterpolator 插值器： 12345678public class AccelerateDecelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; ...... public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125; ......&#125; 到此整个补间动画与补间动画的插值器都分析完毕了。 Drawable Animation（Drawable动画）1. Drawable 动画概述Drawable 动画其实就是 Frame 动画（帧动画），它允许你实现像播放幻灯片一样的效果，这种动画的实质其实是 Drawable， 所以这种动画的 XML 定义方式文件一般放在 res/drawable/ 目录下。具体关于帧动画的 xml 使用方式翻墙点击我查看， java方式翻墙点击我查看。 如下图就是帧动画的源码文件： 可以看见实际的真实父类就是 Drawable。 2. Drawable 动画详细说明我们依旧可以使用 xml 或者 java 方式实现帧动画。但是依旧推荐使用 xml，具体如下： &lt;animation-list&gt; 必须是根节点，包含一个或者多个&lt;item&gt;元素，属性有： android:oneshot true 代表只执行一次，false 循环执行。 &lt;item&gt; 类似一帧的动画资源。 &lt;item&gt; animation-list 的子项，包含属性如下： android:drawable 一个 frame 的 Drawable 资源。 android:duration 一个 frame 显示多长时间。 3. Drawable 动画实例演示关于帧动画相对来说比较简单，这里给出一个常规使用框架，如下： 12345678&lt;!-- 注意：rocket.xml文件位于res/drawable/目录下 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource_name&quot; android:duration=&quot;integer&quot; /&gt;&lt;/animation-list&gt; 使用： 12345ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);rocketImage.setBackgroundResource(R.drawable.rocket_thrust);rocketAnimation = (AnimationDrawable) rocketImage.getBackground();rocketAnimation.start(); 特别注意，AnimationDrawable 的 start() 方法不能在 Activity 的 onCreate 方法中调运，因为 AnimationDrawable 还未完全附着到 window 上， 所以最好的调运时机是 onWindowFocusChanged() 方法中。 Property Animation（属性动画）使用详解在使用属性动画之前先来看几个常用的 View 属性成员： translationX，translationY：控制View的位置，值是相对于View容器左上角坐标的偏移。 rotationX，rotationY：控制相对于轴心旋转。 x，y：控制View在容器中的位置，即左上角坐标加上translationX和translationY的值。 alpha：控制View对象的alpha透明度值。 这几个常用的属性相信大家都很熟悉，接下来的属性动画我们就从这里展开。 1. 属性动画概述Android 3.0 以后引入了属性动画，属性动画可以轻而易举的实现许多 View 动画做不到的事， 上面也看见了，View动画无非也就做那几种事情，别的也搞不定，而属性动画就可以的， 譬如3D旋转一张图片。其实说白了，你记住一点就行，属性动画实现原理就是修改控件的属性值实现的动画。 具体先看下类关系： 1234567/** * This is the superclass for classes which provide basic support for animations which can be * started, ended, and have &lt;code&gt;AnimatorListeners&lt;/code&gt; added to them. */public abstract class Animator implements Cloneable &#123; ......&#125; 所有的属性动画的抽象基类就是他。我们看下他的实现子类： java 类名 xml 关键字 描述信息 ValueAnimator &lt;animator&gt; 放置在 res/animator/ 目录下 在一个特定的时间里执行一个动画 TimeAnimator 不支持/点我查看原因 时序监听回调工具 ObjectAnimator &lt;objectAnimator&gt; 放置在 res/animator/ 目录下 一个对象的一个属性动画 AnimatorSet &lt;set&gt; 放置在 res/animator/ 目录下 动画集合 所以可以看见，我们平时使用属性动画的重点就在于 AnimatorSet、ObjectAnimator、TimeAnimator、ValueAnimator。 所以接下来我们就来依次说说如何使用。 2. 属性动画详细说明2-1 属性动画计算原理Android 属性动画（注意最低兼容版本，不过可以使用开源项目来替代低版本问题）提供了以下属性： Duration：动画的持续时间； TimeInterpolation：定义动画变化速率的接口，所有插值器都必须实现此接口，如线性、非线性插值器； TypeEvaluator：用于定义属性值计算方式的接口，有 int、float、color 类型，根据属性的起始、结束值和插值一起计算出当前时间的属性值； Animation sets：动画集合，即可以同时对一个对象应用多个动画，这些动画可以同时播放也可以对不同动画设置不同的延迟； Frame refreash delay：多少时间刷新一次，即每隔多少时间计算一次属性值，默认为 10ms，最终刷新时间还受系统进程调度与硬件的影响； Repeat Country and behavoir：重复次数与方式，如播放3次、5次、无限循环，可以让此动画一直重复，或播放完时向反向播放； 接下来先来看官方为了解释原理给出的两幅图（其实就是初中物理题，不解释）： [![Example of a linear animation] 上面就是一个线性匀速动画，描述了一个 Object 的 X 属性运动动画，该对象的X坐标在 40ms 内从 0 移动到 40， 每 10ms 刷新一次，移动 4 次，每次移动为 40/4=10pixel。 [![Example of a non-linear animation] 上面是一个非匀速动画，描述了一个 Object 的 X 属性运动动画，该对象的 X 坐标在 40ms 内从 0 移动到 40，每 10ms 刷新一次，移动4次， 但是速率不同，开始和结束的速度要比中间部分慢，即先加速后减速。 接下来我们来详细的看一下，属性动画系统的重要组成部分是如何计算动画值的，下图描述了如上面所示动画的实现作用过程。 [![How animation are calculated] 其中的 ValueAnimator 是动画的执行类，跟踪了当前动画的执行时间和当前时间下的属性值； ValueAnimator 封装了动画的 TimeInterpolator 时间插值器和一个 TypeEvaluator 类型估值，用于设置动画属性的值， 就像上面图2非线性动画里，TimeInterpolator 使用了 AccelerateDecelerateInterpolator、TypeEvaluator 使用了 IntEvaluator。 为了执行一个动画，你需要创建一个 ValueAnimator，并且指定目标对象属性的开始、结束值和持续时间。在调用 start 后， 整个动画过程中， ValueAnimator 会根据已经完成的动画时间计算得到一个 0 到 1 之间的分数，代表该动画的已完成动画百分比。 0 表示 0%，1 表示 100%，譬如上面图一线性匀速动画中总时间 t = 40 ms，t = 10 ms 的时候是 0.25。 当 ValueAnimator 计算完已完成动画分数后，它会调用当前设置的 TimeInterpolator， 去计算得到一个 interpolated（插值）分数，在计算过程中，已完成动画百分比会被加入到新的插值计算中。 如上图 2 非线性动画中，因为动画的运动是缓慢加速的，它的插值分数大约是 0.15，小于 t = 10ms 时的已完成动画分数 0.25。 而在上图1中，这个插值分数一直和已完成动画分数是相同的。 当插值分数计算完成后，ValueAnimator 会根据插值分数调用合适的 TypeEvaluator 去计算运动中的属性值。 好了，现在我们来看下代码就明白这段话了，上面图2非线性动画里，TimeInterpolator 使用了 AccelerateDecelerateInterpolator、 TypeEvaluator 使用了 IntEvaluator。所以这些类都是标准的API，我们来看下标准API就能类比自己写了，如下： 首先计算已完成动画时间分数（以 10ms 为例）：t=10ms/40ms=0.25。 接着看如下源码如何实现计算差值分数的： 1234567891011public class AccelerateDecelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; public AccelerateDecelerateInterpolator() &#123; &#125; ...... //这是我们关注重点，可以发现如下计算公式计算后（input即为时间因子）插值大约为0.15。 public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125; ......&#125; 其实 AccelerateDecelerateInterpolator 的基类接口就是 TimeInterpolator，如下，他只有 getInterpolation 方法， 也就是上面我们关注的方法。 123public interface TimeInterpolator &#123; float getInterpolation(float input);&#125; 接着 ValueAnimator 会根据插值分数调用合适的 TypeEvaluator（IntEvaluator） 去计算运动中的属性值， 如下，因为 startValue = 0，所以属性值：0+0.15*（40-0）= 6。 123456public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 这就是官方给的一个关于属性动画实现的过程及基本原理解释，相信你看到这里是会有些迷糊的，没关系，你先有个大致概念就行， 接下来我们会慢慢进入实战，因为 Android 的属性动画相对于其他动画来说涉及的知识点本来就比较复杂，所以我们慢慢来。 2-2 XML 方式属性动画在 xml 中(放在 res/animator/filename.xml )可直接用的属性动画节点有 ValueAnimator、ObjectAnimator、AnimatorSet。 1234567891011121314151617181920212223242526&lt;set android:ordering=[\"together\" | \"sequentially\"]&gt; &lt;objectAnimator android:propertyName=\"string\" android:duration=\"int\" android:valueFrom=\"float | int | color\" android:valueTo=\"float | int | color\" android:startOffset=\"int\" android:repeatCount=\"int\" android:repeatMode=[\"repeat\" | \"reverse\"] android:valueType=[\"intType\" | \"floatType\"]/&gt; &lt;animator android:duration=\"int\" android:valueFrom=\"float | int | color\" android:valueTo=\"float | int | color\" android:startOffset=\"int\" android:repeatCount=\"int\" android:repeatMode=[\"repeat\" | \"reverse\"] android:valueType=[\"intType\" | \"floatType\"]/&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; &lt;set&gt; 属性解释： xml 属性 解释 android:ordering 控制子动画启动方式是先后有序的还是同时进行。sequentially: 动画按照先后顺序；together(默认): 动画同时启动； &lt;objectAnimator&gt; 属性解释： xml属性 解释 android:propertyName String 类型，必须要设置的节点属性，代表要执行动画的属性（通过名字引用），辟如你可以指定了一个View的”alpha” 或者 “backgroundColor” ，这个objectAnimator元素没有对外说明target属性，所以你不能在XML中设置执行这个动画，必须通过调用loadAnimator()方法加载你的XML动画资源，然后调用setTarget()应用到具备这个属性的目标对象上（譬如TextView）。 android:valueTo float、int 或者 color 类型，必须要设置的节点属性，表明动画结束的点；如果是颜色的话，由 6 位十六进制的数字表示。 android:valueFrom 相对应 valueTo，动画的起始点，如果没有指定，系统会通过属性的 get 方法获取，颜色也是 6 位十六进制的数字表示。 android:duration 动画的时长，int 类型，以毫秒为单位，默认为 300 毫秒。 android:startOffset 动画延迟的时间，从调用 start 方法后开始计算，int 型，毫秒为单位。 android:repeatCount 一个动画的重复次数，int 型，”-1“表示无限循环，”1“表示动画在第一次执行完成后重复执行一次，也就是两次，默认为0，不重复执行。 android:repeatMode 重复模式：int 型，当一个动画执行完的时候应该如何处理。该值必须是正数或者是-1，“reverse”会使得按照动画向相反的方向执行，可实现类似钟摆效果。“repeat”会使得动画每次都从头开始循环。 android:valueType 关键参数，如果该 value 是一个颜色，那么就不需要指定，因为动画框架会自动的处理颜色值。有 intType 和 floatType（默认）两种：分别说明动画值为 int 和 float 型。 &lt;objectAnimator&gt; 属性解释：同上 &lt;objectAnimator&gt; 属性，不多介绍。 XML 属性动画使用方法： 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.animtor.property_animator);set.setTarget(myObject);set.start(); 2-3 Java 方式属性动画1、ObjectAnimator：继承自 ValueAnimator，允许你指定要进行动画的对象以及该对象的一个属性。该类会根据计算得到的新值自动更新属性。 大多数的情况使用 ObjectAnimator 就足够了，因为它使得目标对象动画值的处理过程变得足够简单， 不用像 ValueAnimator 那样自己写动画更新的逻辑，但是 ObjectAnimator 有一定的限制，比如它需要目标对象的属性提供指定的处理方法 （譬如提供getXXX，setXXX 方法），这时候你就需要根据自己的需求在 ObjectAnimator 和 ValueAnimator 中看哪种实现更方便了。 ObjectAnimator 类提供了 ofInt、ofFloat、ofObject 这个三个常用的方法，这些方法都是设置动画作用的元素、属性、开始、结束等任意属性值。 当属性值（上面方法的参数）只设置一个时就把通过getXXX反射获取的值作为起点，设置的值作为终点；如果设置两个（参数）， 那么一个是开始、另一个是结束。 特别注意：ObjectAnimator 的动画原理是不停的调用 setXXX 方法更新属性值，所有使用 ObjectAnimator 更新属性时的前提是 Object 必须声明有getXXX和setXXX方法。 我们通常使用 ObjectAnimator 设置 View 已知的属性来生成动画，而一般 View 已知属性变化时都会主动触发重绘图操作， 所以动画会自动实现；但是也有特殊情况，譬如作用 Object 不是 View，或者作用的属性没有触发重绘，或者我们在重绘时需要做自己的操作， 那都可以通过如下方法手动设置： 12345678910111213ObjectAnimator mObjectAnimator= ObjectAnimator.ofInt(view, &quot;customerDefineAnyThingName&quot;, 0, 1).setDuration(2000);mObjectAnimator.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //int value = animation.getAnimatedValue(); 可以获取当前属性值 //view.postInvalidate(); 可以主动刷新 //view.setXXX(value); //view.setXXX(value); //......可以批量修改属性 &#125; &#125;); 如下是一个我在项目中的Y轴3D旋转动画实现实例： 1ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 0.0f, 360.0f).setDuration(1000).start(); 2、PropertyValuesHolder：多属性动画同时工作管理类。有时候我们需要同时修改多个属性，那就可以用到此类，具体如下： 1234PropertyValuesHolder a1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f, 1f); PropertyValuesHolder a2 = PropertyValuesHolder.ofFloat(&quot;translationY&quot;, 0, viewWidth); ......ObjectAnimator.ofPropertyValuesHolder(view, a1, a2, ......).setDuration(1000).start(); 如上代码就可以实现同时修改多个属性的动画啦。 3、ValueAnimator：属性动画中的时间驱动，管理着动画时间的开始、结束属性值，相应时间属性值计算方法等。包含所有计算动画值的核心函数以及每一个 动画时间节点上的信息、一个动画是否重复、是否监听更新事件等，并且还可以设置自定义的计算类型。 特别注意：ValueAnimator 只是动画计算管理驱动，设置了作用目标，但没有设置属性，需要通过 updateListener 里设置属性才会生效。 1234567891011ValueAnimator animator = ValueAnimator.ofFloat(0, mContentHeight); //定义动画animator.setTarget(view); //设置作用目标animator.setDuration(5000).start();animator.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation)&#123; float value = (float) animation.getAnimatedValue(); view.setXXX(value); //必须通过这里设置属性值才有效 view.mXXX = value; //不需要setXXX属性方法 &#125;&#125;); 大眼看上去可以发现和 ObjectAnimator 没啥区别，实际上正是由于 ValueAnimator 不直接操作属性值， 所以要操作对象的属性可以不需要 setXXX 与 getXXX 方法，你完全可以通过当前动画的计算去修改任何属性。 4、AnimationSet：动画集合，提供把多个动画组合成一个组合的机制，并可设置动画的时序关系，如同时播放、顺序播放或延迟播放。具体使用方法比较简单， 如下： 12345678910ObjectAnimator a1 = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1.0f, 0f); ObjectAnimator a2 = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, viewWidth); ......AnimatorSet animSet = new AnimatorSet(); animSet.setDuration(5000); animSet.setInterpolator(new LinearInterpolator()); //animSet.playTogether(a1, a2, ...); //两个动画同时执行 animSet.play(a1).after(a2); //先后执行......//其他组合方式animSet.start(); 5、Evaluators 相关类解释：Evaluators 就是属性动画系统如何去计算一个属性值。它们通过 Animator 提供的动画的起始和结束值去计算一个动画的属性值。 IntEvaluator：整数属性值。 FloatEvaluator：浮点数属性值。 ArgbEvaluator：十六进制color属性值。 TypeEvaluator：用户自定义属性值接口，譬如对象属性值类型不是 int、float、color 类型， 你必须实现这个接口去定义自己的数据类型。 既然说到这了，那就来个例子吧，譬如我们需要实现一个自定义属性类型和计算规则的属性动画，如下类型 float[]： 1234567891011121314151617181920212223242526272829ValueAnimator valueAnimator = new ValueAnimator();valueAnimator.setDuration(5000);valueAnimator.setObjectValues(new float[2]); //设置属性值类型valueAnimator.setInterpolator(new LinearInterpolator());valueAnimator.setEvaluator(new TypeEvaluator&lt;float[]&gt;()&#123; @Override public float[] evaluate(float fraction, float[] startValue, float[] endValue) &#123; //实现自定义规则计算的float[]类型的属性值 float[] temp = new float[2]; temp[0] = fraction * 2; temp[1] = (float)Math.random() * 10 * fraction; return temp; &#125;&#125;);valueAnimator.start();valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()&#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float[] xyPos = (float[]) animation.getAnimatedValue(); view.setHeight(xyPos[0]); //通过属性值设置View属性动画 view.setWidth(xyPos[1]); //通过属性值设置View属性动画 &#125;&#125;); 6、Interpolators 相关类解释： AccelerateDecelerateInterpolator：先加速后减速。 AccelerateInterpolator：加速。 DecelerateInterpolator：减速。 AnticipateInterpolator：先向相反方向改变一段再加速播放。 AnticipateOvershootInterpolator：先向相反方向改变，再加速播放，会超出目标值然后缓慢移动至目标值，类似于弹簧回弹。 BounceInterpolator：快到目标值时值会跳跃。 CycleIinterpolator：动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)。 LinearInterpolator：线性均匀改变。 OvershottInterpolator：最后超出目标值然后缓慢改变到目标值。 TimeInterpolator：一个允许自定义 Interpolator 的接口，以上都实现了该接口。 举个例子，就像系统提供的标准 API 一样，如下就是加速插值器的实现代码，我们自定义时也可以类似实现： 123456789101112131415161718192021222324//开始很慢然后不断加速的插值器。public class AccelerateInterpolator implements Interpolator &#123; private final float mFactor; private final double mDoubleFactor; public AccelerateInterpolator() &#123; mFactor = 1.0f; mDoubleFactor = 2.0; &#125; ...... //input 0到1.0。表示动画当前点的值，0表示开头，1表示结尾。 //return 插值。值可以大于1超出目标值，也可以小于0突破低值。 @Override public float getInterpolation(float input) &#123; //实现核心代码块 if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125; &#125;&#125; 综上可以发现，我们可以使用现有系统提供标准的东东实现属性动画，也可以通过自定义继承相关接口实现自己的动画， 只要实现上面提到的那些主要方法即可。 2-4 Java 属性动画拓展之 ViewPropertyAnimator 动画在 Android API 12 时，View 中添加了 animate 方法，具体如下： 1234567891011121314151617public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource &#123; ...... /** * This method returns a ViewPropertyAnimator object, which can be used to animate * specific properties on this View. * * @return ViewPropertyAnimator The ViewPropertyAnimator associated with this View. */ public ViewPropertyAnimator animate() &#123; if (mAnimator == null) &#123; mAnimator = new ViewPropertyAnimator(this); &#125; return mAnimator; &#125; ......&#125; 可以看见通过 View 的 animate() 方法可以得到一个 ViewPropertyAnimator 的属性动画 （有人说他没有继承 Animator 类，是的，他是成员关系，不是之前那种继承关系）。 ViewPropertyAnimator 提供了一种非常方便的方法为 View 的部分属性设置动画（切记，是部分属性）， 它可以直接使用一个 Animator 对象设置多个属性的动画；在多属性设置动画时，它比上面的 ObjectAnimator 更加牛逼、高效， 因为他会管理多个属性的 invalidate 方法统一调运触发，而不像上面分别调用，所以还会有一些性能优化。如下就是一个例子： 1myView.animate().x(0f).y(100f).start(); 2-5 Java 属性动画拓展之 LayoutAnimator 容器布局动画Property 动画系统还提供了对 ViewGroup 中 View 添加时的动画功能， 我们可以用 LayoutTransition 对 ViewGroup 中的 View 进行动画设置显示。 LayoutTransition 的动画效果都是设置给 ViewGroup，然后当被设置动画的 ViewGroup 中添加删除 View 时体现出来。 该类用于当前布局容器中有 View 添加、删除、隐藏、显示等时候定义布局容器自身的动画和 View 的动画， 也就是说当在一个 LinerLayout 中隐藏一个 View 的时候，我们可以自定义 整个由于 LinerLayout 隐藏 View 而改变的动画， 同时还可以自定义被隐藏的 View 自己消失时候的动画等。 我们可以发现 LayoutTransition 类中主要有五种容器转换动画类型，具体如下： LayoutTransition.APPEARING：当 View 出现或者添加的时候 View 出现的动画。 LayoutTransition.CHANGE_APPEARING：当添加 View 导致布局容器改变的时候整个布局容器的动画。 LayoutTransition.DISAPPEARING：当View消失或者隐藏的时候 View 消失的动画。 LayoutTransition.CHANGE_DISAPPEARING：当删除或者隐藏 View 导致布局容器改变的时候整个布局容器的动画。 LayoutTransition.CHANGE：当不是由于 View 出现或消失造成对其他 View 位置造成改变的时候整个布局容器的动画。 XML 方式使用系统提供的默认 LayoutTransition 动画： 我们可以通过如下方式使用系统提供的默认 ViewGroup 的 LayoutTransition 动画： 1android:animateLayoutChanges=”true” 在 ViewGroup 添加如上 xml 属性默认是没有任何动画效果的，因为前面说了，该动画针对于 ViewGroup 内部东东发生改变时才有效， 所以当我们设置如上属性然后调运 ViewGroup 的 addView、removeView 方法时就能看见系统默认的动画效果了。 还有一种就是通过如下方式设置： 1android:layoutAnimation=”@anim/customer_anim” 通过这种方式就能实现很多吊炸天的动画。 Java 方式使用系统提供的默认 LayoutTransition 动画： 在使用 LayoutTransition 时，你可以自定义这几种事件类型的动画，也可以使用默认的动画， 总之最终都是通过 setLayoutTransition(LayoutTransition lt) 方法把这些动画以一个 LayoutTransition 对象设置给一个 ViewGroup。 譬如实现如上 Xml 方式的默认系统 LayoutTransition 动画如下： 12mTransitioner = new LayoutTransition();mViewGroup.setLayoutTransition(mTransitioner); 稍微再高端一点吧，我们来自定义这几类事件的动画，分别实现他们，那么你可以像下面这么处理： 123456mTransitioner = new LayoutTransition();......ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"scaleX\", 0, 1);......//设置更多动画mTransition.setAnimator(LayoutTransition.APPEARING, anim);......//设置更多类型的动画 mViewGroup.setLayoutTransition(mTransitioner); 到此通过 LayoutTransition 你就能实现类似小米手机计算器切换普通型和科学型的炫酷动画了。 3. ViewPropertyAnimator 动画(属性动画拓展)3-1 ViewPropertyAnimator 概述通过上面的学习，我们应该明白了属性动画的推出已不再是针对于 View 而进行设计的了，而是一种对数值不断操作的过程， 我们可以将属性动画对数值的操作过程设置到指定对象的属性上来，从而形成一种动画的效果。虽然属性动画给我们提供了 ValueAnimator 类 和 ObjectAnimator 类，在正常情况下，基本都能满足我们对动画操作的需求，但 ValueAnimator 类和 ObjectAnimator 类 本身并不是针对 View 对象的而设计的，而我们在大多数情况下主要都还是对 View 进行动画操作的，因此 Google 官方在 Android 3.1 系统中补充了 ViewPropertyAnimator 类，这个类便是专门为 View 动画而设计的。当然这个类不仅仅是为提供 View 而简单设计的， 它存在以下优点： 专门针对View对象动画而操作的类。 提供了更简洁的链式调用设置多个属性动画，这些动画可以同时进行的。 拥有更好的性能，多个属性动画是一次同时变化，只执行一次UI刷新（也就是只调用一次 invalidate ,而 n 个 ObjectAnimator 就会 进行 n 次属性变化，就有 n 次 invalidate）。 每个属性提供两种类型方法设置。 该类只能通过 View 的 animate() 获取其实例对象的引用 好~，下面我们来了解一下 ViewPropertyAnimator 常规使用 3-2 ViewPropertyAnimator 常规使用之前我们要设置一个View控件旋转 360 的代码是这样： 1ObjectAnimator.ofFloat(btn,\"rotation\",360).setDuration(200).start(); 而现在我们使用 ViewPropertyAnimator 后是这样： 1btn.animate().rotation(360).setDuration(200); 代码是不是特简洁？这里我们来解析一下，首先必须用 View#animate() 方法来获取一个 ViewPropertyAnimator 的对象实例， 前面我们说过 ViewPropertyAnimator 支持链式操作，所以这里直接通过 rotation 方法设置旋转角度，再设置时间即可， 有没有发现连动画的启动都不用我们去操作！是的，ViewPropertyAnimator 内部会自动去调用。对于 View#animate() 方法，这里再说明一下，animate() 方法是在 Android 3.1 系统上新增的一个方法，其作用就是返回 ViewPropertyAnimator 的实例对象，其源码如下，一目了然： 123456789101112 /** * This method returns a ViewPropertyAnimator object, which can be used to animate * specific properties on this View. * * @return ViewPropertyAnimator The ViewPropertyAnimator associated with this View. */public ViewPropertyAnimator animate() &#123; if (mAnimator == null) &#123; mAnimator = new ViewPropertyAnimator(this); &#125; return mAnimator;&#125; 可以看见通过 View 的 animate() 方法可以得到一个 ViewPropertyAnimator 的属性动画（有人说他没有继承 Animator 类，是的， 他是成员关系，不是之前那种继承关系）。 接着我们再来试试别的方法，同时设置一组动画集合如下： 123456789AnimatorSet set = new AnimatorSet();set.playTogether( ObjectAnimator.ofFloat(btn,\"alpha\",0.5f), ObjectAnimator.ofFloat(btn,\"rotation\",360), ObjectAnimator.ofFloat(btn,\"scaleX\",1.5f), ObjectAnimator.ofFloat(btn,\"scaleY\",1.5f), ObjectAnimator.ofFloat(btn,\"translationX\",0,50), ObjectAnimator.ofFloat(btn,\"translationY\",0,50));set.setDuration(5000).start(); 使用 ViewPropertyAnimator 设置代码如下： 12btn.animate().alpha(0.5f).rotation(360).scaleX(1.5f).scaleY(1.5f) .translationX(50).translationY(50).setDuration(5000); 是不是已经深深地爱上 ViewPropertyAnimator ？真的太简洁了！都快感动地哭出来了……先去厕所哭会…….好吧， ViewPropertyAnimator 简单用法讲完了，这里小结一下 ViewPropertyAnimator 的常用方法： Method Discription alpha(float value) 设置透明度，value表示变化到多少，1不透明，0全透明。 scaleY(float value) 设置Y轴方向的缩放大小，value表示缩放到多少。1表示正常规格。小于1代表缩小，大于1代表放大。 scaleX(float value) 设置X轴方向的缩放大小，value表示缩放到多少。1表示正常规格。小于1代表缩小，大于1代表放大。 translationY(float value) 设置Y轴方向的移动值，作为增量来控制View对象相对于它父容器的左上角坐标偏移的位置，即移动到哪里。 translationX(float value) 设置X轴方向的移动值，作为增量来控制View对象相对于它父容器的左上角坐标偏移的位置。 rotation(float value) 控制View对象围绕支点进行旋转， rotation针对2D旋转 rotationX (float value) 控制View对象围绕X支点进行旋转， rotationX针对3D旋转 rotationY(float value) 控制View对象围绕Y支点进行旋转， rotationY针对3D旋转 x(float value) 控制View对象相对于它父容器的左上角坐标在X轴方向的最终位置。 y(float value) 控制View对象相对于它父容器的左上角坐标在Y轴方向的最终位置 void cancel() 取消当前正在执行的动画 setListener(Animator.AnimatorListener listener) 设置监听器，监听动画的开始，结束，取消，重复播放 setUpdateListener(ValueAnimator.AnimatorUpdateListener listener) 设置监听器，监听动画的每一帧的播放 setInterpolator(TimeInterpolator interpolator) 设置插值器 setStartDelay(long startDelay) 设置动画延长开始的时间 setDuration(long duration) 设置动画执行的时间 withLayer() 设置是否开启硬件加速 withStartAction(Runnable runnable) 设置用于动画监听开始（Animator.AnimatorListener）时运行的Runnable任务对象 withEndAction(Runnable runnable) 设置用于动画监听结束（Animator.AnimatorListener）时运行的Runnable任务对象 以上便是 ViewPropertyAnimator 一些操作方法，其实上面很多属性设置方法都对应着一个By结尾的方法，其变量则代表的是变化量，如下： 我们看看其中 scaleY 与 scaleYBy 的实现： 123456789public ViewPropertyAnimator scaleY(float value) &#123; animateProperty(SCALE_Y, value); return this; &#125;public ViewPropertyAnimator scaleYBy(float value) &#123; animatePropertyBy(SCALE_Y, value); return this;&#125; 再看看 animateProperty() 与 animatePropertyBy() 12345678910private void animateProperty(int constantName, float toValue) &#123; float fromValue = getValue(constantName); float deltaValue = toValue - fromValue; animatePropertyBy(constantName, fromValue, deltaValue);&#125;private void animatePropertyBy(int constantName, float byValue) &#123; float fromValue = getValue(constantName); animatePropertyBy(constantName, fromValue, byValue);&#125; 看了源码现在应该很清楚有By结尾（代表变化量的大小）和没By结尾（代表变化到多少）的方法的区别了吧。好~，再来看看监听器， 实际上我们可以通过 setListener(Animator.AnimatorListener listener) 和 setUpdateListener(ValueAnimator.AnimatorUpdateListener listener)设置自定义监听器，而在 ViewPropertyAnimator 内部也有自己实现的监听器，同样我们可以看一下其实现源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private class AnimatorEventListener implements Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener &#123; @Override public void onAnimationStart(Animator animation) &#123; //调用了设置硬件加速的Runnable if (mAnimatorSetupMap != null) &#123; Runnable r = mAnimatorSetupMap.get(animation); if (r != null) &#123; r.run(); &#125; mAnimatorSetupMap.remove(animation); &#125; if (mAnimatorOnStartMap != null) &#123; //调用我们通过withStartAction(Runnable runnable)方法设置的runnable Runnable r = mAnimatorOnStartMap.get(animation); if (r != null) &#123; r.run(); &#125; mAnimatorOnStartMap.remove(animation); &#125; if (mListener != null) &#123; //调用我们自定义的监听器方法 mListener.onAnimationStart(animation); &#125; &#125; @Override public void onAnimationCancel(Animator animation) &#123; if (mListener != null) &#123; //调用我们自定义的监听器方法 mListener.onAnimationCancel(animation); &#125; if (mAnimatorOnEndMap != null) &#123; mAnimatorOnEndMap.remove(animation); &#125; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; if (mListener != null) &#123; //调用我们自定义的监听器方法 mListener.onAnimationRepeat(animation); &#125; &#125; @Override public void onAnimationEnd(Animator animation) &#123; mView.setHasTransientState(false); if (mListener != null) &#123; //调用我们自定义的监听器方法 mListener.onAnimationEnd(animation); &#125; if (mAnimatorOnEndMap != null) &#123; //调用我们通过withEndAction(Runnable runnable)方法设置的runnable Runnable r = mAnimatorOnEndMap.get(animation); if (r != null) &#123; r.run(); &#125; mAnimatorOnEndMap.remove(animation); &#125; if (mAnimatorCleanupMap != null) &#123; //移除硬件加速 Runnable r = mAnimatorCleanupMap.get(animation); if (r != null) &#123; r.run(); &#125; mAnimatorCleanupMap.remove(animation); &#125; mAnimatorMap.remove(animation); &#125;&#125; 由源码我们知道当监听器仅需要监听动画的开始和结束时，我们可以通过 withStartAction(Runnable runnable) 和 withEndAction(Runnable runnable) 方法来设置一些特殊的监听操作。在 AnimatorEventListener 中的开始事件还会判断是否开启硬件加速，当然在动画结束时也会去关闭硬件加速。 我们可以通过 ViewPropertyAnimator #withLayer() 方法开启硬件加速功能。到此对于 ViewPropertyAnimator 的常规使用方式 已很清晰了。 3-3 ViewPropertyAnimator 原理解析ViewPropertyAnimator 原理解析我们先通过一副图来大概了解一下 ViewPropertyAnimator 内部的整体运行工作原理 ViewPropertyAnimator 我们这里先给出整体执行流程（有个整体的概念就行哈，不理解也没有关系，看完下面的分析，再回来来看看也是可以），然后再详细分析： 通过 imageView.animate() 获取 ViewPropertyAnimator 对象。 调用 alpha、translationX 等方法，返回当前 ViewPropertyAnimator 对象，可以继续链式调用 alpha、translationX 等方法内部最终调用 animatePropertyBy(int constantName, float startValue, float byValue)方法 在 animatePropertyBy 方法中则会将 alpha、translationX 等方法的操作封装成 NameVauleHolder，并将每个 NameValueHolder 对象添加到准备列表 mPendingAnimations 中。 animatePropertyBy 方法启动 mAnimationStarter，调用startAnimation，开始动画。 startAnimation 方法中会创建一个 ValueAnimator 对象设置内部监听器 AnimatorEventListener，并将 mPendingAnimations 和 要进行动画的属性名称封装成一个 PropertyBundle 对象，最后 mAnimatorMap 保存当前 Animator 和对应的P ropertyBundle 对象。 该Map将会在 animatePropertyBy 方法和 Animator 监听器 mAnimatorEventListener 中使用，启动动画。 在动画的监听器的 onAnimationUpdate 方法中设置所有属性的变化值，并通过RenderNode类优化绘制性能，最后刷新界面。 有了整体概念后，现在我们沿着该工作流程图的路线来分析 ViewPropertyAnimator内部执行过程，从上图可以看出，通过 View#animate() 获取 到 ViewPropertyAnimator 实例后，可以通过 ViewPropertyAnimator 提供的多种方法来设置动画，如 translationX()、scaleX() 等等， 而当调用完这些方法后，其内部最终则会通过多次调用 animatorPropertyBy()，我们先看看 animatePropertyBy 方法源码： 123456789101112131415161718192021222324252627282930313233343536373839/** * Utility function, called by animateProperty() and animatePropertyBy(), which handles the * details of adding a pending animation and posting the request to start the animation. * * @param constantName The specifier for the property being animated * @param startValue The starting value of the property * @param byValue The amount by which the property will change */private void animatePropertyBy(int constantName, float startValue, float byValue) &#123; // First, cancel any existing animations on this property //判断该属性上是否存在运行的动画，存在则结束。 if (mAnimatorMap.size() &gt; 0) &#123; Animator animatorToCancel = null; Set&lt;Animator&gt; animatorSet = mAnimatorMap.keySet(); for (Animator runningAnim : animatorSet) &#123; PropertyBundle bundle = mAnimatorMap.get(runningAnim); if (bundle.cancel(constantName)) &#123;// 结束对应属性动画 // property was canceled - cancel the animation if it's now empty // Note that it's safe to break out here because every new animation // on a property will cancel a previous animation on that property, so // there can only ever be one such animation running. if (bundle.mPropertyMask == NONE) &#123;//判断是否还有其他属性 // the animation is no longer changing anything - cancel it animatorToCancel = runningAnim; break; &#125; &#125; &#125; if (animatorToCancel != null) &#123; animatorToCancel.cancel(); &#125; &#125; //将要执行的属性的名称，开始值，变化值封装成NameValuesHolder对象 NameValuesHolder nameValuePair = new NameValuesHolder(constantName, startValue, byValue); //添加到准备列表中 mPendingAnimations.add(nameValuePair); mView.removeCallbacks(mAnimationStarter); mView.postOnAnimation(mAnimationStarter);&#125; 从源码可以看出，animatePropertyBy 方法主要干了以下几件事： 首先会去当前属性是否还有在动画在执行，如果有则先结束该属性上的动画，保证该属性上只有一个 Animator 在进行动画操作。将本次动画需要执行的动画属性封装成一个NameValueHolder对象将每个 NameValuesHolder 对象添加到 mPendingAnimations 的准备列表中NameValuesHolder对象是一个内部类，其相关信息如下:NameValueHolder：内部类，封装每个要进行动画属性值开始值和变化值，比如 translationX(200)，那么这个动画的属性值、 开始值和变化值将被封装成一个 NameValueHolder，其源码也非常简单： 12345678910static class NameValuesHolder &#123; int mNameConstant;//要进行动画的属性名称 float mFromValue;//开始值 float mDeltaValue;//变化值 NameValuesHolder(int nameConstant, float fromValue, float deltaValue) &#123; mNameConstant = nameConstant; mFromValue = fromValue; mDeltaValue = deltaValue; &#125;&#125; 而 mPendingAnimations 的相关信息如下：mPendingAnimations：装载的是准备进行动画的属性值（NameValueHolder）所有列表，也就是每次要同时进行动画的全部属性的集合 ArrayList mPendingAnimations = new ArrayList();当添加完每个要运行的属性动画后，则会通过 mAnimationStarter 对象去调用 startAnimation()，启动动画。 Runnable mAnimationStarter：用来执行动画的 Runnable。它会执行 startAnimation 方法，而在 startAnimation 方法中 会通过 animator.start() 启动动画，源码非常简洁： 123456private Runnable mAnimationStarter = new Runnable() &#123; @Override public void run() &#123; startAnimation(); &#125;&#125;; 接着我们看看 startAnimation() 的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Starts the underlying Animator for a set of properties. We use a single animator that * simply runs from 0 to 1, and then use that fractional value to set each property * value accordingly. */private void startAnimation() &#123; if (mRTBackend != null &amp;&amp; mRTBackend.startAnimation(this)) &#123; return; &#125; mView.setHasTransientState(true); //创建ValueAnimator ValueAnimator animator = ValueAnimator.ofFloat(1.0f); //clone一份mPendingAnimations赋值给nameValueList ArrayList&lt;NameValuesHolder&gt; nameValueList = (ArrayList&lt;NameValuesHolder&gt;) mPendingAnimations.clone(); //赋值完后清空 mPendingAnimations.clear(); //用于标识要执行动画的属性 int propertyMask = 0; int propertyCount = nameValueList.size(); //遍历所有nameValuesHolder，取出其属性名称mNameConstant， //执行\"|\"操作并最终赋值propertyMask for (int i = 0; i &lt; propertyCount; ++i) &#123; NameValuesHolder nameValuesHolder = nameValueList.get(i); propertyMask |= nameValuesHolder.mNameConstant; &#125; //创建PropertyBundle，并添加到mAnimatorMap中 mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList)); if (mPendingSetupAction != null) &#123; //设置硬件加速 mAnimatorSetupMap.put(animator, mPendingSetupAction); mPendingSetupAction = null; &#125; if (mPendingCleanupAction != null) &#123; //移除硬件加速 mAnimatorCleanupMap.put(animator, mPendingCleanupAction); mPendingCleanupAction = null; &#125; if (mPendingOnStartAction != null) &#123; //设置开始的动画（监听器的开始方法中调用） mAnimatorOnStartMap.put(animator, mPendingOnStartAction); mPendingOnStartAction = null; &#125; if (mPendingOnEndAction != null) &#123; //设置结束后要进行的下一个动画（监听器的结束方法中调用） mAnimatorOnEndMap.put(animator, mPendingOnEndAction); mPendingOnEndAction = null; &#125; //添加内部监听器 animator.addUpdateListener(mAnimatorEventListener); animator.addListener(mAnimatorEventListener); //判断是否延长开始 if (mStartDelaySet) &#123; animator.setStartDelay(mStartDelay); &#125; //执行动画的实现 if (mDurationSet) &#123; animator.setDuration(mDuration); &#125; //设置插值器 if (mInterpolatorSet) &#123; animator.setInterpolator(mInterpolator); &#125; //开始执行动画 animator.start();&#125; 我们上面的注释非常全面，这里 startAnimation 主要做下面几件事： 创建 Animator,变化值从 0 到 1，设置内部监听器 mAnimatorEventListener。clone 一份 mPendingAnimations 列表，并计算属性值标记 propertyMask，封装成 PropertyBundle 对象。使用 mAnimatorMap 保存当前 Animator 和对应的 PropertyBundle 对象。该Map 将会在 animatePropertyBy 方法和 Animator 监听器 mAnimatorEventListener 中使用。启动 animator 动画。关于PropertyBundle的分析如下： PropertyBundle：内部类，存放着将要执行的动画的属性集合信息，每次调用 animator.start(); 前，都会将存放在 mPendingAnimations 的 clone 一份存入 PropertyBundle 的内部变量 mNameValuesHolder 中，然后再将遍历 mPendingAnimations 中的 NameValueHolder 类，取出要执行的属性进行 ”|” 操作,最后记录成一个 mPropertyMask 的变量， 存放在 PropertyBundle 中，PropertyBundle 就是最终要执行动画的全部属性的封装类，其内部结构如下图 PropertyBundle AnimatorEventListener:ViewPropertyAnimator 内部的监听器。这个类实现了 Animator.AnimatorListener, ValueAnimator.AnimatorUpdateListener 接口。我们前面已经分享过它的部分源码，这个类还有一个 onAnimationUpdate() 的监听方法，这个方法我们放在后面解析，它是动画执行的关键所在。 HashMap mAnimatorMap:存放 PropertyBundle 类的Map。这个Map中存放的是正在执行的动画的 PropertyBundle， 这个 PropertyBundle 包含这本次动画的所有属性的信息。最终在 AnimatorEventListener 的 onAnimationUpdate() 方法中会通过这个map获取相应的属性，然后不断更新每帧的属性值以达到动画效果。通过前面对 animatePropertyBy 方法的分析， 我们可以知道该Map会保证当前只有一个 Animator 对象对该 View 的属性进行操作，不会存在两个 Animator 在操作同一个属性，其声明如下： 12private HashMap&lt;Animator, PropertyBundle&gt; mAnimatorMap = new HashMap&lt;Animator, PropertyBundle&gt;(); 最后我们看看动画是在哪里执行的，根据我们前面的原理图，内部监听器的 onAnimationUpdate() 方法将会被调用（当然内部监听器 AnimatorEventListener 实现了两个动画监听接口，其开始，结束，重复，取消4个方法也会被调用，这个我们前面已分析过）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overridepublic void onAnimationUpdate(ValueAnimator animation) &#123; //取出当前Animator对应用propertyBundle对象 PropertyBundle propertyBundle = mAnimatorMap.get(animation); if (propertyBundle == null) &#123; // Shouldn't happen, but just to play it safe return; &#125; //是否开启了硬件加速 boolean hardwareAccelerated = mView.isHardwareAccelerated(); // alpha requires slightly different treatment than the other (transform) properties. // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation // logic is dependent on how the view handles an internal call to onSetAlpha(). // We track what kinds of properties are set, and how alpha is handled when it is // set, and perform the invalidation steps appropriately. boolean alphaHandled = false; if (!hardwareAccelerated) &#123; mView.invalidateParentCaches(); &#125; //取出当前的估算值（插值器计算值） float fraction = animation.getAnimatedFraction(); int propertyMask = propertyBundle.mPropertyMask; if ((propertyMask &amp; TRANSFORM_MASK) != 0) &#123; mView.invalidateViewProperty(hardwareAccelerated, false); &#125; //取出所有要执行的属性动画的封装对象NameValuesHolder ArrayList&lt;NameValuesHolder&gt; valueList = propertyBundle.mNameValuesHolder; if (valueList != null) &#123; int count = valueList.size(); //遍历所有NameValuesHolder，计算变化值，并设置给对应的属性 for (int i = 0; i &lt; count; ++i) &#123; NameValuesHolder values = valueList.get(i); float value = values.mFromValue + fraction * values.mDeltaValue; if (values.mNameConstant == ALPHA) &#123; alphaHandled = mView.setAlphaNoInvalidation(value); &#125; else &#123; setValue(values.mNameConstant, value); &#125; &#125; &#125; if ((propertyMask &amp; TRANSFORM_MASK) != 0) &#123; if (!hardwareAccelerated) &#123; mView.mPrivateFlags |= View.PFLAG_DRAWN; // force another invalidation &#125; &#125; // invalidate(false) in all cases except if alphaHandled gets set to true // via the call to setAlphaNoInvalidation(), above if (alphaHandled) &#123; mView.invalidate(true); &#125; else &#123; mView.invalidateViewProperty(false, false); &#125; if (mUpdateListener != null) &#123; mUpdateListener.onAnimationUpdate(animation); &#125;&#125; onAnimationUpdate方法主要做了以下几件事： 取出当前 Animator 对应用 propertyBundle 对象并获取当前的估算值（插值器计算值），用于后续动画属性值的计算从 propertyBundle 取出要进行动画的属性列表 ArrayList valueList遍历所有 NameValuesHolder，计算变化值，并通过 setValue 设置给对应的属性，如果是 ALPHA，则会特殊处理一下，最终形成动画效果setValue方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243private void setValue(int propertyConstant, float value) &#123; final View.TransformationInfo info = mView.mTransformationInfo; final RenderNode renderNode = mView.mRenderNode; switch (propertyConstant) &#123; case TRANSLATION_X: renderNode.setTranslationX(value); break; case TRANSLATION_Y: renderNode.setTranslationY(value); break; case TRANSLATION_Z: renderNode.setTranslationZ(value); break; case ROTATION: renderNode.setRotation(value); break; case ROTATION_X: renderNode.setRotationX(value); break; case ROTATION_Y: renderNode.setRotationY(value); break; case SCALE_X: renderNode.setScaleX(value); break; case SCALE_Y: renderNode.setScaleY(value); break; case X: renderNode.setTranslationX(value - mView.mLeft); break; case Y: renderNode.setTranslationY(value - mView.mTop); break; case Z: renderNode.setTranslationZ(value - renderNode.getElevation()); break; case ALPHA: info.mAlpha = value; renderNode.setAlpha(value); break; &#125;&#125; 从源码可以看出实际上都会把属性值的改变设置到 renderNode 对象中，而 RenderNode 类则是一个可以优化绘制流程和绘制动画的类， 该类可以提升优化绘制的性能，其内部操作最终会去调用到 Native 层方法，这里我们就不深追了。最后这里我们再回忆一下前面给出的整体流程说明： 通过imageView.animate()获取ViewPropertyAnimator对象。调用alpha、translationX等方法，返回当前ViewPropertyAnimator对象，可以继续链式调用alpha、translationX等方法内部最终调用animatePropertyBy(int constantName, float startValue, float byValue)方法在animatePropertyBy方法中则会将alpha、translationX等方法的操作封装成NameVauleHolder，并将每个NameValueHolder对象添加到准备列表mPendingAnimations中。animatePropertyBy方法启动mAnimationStarter，调用startAnimation，开始动画。startAnimation方法中会创建一个ValueAnimator对象设置内部监听器AnimatorEventListener，并将mPendingAnimations和要进行动画的属性名称封装成一个PropertyBundle对象，最后mAnimatorMap保存当前Animator和对应的PropertyBundle对象。该Map将会在animatePropertyBy方法和Animator监听器mAnimatorEventListener中使用，启动动画。在动画的监听器的onAnimationUpdate方法中设置所有属性的变化值，并通过RenderNode类优化绘制性能，最后刷新界面。 4. Java 属性动画拓展之 LayoutAnimator 容器布局动画Property 动画系统还提供了对 ViewGroup 中 View 添加时的动画功能，我们可以用 LayoutTransition 对 ViewGroup 中的 View 进行动画设置显示。LayoutTransition 的动画效果都是设置给 ViewGroup，然后当被设置动画的 ViewGroup 中添加删除 View 时体现出来。 该类用于当前布局容器中有 View 添加、删除、隐藏、显示等时候定义布局容器自身的动画和 View 的动画，也就是说当在一个 LinerLayout 中隐藏一个 View 的时候，我们可以自定义 整个由于 LinerLayout 隐藏 View 而改变的动画，同时还可以自定义被隐藏的 View 自己消失时候的动画等。 我们可以发现 LayoutTransition 类中主要有五种容器转换动画类型，具体如下： LayoutTransition.APPEARING：当View出现或者添加的时候View出现的动画。 LayoutTransition.CHANGE_APPEARING：当添加View导致布局容器改变的时候整个布局容器的动画。 LayoutTransition.DISAPPEARING：当View消失或者隐藏的时候View消失的动画。 LayoutTransition.CHANGE_DISAPPEARING：当删除或者隐藏View导致布局容器改变的时候整个布局容器的动画。 LayoutTransition.CHANGE：当不是由于View出现或消失造成对其他View位置造成改变的时候整个布局容器的动画。 4-1 XML 方式使用系统提供的默认 LayoutTransition 动画我们可以通过如下方式使用系统提供的默认ViewGroup的LayoutTransition动画： 1android:animateLayoutChanges=”true” 在 ViewGroup 添加如上 xml 属性默认是没有任何动画效果的，因为前面说了，该动画针对于 ViewGroup 内部东东发生改变时才有效， 所以当我们设置如上属性然后调运 ViewGroup 的 addView、removeView 方法时就能看见系统默认的动画效果了。 还有一种就是通过如下方式设置： 1android:layoutAnimation=”@anim/customer_anim” 通过这种方式就能实现很多吊炸天的动画,并在加载布局的时候就会自动播放 layout-animtion。其中设置的动画位于 res/anim 目录下的动画资源（如下）： 1234&lt;layoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\" android:delay=\"30%\" android:animationOrder=\"reverse\" android:animation=\"@anim/slide_right\"/&gt; 每个属性的作用： android:delay 表示动画播放的延时，既可以是百分比，也可以是 float 小数。 android:animationOrder 表示动画的播放顺序，有三个取值 normal(顺序)、reverse(反序)、random(随机)。 android:animation 指向了子控件所要播放的动画。 4-2 Java 方式使用系统提供的默认 LayoutTransition 动画在使用LayoutTransition时，你可以自定义这几种事件类型的动画，也可以使用默认的动画，总之最终都是通过setLayoutTransition(LayoutTransition lt) 方法把这些动画以一个 LayoutTransition 对象设置给一个 ViewGroup。 譬如实现如上 Xml 方式的默认系统 LayoutTransition 动画如下： 12mTransitioner = new LayoutTransition();mViewGroup.setLayoutTransition(mTransitioner); 如果在xml中文件已经写好 LayoutAnimation，可以使用 AnimationUtils 直接加载： 1AnimationUtils.loadLayoutAnimation(context, id) 另外还可以手动java代码编写，如： 1234567//通过加载XML动画设置文件来创建一个Animation对象；Animation animation=AnimationUtils.loadAnimation(this, R.anim.slide_right); //得到一个LayoutAnimationController对象；LayoutAnimationController controller = new LayoutAnimationController(animation); //设置控件显示的顺序；controller.setOrder(LayoutAnimationController.ORDER_REVERSE); //设置控件显示间隔时间；controller.setDelay(0.3); //为ListView设置LayoutAnimationController属性；listView.setLayoutAnimation(controller);listView.startLayoutAnimation(); 4-3 LayoutTransition 的用法稍微再高端一点吧，我们来自定义这几类事件的动画，分别实现他们，那么你可以像下面这么处理： 1234567mTransitioner = new LayoutTransition();......ObjectAnimator anim = ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 0, 1);......//设置更多动画mTransition.setAnimator(LayoutTransition.APPEARING, anim);......//设置更多类型的动画mViewGroup.setLayoutTransition(mTransitioner); 到此通过 LayoutTransition 你就能实现类似小米手机计算器切换普通型和科学型的炫酷动画了。","categories":[{"name":"项目","slug":"项目","permalink":"http://zhousaito.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/tags/android/"}],"author":"Zhousaito"},{"title":"自定义view(一)","slug":"2019-06-16-自定义View","date":"2019-06-16T06:03:28.087Z","updated":"2019-11-14T00:14:22.597Z","comments":true,"path":"2019/06/16/2019-06-16-自定义View/","link":"","permalink":"http://zhousaito.top/2019/06/16/2019-06-16-%E8%87%AA%E5%AE%9A%E4%B9%89View/","excerpt":"","text":"content{:toc}0x01 介绍 1.进行view的绘制，学会一些自定义的操作 自定义View的步骤： 一般都需要重写onDraw onMeasure 这两个方法 其实View中带有onLayout这个方法，并不是只有ViewGroup中才有onLayout这个方法 自定义ViewGroup的步骤： 一般重写onMeasure, onLayout 0x02 自定义个简单的FlowLayout1：什么是FlowLayout FlowLayout：我这边弄的flowLayout就是当着横向摆放子控件的时候，如果这一行放不下后，然后就放另一行 1.1：测量 (onMeasure)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /** * 测量就是确定自己自定义控件的大小 * * @param widthMeasureSpec * @param heightMeasureSpec */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //漏了这一句，界面一直不显示，child的测量全是0 //实际就是测量一下子View measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); //宽度默认是自己的宽度，实际上可以在AT_MOST模式下，进行一些计算 //如把所有的子控件的宽和padding+margin这些都加起来，这样换算成自己的宽度 int width = widthSize; int height; if (heightMode == MeasureSpec.EXACTLY) &#123; height = heightSize; &#125; else &#123; //根据策略来进行子空间的摆放 int row = 1;// int widthSpace = width; //宽度剩余空间 int tempWidth = 0; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int childW = view.getMeasuredWidth(); if (childW + tempWidth &lt;= width) &#123; tempWidth += width; &#125; else &#123; row++; //换行了 tempWidth = 0; &#125;// if (widthSpace &gt;= childW) &#123;// widthSpace -= childW;// &#125; else &#123;// row++;// widthSpace = width - childW;// &#125; &#125; int childH = getChildAt(0).getMeasuredHeight(); height = childH * row; &#125; setMeasuredDimension(width, height); &#125; 1.2：布局(onLayout) 策略的进行子View控件的摆放 策略：经过测量，当子View不能放在当前行的时候，就进行下一行的绘制 123456789101112131415161718192021222324252627282930313233343536373839/** * @param changed * @param l * @param t * @param r * @param b */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int offsetWidth = 0; //测量偏移的宽度 int offsetHeight = 0; //测量偏移的高度 int right = 0; for (int i = 0; i &lt; getChildCount(); i++) &#123; View childView = getChildAt(i); int measuredWidth = childView.getMeasuredWidth(); int measuredHeight = childView.getMeasuredHeight(); //这一行还可以放下 if (offsetWidth + measuredWidth &lt;= r) &#123; childView.layout(offsetWidth, offsetHeight, measuredWidth + offsetWidth, measuredHeight + offsetHeight); //加上已经填充好的宽度 offsetWidth += measuredWidth; &#125; else &#123; //换一行 offsetHeight += measuredHeight; offsetWidth = 0; //我换一行了，所以重新开始计算偏移的宽度 childView.layout(offsetWidth, offsetHeight, measuredWidth + offsetWidth, measuredHeight + offsetHeight); //这里也要加偏移量 offsetWidth += measuredWidth; &#125; &#125; Log.e(TAG, \"onLayout: changed: \" + changed + \", l: \" + l + \", t: \" + t + \", r: \" + r + \", b: \" + b);&#125;","categories":[{"name":"自定义View","slug":"自定义View","permalink":"http://zhousaito.top/categories/%E8%87%AA%E5%AE%9A%E4%B9%89View/"}],"tags":[{"name":"android view","slug":"android-view","permalink":"http://zhousaito.top/tags/android-view/"}],"author":"Zhousaito"},{"title":"求导","slug":"2019-06-11-求导","date":"2019-06-10T16:00:00.000Z","updated":"2019-11-14T00:37:59.856Z","comments":true,"path":"2019/06/11/2019-06-11-求导/","link":"","permalink":"http://zhousaito.top/2019/06/11/2019-06-11-%E6%B1%82%E5%AF%BC/","excerpt":"","text":"content{:toc}0x01 最近看李永乐老师的视频看多了，发现想把所有的数学或者物理现象可以通过编程来实现。 0x02求导公式： 1.C’=0(C为常数)； 2.(Xn)’=nX(n-1) (n∈R)； 3.(sinX)’=cosX； 4.(cosX)’=-sinX； 5.(aX)’=aXIna （ln为自然对数)； 6.(logaX)’=（1/X)logae=1/(Xlna) (a&gt;0，且a≠1)； 7.(tanX)’=1/(cosX)2=(secX)2 8.(cotX)’=-1/(sinX)2=-(cscX)2 9.(secX)’=tanX secX； 10.(cscX)’=-cotX cscX； [1] 并不是所有的函数都可以求导； 可导函数一定连续，但连续的函数不一定可导 （如y=|x|在y=0出不可求导）","categories":[{"name":"求导","slug":"求导","permalink":"http://zhousaito.top/categories/%E6%B1%82%E5%AF%BC/"}],"tags":[{"name":"java 数学","slug":"java-数学","permalink":"http://zhousaito.top/tags/java-%E6%95%B0%E5%AD%A6/"}],"author":"Zhousaito"},{"title":"事件分发","slug":"2019-06-09-事件分发","date":"2019-06-09T08:52:06.071Z","updated":"2019-11-14T00:14:03.776Z","comments":true,"path":"2019/06/09/2019-06-09-事件分发/","link":"","permalink":"http://zhousaito.top/2019/06/09/2019-06-09-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/","excerpt":"","text":"content{:toc}0x01 为什么需要学习事件分发 事件分发可以让我们解决一些自定义view和控制一些组件的冲突 用了一个设计模式：责任链设计模式 0x02 事件分发1: 先上个图片 2: 根据图片进行分析 事件分发最开始是通过activity的 dispatchTouchEvent 方法来进行的，activity上一层是C/C++层，具体应该是跟屏幕驱动之类的了。 根据代码： 父控件的dispatchTouchEvent返回true，父控件自己的拦截也走了，事件直接在dispatchTouchEvent的地方消耗了 dispatchTouchEvent（view中的方法被ViewGroup重写） onTouchEvent（View中的被ViewGroup重写，onClickListener在它的UP事件上面） onInterceptTouchEvent（只有ViewGroup中有） 父控件（ViewGroup） 返回true，就直接处理了，后面的onInterceptTouchEvent也不进行执行了，因为把父类当成DecorView的子类就好了，直接就从这里不往下执行了，这里已经返回true，事件在这个地方已经被消费了。，如果自定义viewGroup在这个地方返回true，上面的点击事件就不起作用了;其实只要不调用父类的方法（super.dispatchTouchEvent(ev)）都在dispatchTouchEvent这里就不往下面传递了，这里最好根据上滑动或者下滑动的方式,或者是MOVE，DOWN，UP事件来进行判断，如：自己需要上滑动的情况下来进行返回true不给子控件点击这种来进行，相当于单个来进行放回true，尽量不要直接返回true来进行全部自己消费。 这个是事件的最终消费的方法.这里分两种情况：1.就是onInterceptTouchEvent不返回true的情况下。只要用户的点击不命中自己的上面（就是点击没有在自己的区域上面，源码的dispatchTouchEvent里面判断完整的点击事件在UP事件上面，并进行了点击范围的处理），都不会调用这个方法，即使命中的控件是enable是false的2.就是onInterceptTouchEvent返回true，表示拦截了子类的某种行为。这个方法就会被回调3.当子类在某种情况下调用了getParent().requestDisallowInterceptTouchEvent(false)这个方法也不会调用这个方法了。 如果返回true的话就会直接不给自己的子View点击事件了 子控件(view，不是viewGroup) 如果直接返回true，自己的onTouchEvent不会执行。viewGroup也一样（onInterceptTouchEvent也不执行了，因为onInterceptTouchEvent来进行是否分发在它的dispatchTouchEvent中） 如果返回true就代表事件在这里就消耗了。 view中没有该方法 requestDisallowInterceptTouchEvent说明，一开始拦截了就不起效果了: 第一个事件是先调用 ViewGroup 的 onIntercept 的，所以如果一开始 ViewGroup 就打算拦截，子 View 将没有任何机会； 所有的事件以：ACTION_DOWN 开始，ACTION_UP 或者 ACTION_CANCEL 结束 3:解决冲突从父组件的onInterceptTouchEvent入手1234567@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if(!allowChildViewScroll)&#123; return true; &#125; return super.onInterceptTouchEvent(ev); &#125; 如果不允许子控件滑动，就直接禁止这种方式，防止父类不能进行滑动。只不过，还有很多种情况，比如，子控件可以滑动，通过滑动到第一个item或者说不能滑动的时候，然后又把滚动的权利还给父控件，然后就连贯了 getFirstVisiblePosition / getLastVisiblePosition 或者canScrollVertically(-1) 这些方式来判断滑动是否到了极限值，然后给另一个需要滑动的控件来进行滑动 参考事件传递及滑动冲突的处理Android之ScrollView嵌套两个ListView及冲突解决","categories":[{"name":"事件分发","slug":"事件分发","permalink":"http://zhousaito.top/categories/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"}],"tags":[{"name":"android java 进阶","slug":"android-java-进阶","permalink":"http://zhousaito.top/tags/android-java-%E8%BF%9B%E9%98%B6/"}],"author":"Zhousaito"},{"title":"hook Activity","slug":"2019-06-02-hookActivity","date":"2019-06-02T06:48:07.635Z","updated":"2019-11-14T00:13:57.240Z","comments":true,"path":"2019/06/02/2019-06-02-hookActivity/","link":"","permalink":"http://zhousaito.top/2019/06/02/2019-06-02-hookActivity/","excerpt":"","text":"content{:toc}0x01 为了进一步弄懂，android中四大主键中的activity的启动过程，所以就进行了hook activity 进行处理。 hook的原理就是通过动态代理或者静态代理的方式进行 偷梁换柱 的 方式进行，然后当程序执行到这个地方的时候，就会执行到我们自己所代理的 类或者方法上面，从而可以控制了这段代码的执行。 Hook选择点： 静态变量，单例。因为一旦创建了对象，它们就不容易变化，非常容易定位。 hook的使用过程： 找hook点。静态或者单例对象，尽量hook public的方法。 2. 选择合适的代理方式，如果是接口，就用动态代理。 3. 偷梁换柱—&gt; 用自己实现的代理对象替换原始对象。 注意： 由于android 版本非常的多，通过反射的过程中，可以有很多的api不太一样，这样就会造成，要进行兼容处理。 0x02 hook IActivityManager，然后进行不注册Activity，然后也进行启动原理 就是通过一个正常的 activity 通过 startActivity启动，启动的时候，然后用intent先保存好没有注册的activity的intent，然后进行传递到AMS中，AMS通过 PKMS存好的 原来App安装的Mainfest的文件，里面的Activity， Service，ContentProvider, BroadcastReceiver 的注册好的，然后找到对应的Activity。最后从AMS回来。 目的一、开始写代码123456789public void hookAMS(View view) &#123; HookAms.hookIActivityManager(); HookAms.hookActivityThread$mH(); Intent intent = new Intent(this, NoRegisterActivity.class); //先把没注册的activity保存起来 intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // intent.putExtra(HookAms.SAVE_AMS_INTENT, new Intent(this, NoRegisterActivity.class)); startActivity(intent);&#125; 通过startActivity我们知道，最后跑到了 AMS的startActivity中去了 hook点就是AMS的startActivity，实际上AMS是实现了IActivityManager的接口，所以直接动态代理去实现。 二、hook ActivityManager中的IActivityManagerSingleton成员变量为什么要hook ActivityManager的IActivityManagerSingleton呢,看下图： 因为在Instrumention 中启动activity是通过AMS的startActivity 123456789101112131415161718192021222324252627282930313233343536373839/** * 通过分析，可以hook IActivityManager 的startActivity方法 * 然后进行hook */public static void hookIActivityManager() &#123; try &#123; Class&lt;?&gt; activityManagerClass = Class.forName(\"android.app.ActivityManager\"); Field iActivityManagerSingletonField = activityManagerClass.getDeclaredField(\"IActivityManagerSingleton\"); iActivityManagerSingletonField.setAccessible(true); Object iActivityManagerSingleton = iActivityManagerSingletonField.get(null); Class&lt;?&gt; singletonClass = Class.forName(\"android.util.Singleton\"); Field mInstanceField = singletonClass.getDeclaredField(\"mInstance\"); mInstanceField.setAccessible(true); Object iActivityManagerObject = mInstanceField.get(iActivityManagerSingleton); //这里使用动态代理 /** * classloader ： 用当前线程的classloader * */ ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Class[] interfaces = iActivityManagerObject.getClass().getInterfaces(); ProxyInvokehanlder proxyInvokehanlder = new ProxyInvokehanlder(iActivityManagerObject); //IActivityManger的代理对象 Object proxyInstance = Proxy.newProxyInstance(contextClassLoader, interfaces, proxyInvokehanlder); //偷梁换柱，把代理对象给ActivityManagerSingleton的mInstance,变成自己的代理类对象 mInstanceField.set(iActivityManagerSingleton, proxyInstance); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这个过程中： 获取IActivityManager的对象，然后通过动态代理进行偷梁换柱。 最后把代理类设置在了ActivityManger里面去 三、ProxyInvokehanlder12345678910111213141516171819202122232425262728293031323334353637static class ProxyInvokehanlder implements InvocationHandler &#123; private static final String TAG = \"ProxyInvokehanlder\"; private Object mBase; public ProxyInvokehanlder(Object base) &#123; mBase = base; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.e(TAG, \"invoke: \" + method.getName()); if (\"startActivity\".equals(method.getName())) &#123; int curIntentIndex = -1; Intent curIntent = null; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof Intent) &#123; curIntentIndex = i; curIntent = (Intent) args[i]; &#125; Log.e(TAG, \"arg: \" + args[i]); &#125; if (curIntent != null) &#123; Intent intent = new Intent(); intent.setComponent(new ComponentName(\"com.zhousaito.hookactivity\", FakeActivity.class.getName())); //把curIntent保存起来 intent.putExtra(SAVE_AMS_INTENT, curIntent); //把这个进行 欺骗处理 欺骗AMS 启动的是Fake的activity args[curIntentIndex] = intent; &#125; &#125; return method.invoke(mBase, args); &#125;&#125; 主要工作就是把自己未注册的Activity的intent，换成注册好的 Activity，然后欺骗AMS 四、通过以上方式，可以启动Activity，但是FakeActivity是欺骗AMS的Activity五、通过hook activityThread里面的mH这个类进行替换回来12345678910111213141516171819202122232425262728293031/** * 经过上面步骤，肯定还是不行的,打开的fakeActivity，我们要在 * 适当的时候，替换回来，才算可以 * &lt;p&gt; * hookActivityThread$mH -&gt; 中的$ 我是为了避免，AS编译器给个下划线加的，没有别的意思 */public static void hookActivityThread$mH() &#123; try &#123; //获取ActivityThread的字节码 Class&lt;?&gt; activityThreadClass = Class.forName(\"android.app.ActivityThread\"); Field mHField = activityThreadClass.getDeclaredField(\"mH\"); mHField.setAccessible(true); //获取ActivityThread的对象 Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\"currentActivityThread\"); Object activityThreadObject = currentActivityThreadMethod.invoke(null); Handler mHObject = (Handler) mHField.get(activityThreadObject); //获取handler的mCallback对象 Class&lt;?&gt; handlerClass = Class.forName(\"android.os.Handler\"); Field mCallbackField = handlerClass.getDeclaredField(\"mCallback\"); mCallbackField.setAccessible(true); //代理handle中的Callback mCallbackField.set(mHObject, new ProxyCallback(mHObject)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static class ProxyCallback implements Handler.Callback &#123; private static final String TAG = \"ProxyCallback\"; Handler mHandler; public ProxyCallback(Handler handler) &#123; mHandler = handler; &#125; @Override public boolean handleMessage(Message msg) &#123; Log.e(TAG, \"what: \" + msg.what + \", obj: \" + msg.obj); switch (msg.what) &#123; case 159: try &#123; Class&lt;?&gt; clientTransactionClass = Class.forName(\"android.app.servertransaction.ClientTransaction\"); Field mActivityCallbacks = clientTransactionClass.getDeclaredField(\"mActivityCallbacks\"); mActivityCallbacks.setAccessible(true); List mActivityCallbacksObject = (List) mActivityCallbacks.get(msg.obj); if (mActivityCallbacksObject.size() &gt; 0) &#123; //这个类型，经过打印是LaunchActivityItem 类型的 Object launchActivityItemObject = mActivityCallbacksObject.get(0); Log.e(TAG, \"mActivityCallbacksObject: \" + launchActivityItemObject); Field mIntentField = launchActivityItemObject.getClass().getDeclaredField(\"mIntent\"); mIntentField.setAccessible(true); //拿到我们欺骗ams的intent，然后把我们真正需要的intent替换一下 Intent fakeIntent = (Intent) mIntentField.get(launchActivityItemObject); Log.e(TAG, \"intent: \" + fakeIntent); Intent intent = fakeIntent.getParcelableExtra(SAVE_AMS_INTENT); //替换成想要的intent mIntentField.set(launchActivityItemObject, intent); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; break; default: break; &#125; mHandler.handleMessage(msg); return false; &#125;&#125; 通过上面的，最后完成了未注册的Activity的启动 总结 知道了hook的简单使用，然后并进行了实践。 了解了Activity的启动过程： Activity # startActivityForResult -&gt; Instrumentation# execStartActivity -&gt; ActivityManager.getService()#startActivity (实际上到了 AMS # startActivity) -&gt;AMS#startActivityAsUser -&gt; ActivityStartController 的handle发送消息 doPendingActivityLaunches -&gt; ActivityStarter # startResolvedActivity -&gt; ActivityStarter#startActivity(构造方法参数贼多的那个) -&gt;ActivityStack.sendActivityResultLocked -&gt; mService.getLifecycleManager().scheduleTransaction就是AMS中的LifecycleManager的scheduleTransaction -&gt; ClientTransaction # schedule -&gt; IApplicationThread#scheduleTransaction 就相当于ApplicationThread的中的scheduleTransaction方法 -&gt; ActivityThread的继承类 scheduleTransaction 方法 12345 &gt;void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this);//执行了EXECUTE_TRANSACTION，就是 159 那个what sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); &gt;&#125; -&gt; TransactionExecutor # execute -&gt; TransactionExecutor # cycleToPath -&gt; TransactionExecutor #performLifecycleSequence 12345678910111213141516171819&gt;private void performLifecycleSequence(ActivityClientRecord r, IntArray path) &#123; final int size = path.size(); for (int i = 0, state; i &lt; size; i++) &#123; state = path.get(i); log(\"Transitioning to state: \" + state); switch (state) &#123; case ON_CREATE: //最后都调用了ActivityThread中的对应方法 mTransactionHandler.handleLaunchActivity(r, mPendingActions, null /* customIntent */); break; case ON_START: mTransactionHandler.handleStartActivity(r, mPendingActions); break; case ON_RESUME: mTransactionHandler.handleResumeActivity(r.token, false /* finalStateRequest */, r.isForward, \"LIFECYCLER_RESUME_ACTIVITY\"); break; //.... ActivityThread # handleLaunchActivity -&gt; ActivityThread # performLaunchActivity -&gt; 就找了熟悉的代码 12&gt;activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ​","categories":[{"name":"hook","slug":"hook","permalink":"http://zhousaito.top/categories/hook/"}],"tags":[{"name":"android java 进阶","slug":"android-java-进阶","permalink":"http://zhousaito.top/tags/android-java-%E8%BF%9B%E9%98%B6/"}],"author":"Zhousaito"},{"title":"broadcoast启动过程","slug":"2019-05-25-BroadcastReceiver启动过程","date":"2019-05-25T01:49:48.129Z","updated":"2019-11-14T00:13:46.245Z","comments":true,"path":"2019/05/25/2019-05-25-BroadcastReceiver启动过程/","link":"","permalink":"http://zhousaito.top/2019/05/25/2019-05-25-BroadcastReceiver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"content{:toc}简单使用 braodcast通过静态注册和动态注册两种方式进行使用，这里就不再详细描述 先上个图 ContextImpl通过binder的方式进行通信 开始RTFSC第一步自己写的注册类 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private MyBroadcastReceiver mMyBroadcastReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMyBroadcastReceiver = new MyBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(Constant.MY_BROADCAST_ACTION); //1.动态注册自己写的BroadcastReceiver到AMS中 registerReceiver(mMyBroadcastReceiver, intentFilter); &#125; //...&#125; 123public interface Constant &#123; String MY_BROADCAST_ACTION = \"my_broadcast_action\";&#125; 第二步contextWrapper#registerReceivercontextWrapper#registerReceiver 运用了装饰者设计模式，mBase是ContextImpl的对象 参照：ContextImpl和ContextWrapper(装饰模式) ContextImpl和ContextWrapper绑定过程 123456789101112 Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125;//...@Override public Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter); &#125;//... 其实有个好一点的办法区分，就是找到contextWrapper类，打个断点，看看mBase的类型就好了 第三步ContextImpl#registerReceiver从第二步，我们已经知道是contextImpl，所以第三步是 ContextImpl#registerReceiver 12345678910111213141516171819//...@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; return registerReceiver(receiver, filter, null, null);&#125;@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags) &#123; return registerReceiver(receiver, filter, null, null, flags);&#125;@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext(), 0);&#125;//... 一大堆的重载方法（是重写context的抽象方法，相互回调了，就看做为重载方法应该也没毛病）。 最终调用了registerReceiverInternal 第三小步 1.1 ContextImpl#registerReceiverInternal123456789101112131415161718192021222324252627282930313233343536private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context, int flags) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; //1. scheduler = mMainThread.getHandler(); &#125; //2. rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; //3.ActivityManager.getService() final Intent intent = ActivityManager.getService().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId, flags); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 这个类没多少内容，全部都copy了下来 获取ActivityThread的mH这个 handler 对象 IIntentReceiver的binder对象 IIntentReceiver相当于是一个AIDL的接口。2.x的内容和绑定的关系不是很大，就是可能好理解一些，所以我记录了一下2.x的一些内容，实际上回头发送broadcast的时候还是要知道，AMS发送消息回来的时候需要看这些源码 12345678910ReceiverDispatcher(BroadcastReceiver receiver, Context context, Handler activityThread, Instrumentation instrumentation, boolean registered) &#123; //... //2.1 mIIntentReceiver = new InnerReceiver(this, !registered); //2.1.1 这里同时还存了我们注册的BroadcastReceiver mReceiver = receiver; //... &#125; ​ 2.1 这个里把 ReceiverDispatcher 用 this 传了进行，以便于然后 ，后面AMS那边把IIntentReceiver 这个binder对象传回来的时候进行 调取 ReceiverDispatcher自己的performReceive方法，其实这个里我原来也不太理解，为什么不直接传ReceiverDispatcher对象过去。现在我理解成，因为binder对象是可以通过打包在 Parcel中，通过 Parcel的 writeStrongBinder进行传递的，然后AIDL的方式传递到AMS中，然后进行保存 1234567891011121314151617181920212223242526272829303132final static class InnerReceiver extends IIntentReceiver.Stub &#123; //保存了一个mDispatcher final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher; final LoadedApk.ReceiverDispatcher mStrongRef; InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd); mStrongRef = strong ? rd : null; &#125; @Override public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final LoadedApk.ReceiverDispatcher rd; if (intent == null) &#123; Log.wtf(TAG, \"Null intent received\"); rd = null; &#125; else &#123; //通过弱引用的方式，拿到了这个对象 rd = mDispatcher.get(); &#125; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(\"seq\", -1); Slog.i(ActivityThread.TAG, \"Receiving broadcast \" + intent.getAction() + \" seq=\" + seq + \" to \" + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; //然后调用了mDispatcher中的performReceive方法 rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; //... ​ 2.2 InnerReceiver是ReceiverDispatcher的静态内部类，并且实现了IIntentReceiver的方法。根据AIDL，继承了IIntentReceiver.Stub相当于一个binder对象并且实现了IIntentReceiver的方法，根据多态，然后可以通过IIntentReceiver的方式进行传递 ​ 2.3 在往下一步的下一步，我们就能看到接收了，我们重写的 onReceive() ​ ReceiverDispatcher#performReceive 12345678910public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); //... // mActivityThread 是 mH ActivityThread的handler if (intent == null || !mActivityThread.post(args.getRunnable())) &#123; //... &#125; ​ 2.4 再看args.getRunnable() 12345678910111213public final Runnable getRunnable() &#123; return () -&gt; &#123; //原来保存好的对象 final BroadcastReceiver receiver = mReceiver; final boolean ordered = mOrdered; //... receiver.setPendingResult(this); //这个就是那个熟悉的身影了 receiver.onReceive(mContext, intent); //... &#125; ActivityManager.getService() 想当于调用AMS里面对应的方法 1234567891011121314public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); //AIDL绑定，获取AIDL中的Proxy对象 final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; ​ 上面代码可以看出，就是个AIDL， asInterface就是返回了一个AIDL中的proxy的对象，这个用来跨进程调用AMS的方法 第四步ActivityManagerService#registerReceiver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId, int flags) &#123; //... //1.sticky的一些判断,然后添加在了mStickyBroadcasts中 //还做了一些uid和pid的判断 if(caller!=null) &#123; //... while (actions.hasNext()) &#123; String action = actions.next(); for (int id : userIds) &#123; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id); if (stickies != null) &#123; ArrayList&lt;Intent&gt; intents = stickies.get(action); if (intents != null) &#123; if (stickyIntents == null) &#123; stickyIntents = new ArrayList&lt;Intent&gt;(); &#125; stickyIntents.addAll(intents); &#125; &#125; &#125; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId); if (stickies == null) &#123; stickies = new ArrayMap&lt;&gt;(); mStickyBroadcasts.put(userId, stickies); &#125; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list == null) &#123; list = new ArrayList&lt;&gt;(); stickies.put(intent.getAction(), list); &#125; final int stickiesCount = list.size(); int i; for (i = 0; i &lt; stickiesCount; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; // This sticky already exists, replace it. list.set(i, new Intent(intent)); break; &#125; &#125; if (i &gt;= stickiesCount) &#123; list.add(new Intent(intent)); &#125; &#125; &#125; //... ArrayList&lt;Intent&gt; allSticky = null; if (stickyIntents != null) &#123; final ContentResolver resolver = mContext.getContentResolver(); // Look for any matching sticky broadcasts... //... &#125; // The first sticky in the list is returned directly back to the client. Intent sticky = allSticky != null ? allSticky.get(0) : null; if (receiver == null) &#123; return sticky; &#125; synchronized (this) &#123; if (callerApp != null &amp;&amp; (callerApp.thread == null || callerApp.thread.asBinder() != caller.asBinder())) &#123; // Original caller already died return null; &#125; //2.ReceiverList是否存在，如果是空的就创建 ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); if (rl == null) &#123; rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver); //... //3.最后保存了IIntentReceiver的binder对象，但是任然是IIntentReceiver的子类 mRegisteredReceivers.put(receiver.asBinder(), rl); &#125; //... //4.把 rl:ReceiverList 传给了 BroadcastFilter 生成出了bf对象 BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId, instantApp, visibleToInstantApps); if (rl.containsFilter(filter)) &#123; Slog.w(TAG, \"Receiver with filter \" + filter + \" already registered for pid \" + rl.pid + \", callerPackage is \" + callerPackage); &#125; else &#123; rl.add(bf); if (!bf.debugCheck()) &#123; Slog.w(TAG, \"==&gt; For Dynamic broadcast\"); &#125; //5.把这个自己的action的封装保存了起来，方面后面发送这个action的请求进行发送对应的广播 //所以前面如果有了，就不再加入了 mReceiverResolver.addFilter(bf); &#125; // Enqueue broadcasts for all existing stickies that match // this filter. // 6.粘性广播，最后如果不为0，就加入到了BroadcastQueue中 if (allSticky != null) &#123; ArrayList receivers = new ArrayList(); receivers.add(bf); final int stickyCount = allSticky.size(); for (int i = 0; i &lt; stickyCount; i++) &#123; Intent intent = allSticky.get(i); BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, null, null, -1, -1, false, null, null, OP_NONE, null, receivers, null, 0, null, null, false, true, true, -1); queue.enqueueParallelBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; &#125; return sticky; &#125; &#125;&#125; 到此，使用的broadcast在AMS中注册就已经注册完成了 参考《android源码情景分析》 四大组件之BroadcastRecord 读源码-五分钟理解不了广播机制","categories":[{"name":"broadcoast","slug":"broadcoast","permalink":"http://zhousaito.top/categories/broadcoast/"}],"tags":[{"name":"android java 进阶","slug":"android-java-进阶","permalink":"http://zhousaito.top/tags/android-java-%E8%BF%9B%E9%98%B6/"}],"author":"Zhousaito"},{"title":"jitpack发布自己的lib包","slug":"2019-03-15-jitpack-use","date":"2019-03-15T07:16:33.700Z","updated":"2019-03-20T06:04:23.032Z","comments":true,"path":"2019/03/15/2019-03-15-jitpack-use/","link":"","permalink":"http://zhousaito.top/2019/03/15/2019-03-15-jitpack-use/","excerpt":"","text":"content{:toc}谚语：两年学说话,一生学闭嘴 一、启发做了3年android开发了，很少自己尝试或者发布 lib 包。可能自己编程的水平还不够，从现在开始，鼓起勇气，进行来发布一个自己使用lib，至少对这块遇到后，不那么的陌生。 二、开始万事开头难： 先在AS中，新建立一个项目：SubtitleviewDemo New Project =&gt; SubtitleviewDemo 然后在创建成功之后的SubtitleviewDemo中创建一个 Subtitleview的一个module New =&gt; Module 最后编写好subtitleview里面的内容,然后进行发布到github上面 然后到github进行相关设置: 创建一个新的relaese,然后去jitpack 然后获取project 这样基本上就完工了 参考jitpack的官方文档 通过JitPack发布Android Library Android发布Library到JitPack Android Library打造自己的SDK，并Maven发布","categories":[{"name":"jitpack","slug":"jitpack","permalink":"http://zhousaito.top/categories/jitpack/"}],"tags":[{"name":"jitpack jitpack简单使用","slug":"jitpack-jitpack简单使用","permalink":"http://zhousaito.top/tags/jitpack-jitpack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"}],"author":"Zhousaito"},{"title":"快速开发","slug":"2019-03-06-快速开发","date":"2019-03-06T01:37:32.842Z","updated":"2019-03-11T02:28:08.604Z","comments":true,"path":"2019/03/06/2019-03-06-快速开发/","link":"","permalink":"http://zhousaito.top/2019/03/06/2019-03-06-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/","excerpt":"","text":"content{:toc}一、想法 就是为了,开发一个app可以快速上手,而不需要点其他的,从而产生的一个需求; 针对现在我们公司的现状和公司的后端给予的一些数据标准进行一些判断, 根据产品一般给的需求,进行的一系列的总结,然后得出一套在现在公司的一套快速开发的方案.方案不管完善不完善,也将一直进行维护. 框架的整体思想 主要使用mvp模式,这个模式用来进行界面和数据隔离,当app越做越大的时候,容易进行维护.解耦率比较高 尽量少使用if和else进行编程,使用也尽量减少嵌套,不然代码后期不好维护 http请求 加密算法 请求的代码回调 统一的后台数据出来格式的 BaseEntry 采用rxjava + retrofit2 + okhttp3这种组合进行 ui方面 activity封装 具有左滑动结束的 不具有左滑动结束的 有正在加载的 有带有没有数据的空界面的 带有下拉刷新和下拉加载的界面 fragment封装 不具有左滑动的结束的 具有左滑动结束的 有正在加载的 有带有没有数据的空界面的 带有下拉刷新和下拉加载的界面 application的编写 一般都要继承MultiDexApplication AppSession 用于存储用户信息，用于进一步封装application,不直接的在外面直接使用App.getContext(). 二、具体http方面草稿 图片加载 , 图片选择器 , 统一的日志, 统一的toast, 动态权限申请， 底部4个状态栏 尽量把通用的都写了 统一的动画 sp的封装 注意事项 一定要使用jdk1.8，主要为了方便，可以写lambda表达式 ,而且有很多地方使用局部变量的时候不用使用final进行修饰 最后细节AndroidManifast警告去除","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android android框架","slug":"android-android框架","permalink":"http://zhousaito.top/tags/android-android%E6%A1%86%E6%9E%B6/"}],"author":"Zhousaito"},{"title":"自定义behavior","slug":"2019-03-05-behavior","date":"2019-03-05T01:38:35.207Z","updated":"2019-03-06T00:41:05.044Z","comments":true,"path":"2019/03/05/2019-03-05-behavior/","link":"","permalink":"http://zhousaito.top/2019/03/05/2019-03-05-behavior/","excerpt":"","text":"content{:toc}介绍 其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。 在Behavior中，被观察View 也就是事件源被称为dependency，而观察View，则被称为child。 两个简单的控件进行一起滑动 ButtonFragment中: 12345678910111213141516171819202122232425262728dependBtn.setOnTouchListener(new View.OnTouchListener() &#123; private int lastX, lastY; @Override public boolean onTouch(View v, MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录触摸点坐标 lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 在当前left、top、right、bottom的基础上加上偏移量 v.layout(v.getLeft() + offsetX, v.getTop() + offsetY, v.getRight() + offsetX, v.getBottom() + offsetY); break; &#125; return true; &#125; &#125;); buttonBehavior 中: 12345678910111213@Overridepublic boolean layoutDependsOn(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) &#123; return dependency instanceof Button;&#125;@Overridepublic boolean onDependentViewChanged(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) &#123; //这里就决定了child位置改变，从而，在coordinatorLayout中，布局会重新布局的原因 child.setX(dependency.getX() + dependency.getWidth() + 200); child.setY(dependency.getY()); Log.e(TAG, \"onDependentViewChanged: \" + dependency.getX() + \", \" + dependency.getY()); return true;&#125; UC浏览器主页demo 主要是这4个重要的类 布局说明: UCTitleView UCTitleView如果要在content滑动结束刚刚全部出来 应该是： float ratio = UCTitleView的滑动距离 / content的滑动距离 由于初始状态是从上面往下面走，所以是 负的 直接用 -1 * offset 控件会保持不动 所以： UCTitleView移动距离 = -(1 + ratio) * offset123456789UCHeaderView headerView = (UCHeaderView) viewGroup;int scrollRange = headerView.getScrollRange();float ratio = getMeasuredHeight() / (float) scrollRange;//负号是往下面移动//如果直接是-offset,控件是原地不动的//经过计算, 如果重上往下走 如果是控件全部出来这一种 移动一个控件的高度就好了//即: -(1 + (控件高度/recyclerView滑动总距离)) * offset//offset的max是 recyclerView滑动总距离mATViewOffsetHelper.setTopAndBottomOffset((int) (-(ratio + 1) * offset)); UCTabLayout UCTabLayout如果要滑动刚刚和和UCTitleView全部划出来的地方 距离应该是: ​ 滑动高度 = UCCenterView的高度 - content的滑动距离 - UCTitleView的高度 从而得出了倍率: ​ float ratio = 滑动高度/content的滑动距离 所以: ​ UCTabLayout动态移动距离 = ratio * offset 123456UCHeaderView headerView = (UCHeaderView) viewGroup;int scrollRange = headerView.getScrollRange();int height = headerView.getCenterViewHeight();int currentScroll = height - scrollRange;float ratio = (currentScroll - headerView.getTitleHeight()) / (float) scrollRange;mATViewOffsetHelper.setTopAndBottomOffset((int) (ratio * offset)); UCScrollingBehaviorUCScrollingBehavior主要用来放在 RecyclerView(也可以是其他实现了NestedScrollChild的接口View) 上面的一个behavior,用于把 UCHeaderView和RecyclerView摆放位置确定的类 部分代码 12345678910111213141516171819202122232425262728 /** * 一开始确定 * UCHeaderView 和 recyclerView的摆放 */ @Override public boolean onDependentViewChanged(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) &#123; UCHeaderView headerView = findFirstDependency(parent.getDependencies(child)); if (headerView != null) &#123; CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) headerView.getLayoutParams(); CoordinatorLayout.Behavior behavior = layoutParams.getBehavior(); if (behavior instanceof UCHeaderView.Behavior) &#123;// UCHeaderView.Behavior headerBehavior = (UCHeaderView.Behavior) behavior; ViewCompat.offsetTopAndBottom(child, dependency.getBottom() - child.getTop() - (headerView).getTitleHeight() - (headerView).getBarRange()); &#125; &#125; return super.onDependentViewChanged(parent, child, dependency); &#125; /** * 限制 content 滑动范围 */ @Override protected int getScrollRange(View v) &#123; if (v instanceof UCHeaderView) &#123; return ((UCHeaderView) v).getScrollRange() + ((UCHeaderView) v).getTitleHeight() + ((UCHeaderView) v).getBarRange(); &#125; return super.getScrollRange(v); &#125; UCHeaderView UCHeaderView决定头部里面所有控件的摆放和移动, 通过里面的behavior进行确定偏移(offset) UCTitleView 摆放在手机屏幕上面的外面,UCTitleView的bottom在上面屏幕的边界上 UCCenterView 正常的摆放以自己的高度的高度进行了摆放 UCTabLayout 摆在了UCCenterView后面,只不过UCTabLayout会在摆放的RecyclerView的下面,所以在UCScrollingBehavior中onDependentViewChanged和getScrollRange方法进行了体现. 1234567891011121314151617181920212223 /** * 每个child view 的布局 * 确定没个childview的位置 */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childTop = getPaddingTop(); int childLeft = getPaddingLeft(); //titleView的摆放 mTitleView.layout(childLeft, childTop - mTitleView.getMeasuredHeight(), childLeft + mTitleView.getMeasuredWidth(), childTop);// childTop += mTitleView.getMeasuredHeight(); mCenterView.layout(childLeft, childTop, childLeft + mCenterView.getMeasuredWidth(), childTop + mCenterView.getMeasuredHeight()); childTop += mCenterView.getMeasuredHeight(); mTab.layout(childLeft, childTop, childLeft + mTab.getMeasuredWidth(), childTop + mTab.getMeasuredHeight());// childTop += mTab.getMeasuredHeight(); for (View sv : mScrollableViews) &#123; sv.layout(childLeft, childTop, childLeft + sv.getMeasuredWidth(), childTop + sv.getMeasuredHeight()); childTop += sv.getMeasuredHeight(); &#125; &#125; 参考CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你飞 支付宝首页交互三部曲 3 实现支付宝首页交互","categories":[{"name":"android","slug":"android","permalink":"http://zhousaito.top/categories/android/"}],"tags":[{"name":"android behavior使用","slug":"android-behavior使用","permalink":"http://zhousaito.top/tags/android-behavior%E4%BD%BF%E7%94%A8/"}],"author":"Zhousaito"},{"title":"个人博客搭建","slug":"2019-03-04-blog-construct","date":"2019-03-04T09:13:48.017Z","updated":"2019-03-04T10:14:44.637Z","comments":true,"path":"2019/03/04/2019-03-04-blog-construct/","link":"","permalink":"http://zhousaito.top/2019/03/04/2019-03-04-blog-construct/","excerpt":"","text":"content{:toc} 开始去xudailong大佬的库 fork到自己的github上面大佬的库 fork下来之后去 setting 设置自己的库的名字把把 xudailong.github.io -&gt; xxx.github.io 12xxx 是自己的github用户的名字(这个和github建站有关) 然后clone xxx.github.io到自己的电脑上面，进行修改 通过 Jekyll 安装在本地，可以进行本地访问修改，修改好后，然后在push到github上就可以了 jekyll使用的一些细节 cd 到项目的根路径下面 然后执行命令 12# watch 可以修改过程中不进行启动服务器(修改_config.yml还是需要重启 jekyll)jekyll server --watch 启动jekyll后会出现地址，访问jekyll打印出来的地址即可 1Server address: http://127.0.0.1:4001/ 参照Github搭建个人博客(2018最新版,亲测) 在github.io上写博客 CocoaPods1.4.0 安装使用详解 1sudo gem install -n /usr/local/bin [需要安装的程序名字] 我在mac上面安装 jekyll 出现了很多错误,没有权限 写入 usr这个文件,通过这种方式进行了解决","categories":[{"name":"博客搭建指南","slug":"博客搭建指南","permalink":"http://zhousaito.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"博客搭建笔记 博客搭建备忘录","slug":"博客搭建笔记-博客搭建备忘录","permalink":"http://zhousaito.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A4%87%E5%BF%98%E5%BD%95/"}],"author":"Zhousaito"},{"title":"markdown语法(使用笔记)","slug":"2019-03-04-markdown-use","date":"2019-03-04T07:09:35.385Z","updated":"2019-03-04T09:57:26.775Z","comments":true,"path":"2019/03/04/2019-03-04-markdown-use/","link":"","permalink":"http://zhousaito.top/2019/03/04/2019-03-04-markdown-use/","excerpt":"","text":"content{:toc}一、标题 123456#标题##标题###标题####标题#####标题######标题 二、字体加粗使用**来进行表示 1如：**aaa** 这样来写 aaa 斜体1***aa*** aa 删除线1~~删除线~~ 删除线 三、引用引用 1&gt; 这个来进行 我是引用的 内容 四、分割线1使用- 或者 * 都至少连着输入三个 五、图片链接1![img的alt](地址 \"表述\") 六、链接1[链接的名称](链接地址 \"title\") 点击去百度 七、列表123456a.无序列表 - * + 这三个符号输入后 然后空格一些就可以了b.有序列表 1.[空格]内容 通过输入 1. 然后空格一下内容就可以了 无序列表 无序一 无序二 有序列表 有序一 有序二 八、表格 我是用很多次表格我觉得不太好用 1234| 一个普通标题 | 一个普通标题 | 一个普通标题 || ------ | ------ | ------ || 短文本 | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 | 九、流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: yes or no?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: yes or no?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 流程图支持的比较少,所以显示有点问题 最后参考：Markdown基本语法 感谢这位大佬分享","categories":[{"name":"markdown","slug":"markdown","permalink":"http://zhousaito.top/categories/markdown/"}],"tags":[{"name":"markdown markdown使用","slug":"markdown-markdown使用","permalink":"http://zhousaito.top/tags/markdown-markdown%E4%BD%BF%E7%94%A8/"}],"author":"Zhousaito"}]}